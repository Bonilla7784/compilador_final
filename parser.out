Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> program
Rule 1     program -> PROGRAM ID SEMICOLON create_scopes global_scope main_function end_scopes
Rule 2     global_scope -> VARIABLES LBRACE decl_list RBRACE function_decl_list
Rule 3     global_scope -> VARIABLES LBRACE decl_list RBRACE
Rule 4     function_decl_list -> function_decl function_decl_list
Rule 5     function_decl_list -> empty
Rule 6     main_function -> MAIN LPAREN RPAREN LBRACE stmt_list RBRACE
Rule 7     create_scopes -> <empty>
Rule 8     end_scopes -> <empty>
Rule 9     decl_list -> decl SEMICOLON decl_list
Rule 10    decl_list -> decl SEMICOLON
Rule 11    decl_list -> empty
Rule 12    decl -> type ID
Rule 13    decl -> array_decl SEMICOLON
Rule 14    type -> INT
Rule 15    type -> FLOAT
Rule 16    type -> STRING
Rule 17    type -> BOOL
Rule 18    stmt_list -> stmt SEMICOLON stmt_list
Rule 19    stmt_list -> stmt SEMICOLON
Rule 20    stmt -> assign
Rule 21    stmt -> print
Rule 22    stmt -> conditional
Rule 23    stmt -> loop
Rule 24    stmt -> function_call
Rule 25    stmt -> decl
Rule 26    stmt -> built_in_function
Rule 27    built_in_function -> TEACH_SUM LPAREN RPAREN
Rule 28    built_in_function -> TEACH_SUBSTRACTION LPAREN RPAREN
Rule 29    built_in_function -> TEACH_MULTIPLICATION LPAREN RPAREN
Rule 30    built_in_function -> TEACH_DIVISION LPAREN RPAREN
Rule 31    built_in_function -> TEACH_IF LPAREN RPAREN
Rule 32    built_in_function -> TEACH_WHILE LPAREN RPAREN
Rule 33    built_in_function -> TEACH_FUNCTION_DECLARATION LPAREN RPAREN
Rule 34    built_in_function -> TEACH_FUNCTION_CALL LPAREN RPAREN
Rule 35    built_in_function -> AYUDA LPAREN RPAREN
Rule 36    assign -> ID EQUALS expr
Rule 37    assign -> ID EQUALS function_call
Rule 38    expr1 -> term1
Rule 39    term1 -> factor1
Rule 40    factor1 -> ID
Rule 41    expr -> expr PLUS term
Rule 42    expr -> expr MINUS term
Rule 43    expr -> expr comp_op term
Rule 44    expr -> term
Rule 45    term -> term MULTIPLY factor
Rule 46    term -> term DIVIDE factor
Rule 47    term -> factor
Rule 48    factor -> LPAREN expr RPAREN
Rule 49    factor -> CTEI
Rule 50    factor -> FLOAT_NUMBER
Rule 51    factor -> STRING_LITERAL
Rule 52    factor -> TRUE
Rule 53    factor -> FALSE
Rule 54    factor -> ID
Rule 55    print -> PRINT COLON ID
Rule 56    conditional -> IF LPAREN comp_expr RPAREN LBRACE stmt_list RBRACE else_stmt
Rule 57    conditional -> IF LPAREN comp_expr RPAREN LBRACE stmt_list RBRACE
Rule 58    comp_expr -> expr comp_op expr
Rule 59    comp_op -> LESS_THAN
Rule 60    comp_op -> GREATER_THAN
Rule 61    comp_op -> LESS_EQUAL
Rule 62    comp_op -> GREATER_EQUAL
Rule 63    comp_op -> EQUAL_EQUAL
Rule 64    comp_op -> NOT_EQUAL
Rule 65    else_stmt -> ELSE LBRACE else_part stmt_list RBRACE
Rule 66    else_stmt -> empty
Rule 67    else_part -> <empty>
Rule 68    loop -> WHILE LPAREN comp_expr RPAREN LBRACE stmt_list RBRACE
Rule 69    create_function_scope -> <empty>
Rule 70    function_decl -> type ID LPAREN create_function_scope param_list RPAREN LBRACE stmt_list return_stmt end_scopes RBRACE
Rule 71    function_decl -> VOID ID LPAREN create_function_scope param_list RPAREN LBRACE stmt_list end_scopes RBRACE
Rule 72    return_stmt -> RETURN expr1 SEMICOLON
Rule 73    return_stmt -> empty
Rule 74    function_call -> ID LPAREN arg_list RPAREN
Rule 75    param_list -> param COMMA param_list
Rule 76    param_list -> param
Rule 77    param_list -> empty
Rule 78    param -> type ID
Rule 79    arg_list -> expr1
Rule 80    arg_list -> expr1 COMMA arg_list
Rule 81    array_decl -> type ID LBRACKET CTEI RBRACKET
Rule 82    empty -> <empty>

Terminals, with rules where they appear

AYUDA                : 35
BOOL                 : 17
COLON                : 55
COMMA                : 75 80
CTEI                 : 49 81
DIVIDE               : 46
ELSE                 : 65
EQUALS               : 36 37
EQUAL_EQUAL          : 63
FALSE                : 53
FLOAT                : 15
FLOAT_NUMBER         : 50
GREATER_EQUAL        : 62
GREATER_THAN         : 60
ID                   : 1 12 36 37 40 54 55 70 71 74 78 81
IF                   : 56 57
INT                  : 14
LBRACE               : 2 3 6 56 57 65 68 70 71
LBRACKET             : 81
LESS_EQUAL           : 61
LESS_THAN            : 59
LPAREN               : 6 27 28 29 30 31 32 33 34 35 48 56 57 68 70 71 74
MAIN                 : 6
MINUS                : 42
MULTIPLY             : 45
NOT_EQUAL            : 64
PLUS                 : 41
PRINT                : 55
PROGRAM              : 1
RBRACE               : 2 3 6 56 57 65 68 70 71
RBRACKET             : 81
RETURN               : 72
RPAREN               : 6 27 28 29 30 31 32 33 34 35 48 56 57 68 70 71 74
SEMICOLON            : 1 9 10 13 18 19 72
STRING               : 16
STRING_LITERAL       : 51
TEACH_DIVISION       : 30
TEACH_FUNCTION_CALL  : 34
TEACH_FUNCTION_DECLARATION : 33
TEACH_IF             : 31
TEACH_MULTIPLICATION : 29
TEACH_SUBSTRACTION   : 28
TEACH_SUM            : 27
TEACH_WHILE          : 32
TRUE                 : 52
VARIABLES            : 2 3
VOID                 : 71
WHILE                : 68
error                : 

Nonterminals, with rules where they appear

arg_list             : 74 80
array_decl           : 13
assign               : 20
built_in_function    : 26
comp_expr            : 56 57 68
comp_op              : 43 58
conditional          : 22
create_function_scope : 70 71
create_scopes        : 1
decl                 : 9 10 25
decl_list            : 2 3 9
else_part            : 65
else_stmt            : 56
empty                : 5 11 66 73 77
end_scopes           : 1 70 71
expr                 : 36 41 42 43 48 58 58
expr1                : 72 79 80
factor               : 45 46 47
factor1              : 39
function_call        : 24 37
function_decl        : 4
function_decl_list   : 2 4
global_scope         : 1
loop                 : 23
main_function        : 1
param                : 75 76
param_list           : 70 71 75
print                : 21
program              : 0
return_stmt          : 70
stmt                 : 18 19
stmt_list            : 6 18 56 57 65 68 70 71
term                 : 41 42 43 44 45 46
term1                : 38
type                 : 12 70 78 81

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . PROGRAM ID SEMICOLON create_scopes global_scope main_function end_scopes

    PROGRAM         shift and go to state 2

    program                        shift and go to state 1

state 1

    (0) S' -> program .



state 2

    (1) program -> PROGRAM . ID SEMICOLON create_scopes global_scope main_function end_scopes

    ID              shift and go to state 3


state 3

    (1) program -> PROGRAM ID . SEMICOLON create_scopes global_scope main_function end_scopes

    SEMICOLON       shift and go to state 4


state 4

    (1) program -> PROGRAM ID SEMICOLON . create_scopes global_scope main_function end_scopes
    (7) create_scopes -> .

    VARIABLES       reduce using rule 7 (create_scopes -> .)

    create_scopes                  shift and go to state 5

state 5

    (1) program -> PROGRAM ID SEMICOLON create_scopes . global_scope main_function end_scopes
    (2) global_scope -> . VARIABLES LBRACE decl_list RBRACE function_decl_list
    (3) global_scope -> . VARIABLES LBRACE decl_list RBRACE

    VARIABLES       shift and go to state 7

    global_scope                   shift and go to state 6

state 6

    (1) program -> PROGRAM ID SEMICOLON create_scopes global_scope . main_function end_scopes
    (6) main_function -> . MAIN LPAREN RPAREN LBRACE stmt_list RBRACE

    MAIN            shift and go to state 9

    main_function                  shift and go to state 8

state 7

    (2) global_scope -> VARIABLES . LBRACE decl_list RBRACE function_decl_list
    (3) global_scope -> VARIABLES . LBRACE decl_list RBRACE

    LBRACE          shift and go to state 10


state 8

    (1) program -> PROGRAM ID SEMICOLON create_scopes global_scope main_function . end_scopes
    (8) end_scopes -> .

    $end            reduce using rule 8 (end_scopes -> .)

    end_scopes                     shift and go to state 11

state 9

    (6) main_function -> MAIN . LPAREN RPAREN LBRACE stmt_list RBRACE

    LPAREN          shift and go to state 12


state 10

    (2) global_scope -> VARIABLES LBRACE . decl_list RBRACE function_decl_list
    (3) global_scope -> VARIABLES LBRACE . decl_list RBRACE
    (9) decl_list -> . decl SEMICOLON decl_list
    (10) decl_list -> . decl SEMICOLON
    (11) decl_list -> . empty
    (12) decl -> . type ID
    (13) decl -> . array_decl SEMICOLON
    (82) empty -> .
    (14) type -> . INT
    (15) type -> . FLOAT
    (16) type -> . STRING
    (17) type -> . BOOL
    (81) array_decl -> . type ID LBRACKET CTEI RBRACKET

    RBRACE          reduce using rule 82 (empty -> .)
    INT             shift and go to state 18
    FLOAT           shift and go to state 19
    STRING          shift and go to state 20
    BOOL            shift and go to state 21

    decl_list                      shift and go to state 13
    decl                           shift and go to state 14
    empty                          shift and go to state 15
    type                           shift and go to state 16
    array_decl                     shift and go to state 17

state 11

    (1) program -> PROGRAM ID SEMICOLON create_scopes global_scope main_function end_scopes .

    $end            reduce using rule 1 (program -> PROGRAM ID SEMICOLON create_scopes global_scope main_function end_scopes .)


state 12

    (6) main_function -> MAIN LPAREN . RPAREN LBRACE stmt_list RBRACE

    RPAREN          shift and go to state 22


state 13

    (2) global_scope -> VARIABLES LBRACE decl_list . RBRACE function_decl_list
    (3) global_scope -> VARIABLES LBRACE decl_list . RBRACE

    RBRACE          shift and go to state 23


state 14

    (9) decl_list -> decl . SEMICOLON decl_list
    (10) decl_list -> decl . SEMICOLON

    SEMICOLON       shift and go to state 24


state 15

    (11) decl_list -> empty .

    RBRACE          reduce using rule 11 (decl_list -> empty .)


state 16

    (12) decl -> type . ID
    (81) array_decl -> type . ID LBRACKET CTEI RBRACKET

    ID              shift and go to state 25


state 17

    (13) decl -> array_decl . SEMICOLON

    SEMICOLON       shift and go to state 26


state 18

    (14) type -> INT .

    ID              reduce using rule 14 (type -> INT .)


state 19

    (15) type -> FLOAT .

    ID              reduce using rule 15 (type -> FLOAT .)


state 20

    (16) type -> STRING .

    ID              reduce using rule 16 (type -> STRING .)


state 21

    (17) type -> BOOL .

    ID              reduce using rule 17 (type -> BOOL .)


state 22

    (6) main_function -> MAIN LPAREN RPAREN . LBRACE stmt_list RBRACE

    LBRACE          shift and go to state 27


state 23

    (2) global_scope -> VARIABLES LBRACE decl_list RBRACE . function_decl_list
    (3) global_scope -> VARIABLES LBRACE decl_list RBRACE .
    (4) function_decl_list -> . function_decl function_decl_list
    (5) function_decl_list -> . empty
    (70) function_decl -> . type ID LPAREN create_function_scope param_list RPAREN LBRACE stmt_list return_stmt end_scopes RBRACE
    (71) function_decl -> . VOID ID LPAREN create_function_scope param_list RPAREN LBRACE stmt_list end_scopes RBRACE
    (82) empty -> .
    (14) type -> . INT
    (15) type -> . FLOAT
    (16) type -> . STRING
    (17) type -> . BOOL

  ! reduce/reduce conflict for MAIN resolved using rule 3 (global_scope -> VARIABLES LBRACE decl_list RBRACE .)
    MAIN            reduce using rule 3 (global_scope -> VARIABLES LBRACE decl_list RBRACE .)
    VOID            shift and go to state 32
    INT             shift and go to state 18
    FLOAT           shift and go to state 19
    STRING          shift and go to state 20
    BOOL            shift and go to state 21

  ! MAIN            [ reduce using rule 82 (empty -> .) ]

    function_decl_list             shift and go to state 28
    function_decl                  shift and go to state 29
    empty                          shift and go to state 30
    type                           shift and go to state 31

state 24

    (9) decl_list -> decl SEMICOLON . decl_list
    (10) decl_list -> decl SEMICOLON .
    (9) decl_list -> . decl SEMICOLON decl_list
    (10) decl_list -> . decl SEMICOLON
    (11) decl_list -> . empty
    (12) decl -> . type ID
    (13) decl -> . array_decl SEMICOLON
    (82) empty -> .
    (14) type -> . INT
    (15) type -> . FLOAT
    (16) type -> . STRING
    (17) type -> . BOOL
    (81) array_decl -> . type ID LBRACKET CTEI RBRACKET

  ! reduce/reduce conflict for RBRACE resolved using rule 10 (decl_list -> decl SEMICOLON .)
    RBRACE          reduce using rule 10 (decl_list -> decl SEMICOLON .)
    INT             shift and go to state 18
    FLOAT           shift and go to state 19
    STRING          shift and go to state 20
    BOOL            shift and go to state 21

  ! RBRACE          [ reduce using rule 82 (empty -> .) ]

    decl                           shift and go to state 14
    decl_list                      shift and go to state 33
    empty                          shift and go to state 15
    type                           shift and go to state 16
    array_decl                     shift and go to state 17

state 25

    (12) decl -> type ID .
    (81) array_decl -> type ID . LBRACKET CTEI RBRACKET

    SEMICOLON       reduce using rule 12 (decl -> type ID .)
    LBRACKET        shift and go to state 34


state 26

    (13) decl -> array_decl SEMICOLON .

    SEMICOLON       reduce using rule 13 (decl -> array_decl SEMICOLON .)


state 27

    (6) main_function -> MAIN LPAREN RPAREN LBRACE . stmt_list RBRACE
    (18) stmt_list -> . stmt SEMICOLON stmt_list
    (19) stmt_list -> . stmt SEMICOLON
    (20) stmt -> . assign
    (21) stmt -> . print
    (22) stmt -> . conditional
    (23) stmt -> . loop
    (24) stmt -> . function_call
    (25) stmt -> . decl
    (26) stmt -> . built_in_function
    (36) assign -> . ID EQUALS expr
    (37) assign -> . ID EQUALS function_call
    (55) print -> . PRINT COLON ID
    (56) conditional -> . IF LPAREN comp_expr RPAREN LBRACE stmt_list RBRACE else_stmt
    (57) conditional -> . IF LPAREN comp_expr RPAREN LBRACE stmt_list RBRACE
    (68) loop -> . WHILE LPAREN comp_expr RPAREN LBRACE stmt_list RBRACE
    (74) function_call -> . ID LPAREN arg_list RPAREN
    (12) decl -> . type ID
    (13) decl -> . array_decl SEMICOLON
    (27) built_in_function -> . TEACH_SUM LPAREN RPAREN
    (28) built_in_function -> . TEACH_SUBSTRACTION LPAREN RPAREN
    (29) built_in_function -> . TEACH_MULTIPLICATION LPAREN RPAREN
    (30) built_in_function -> . TEACH_DIVISION LPAREN RPAREN
    (31) built_in_function -> . TEACH_IF LPAREN RPAREN
    (32) built_in_function -> . TEACH_WHILE LPAREN RPAREN
    (33) built_in_function -> . TEACH_FUNCTION_DECLARATION LPAREN RPAREN
    (34) built_in_function -> . TEACH_FUNCTION_CALL LPAREN RPAREN
    (35) built_in_function -> . AYUDA LPAREN RPAREN
    (14) type -> . INT
    (15) type -> . FLOAT
    (16) type -> . STRING
    (17) type -> . BOOL
    (81) array_decl -> . type ID LBRACKET CTEI RBRACKET

    ID              shift and go to state 44
    PRINT           shift and go to state 45
    IF              shift and go to state 46
    WHILE           shift and go to state 47
    TEACH_SUM       shift and go to state 48
    TEACH_SUBSTRACTION shift and go to state 49
    TEACH_MULTIPLICATION shift and go to state 50
    TEACH_DIVISION  shift and go to state 51
    TEACH_IF        shift and go to state 52
    TEACH_WHILE     shift and go to state 53
    TEACH_FUNCTION_DECLARATION shift and go to state 54
    TEACH_FUNCTION_CALL shift and go to state 55
    AYUDA           shift and go to state 56
    INT             shift and go to state 18
    FLOAT           shift and go to state 19
    STRING          shift and go to state 20
    BOOL            shift and go to state 21

    stmt_list                      shift and go to state 35
    stmt                           shift and go to state 36
    assign                         shift and go to state 37
    print                          shift and go to state 38
    conditional                    shift and go to state 39
    loop                           shift and go to state 40
    function_call                  shift and go to state 41
    decl                           shift and go to state 42
    built_in_function              shift and go to state 43
    type                           shift and go to state 16
    array_decl                     shift and go to state 17

state 28

    (2) global_scope -> VARIABLES LBRACE decl_list RBRACE function_decl_list .

    MAIN            reduce using rule 2 (global_scope -> VARIABLES LBRACE decl_list RBRACE function_decl_list .)


state 29

    (4) function_decl_list -> function_decl . function_decl_list
    (4) function_decl_list -> . function_decl function_decl_list
    (5) function_decl_list -> . empty
    (70) function_decl -> . type ID LPAREN create_function_scope param_list RPAREN LBRACE stmt_list return_stmt end_scopes RBRACE
    (71) function_decl -> . VOID ID LPAREN create_function_scope param_list RPAREN LBRACE stmt_list end_scopes RBRACE
    (82) empty -> .
    (14) type -> . INT
    (15) type -> . FLOAT
    (16) type -> . STRING
    (17) type -> . BOOL

    VOID            shift and go to state 32
    MAIN            reduce using rule 82 (empty -> .)
    INT             shift and go to state 18
    FLOAT           shift and go to state 19
    STRING          shift and go to state 20
    BOOL            shift and go to state 21

    function_decl                  shift and go to state 29
    function_decl_list             shift and go to state 57
    empty                          shift and go to state 30
    type                           shift and go to state 31

state 30

    (5) function_decl_list -> empty .

    MAIN            reduce using rule 5 (function_decl_list -> empty .)


state 31

    (70) function_decl -> type . ID LPAREN create_function_scope param_list RPAREN LBRACE stmt_list return_stmt end_scopes RBRACE

    ID              shift and go to state 58


state 32

    (71) function_decl -> VOID . ID LPAREN create_function_scope param_list RPAREN LBRACE stmt_list end_scopes RBRACE

    ID              shift and go to state 59


state 33

    (9) decl_list -> decl SEMICOLON decl_list .

    RBRACE          reduce using rule 9 (decl_list -> decl SEMICOLON decl_list .)


state 34

    (81) array_decl -> type ID LBRACKET . CTEI RBRACKET

    CTEI            shift and go to state 60


state 35

    (6) main_function -> MAIN LPAREN RPAREN LBRACE stmt_list . RBRACE

    RBRACE          shift and go to state 61


state 36

    (18) stmt_list -> stmt . SEMICOLON stmt_list
    (19) stmt_list -> stmt . SEMICOLON

    SEMICOLON       shift and go to state 62


state 37

    (20) stmt -> assign .

    SEMICOLON       reduce using rule 20 (stmt -> assign .)


state 38

    (21) stmt -> print .

    SEMICOLON       reduce using rule 21 (stmt -> print .)


state 39

    (22) stmt -> conditional .

    SEMICOLON       reduce using rule 22 (stmt -> conditional .)


state 40

    (23) stmt -> loop .

    SEMICOLON       reduce using rule 23 (stmt -> loop .)


state 41

    (24) stmt -> function_call .

    SEMICOLON       reduce using rule 24 (stmt -> function_call .)


state 42

    (25) stmt -> decl .

    SEMICOLON       reduce using rule 25 (stmt -> decl .)


state 43

    (26) stmt -> built_in_function .

    SEMICOLON       reduce using rule 26 (stmt -> built_in_function .)


state 44

    (36) assign -> ID . EQUALS expr
    (37) assign -> ID . EQUALS function_call
    (74) function_call -> ID . LPAREN arg_list RPAREN

    EQUALS          shift and go to state 63
    LPAREN          shift and go to state 64


state 45

    (55) print -> PRINT . COLON ID

    COLON           shift and go to state 65


state 46

    (56) conditional -> IF . LPAREN comp_expr RPAREN LBRACE stmt_list RBRACE else_stmt
    (57) conditional -> IF . LPAREN comp_expr RPAREN LBRACE stmt_list RBRACE

    LPAREN          shift and go to state 66


state 47

    (68) loop -> WHILE . LPAREN comp_expr RPAREN LBRACE stmt_list RBRACE

    LPAREN          shift and go to state 67


state 48

    (27) built_in_function -> TEACH_SUM . LPAREN RPAREN

    LPAREN          shift and go to state 68


state 49

    (28) built_in_function -> TEACH_SUBSTRACTION . LPAREN RPAREN

    LPAREN          shift and go to state 69


state 50

    (29) built_in_function -> TEACH_MULTIPLICATION . LPAREN RPAREN

    LPAREN          shift and go to state 70


state 51

    (30) built_in_function -> TEACH_DIVISION . LPAREN RPAREN

    LPAREN          shift and go to state 71


state 52

    (31) built_in_function -> TEACH_IF . LPAREN RPAREN

    LPAREN          shift and go to state 72


state 53

    (32) built_in_function -> TEACH_WHILE . LPAREN RPAREN

    LPAREN          shift and go to state 73


state 54

    (33) built_in_function -> TEACH_FUNCTION_DECLARATION . LPAREN RPAREN

    LPAREN          shift and go to state 74


state 55

    (34) built_in_function -> TEACH_FUNCTION_CALL . LPAREN RPAREN

    LPAREN          shift and go to state 75


state 56

    (35) built_in_function -> AYUDA . LPAREN RPAREN

    LPAREN          shift and go to state 76


state 57

    (4) function_decl_list -> function_decl function_decl_list .

    MAIN            reduce using rule 4 (function_decl_list -> function_decl function_decl_list .)


state 58

    (70) function_decl -> type ID . LPAREN create_function_scope param_list RPAREN LBRACE stmt_list return_stmt end_scopes RBRACE

    LPAREN          shift and go to state 77


state 59

    (71) function_decl -> VOID ID . LPAREN create_function_scope param_list RPAREN LBRACE stmt_list end_scopes RBRACE

    LPAREN          shift and go to state 78


state 60

    (81) array_decl -> type ID LBRACKET CTEI . RBRACKET

    RBRACKET        shift and go to state 79


state 61

    (6) main_function -> MAIN LPAREN RPAREN LBRACE stmt_list RBRACE .

    $end            reduce using rule 6 (main_function -> MAIN LPAREN RPAREN LBRACE stmt_list RBRACE .)


state 62

    (18) stmt_list -> stmt SEMICOLON . stmt_list
    (19) stmt_list -> stmt SEMICOLON .
    (18) stmt_list -> . stmt SEMICOLON stmt_list
    (19) stmt_list -> . stmt SEMICOLON
    (20) stmt -> . assign
    (21) stmt -> . print
    (22) stmt -> . conditional
    (23) stmt -> . loop
    (24) stmt -> . function_call
    (25) stmt -> . decl
    (26) stmt -> . built_in_function
    (36) assign -> . ID EQUALS expr
    (37) assign -> . ID EQUALS function_call
    (55) print -> . PRINT COLON ID
    (56) conditional -> . IF LPAREN comp_expr RPAREN LBRACE stmt_list RBRACE else_stmt
    (57) conditional -> . IF LPAREN comp_expr RPAREN LBRACE stmt_list RBRACE
    (68) loop -> . WHILE LPAREN comp_expr RPAREN LBRACE stmt_list RBRACE
    (74) function_call -> . ID LPAREN arg_list RPAREN
    (12) decl -> . type ID
    (13) decl -> . array_decl SEMICOLON
    (27) built_in_function -> . TEACH_SUM LPAREN RPAREN
    (28) built_in_function -> . TEACH_SUBSTRACTION LPAREN RPAREN
    (29) built_in_function -> . TEACH_MULTIPLICATION LPAREN RPAREN
    (30) built_in_function -> . TEACH_DIVISION LPAREN RPAREN
    (31) built_in_function -> . TEACH_IF LPAREN RPAREN
    (32) built_in_function -> . TEACH_WHILE LPAREN RPAREN
    (33) built_in_function -> . TEACH_FUNCTION_DECLARATION LPAREN RPAREN
    (34) built_in_function -> . TEACH_FUNCTION_CALL LPAREN RPAREN
    (35) built_in_function -> . AYUDA LPAREN RPAREN
    (14) type -> . INT
    (15) type -> . FLOAT
    (16) type -> . STRING
    (17) type -> . BOOL
    (81) array_decl -> . type ID LBRACKET CTEI RBRACKET

    RBRACE          reduce using rule 19 (stmt_list -> stmt SEMICOLON .)
    RETURN          reduce using rule 19 (stmt_list -> stmt SEMICOLON .)
    ID              shift and go to state 44
    PRINT           shift and go to state 45
    IF              shift and go to state 46
    WHILE           shift and go to state 47
    TEACH_SUM       shift and go to state 48
    TEACH_SUBSTRACTION shift and go to state 49
    TEACH_MULTIPLICATION shift and go to state 50
    TEACH_DIVISION  shift and go to state 51
    TEACH_IF        shift and go to state 52
    TEACH_WHILE     shift and go to state 53
    TEACH_FUNCTION_DECLARATION shift and go to state 54
    TEACH_FUNCTION_CALL shift and go to state 55
    AYUDA           shift and go to state 56
    INT             shift and go to state 18
    FLOAT           shift and go to state 19
    STRING          shift and go to state 20
    BOOL            shift and go to state 21

    stmt                           shift and go to state 36
    stmt_list                      shift and go to state 80
    assign                         shift and go to state 37
    print                          shift and go to state 38
    conditional                    shift and go to state 39
    loop                           shift and go to state 40
    function_call                  shift and go to state 41
    decl                           shift and go to state 42
    built_in_function              shift and go to state 43
    type                           shift and go to state 16
    array_decl                     shift and go to state 17

state 63

    (36) assign -> ID EQUALS . expr
    (37) assign -> ID EQUALS . function_call
    (41) expr -> . expr PLUS term
    (42) expr -> . expr MINUS term
    (43) expr -> . expr comp_op term
    (44) expr -> . term
    (74) function_call -> . ID LPAREN arg_list RPAREN
    (45) term -> . term MULTIPLY factor
    (46) term -> . term DIVIDE factor
    (47) term -> . factor
    (48) factor -> . LPAREN expr RPAREN
    (49) factor -> . CTEI
    (50) factor -> . FLOAT_NUMBER
    (51) factor -> . STRING_LITERAL
    (52) factor -> . TRUE
    (53) factor -> . FALSE
    (54) factor -> . ID

    ID              shift and go to state 81
    LPAREN          shift and go to state 85
    CTEI            shift and go to state 87
    FLOAT_NUMBER    shift and go to state 88
    STRING_LITERAL  shift and go to state 89
    TRUE            shift and go to state 90
    FALSE           shift and go to state 91

    expr                           shift and go to state 82
    function_call                  shift and go to state 83
    term                           shift and go to state 84
    factor                         shift and go to state 86

state 64

    (74) function_call -> ID LPAREN . arg_list RPAREN
    (79) arg_list -> . expr1
    (80) arg_list -> . expr1 COMMA arg_list
    (38) expr1 -> . term1
    (39) term1 -> . factor1
    (40) factor1 -> . ID

    ID              shift and go to state 92

    arg_list                       shift and go to state 93
    expr1                          shift and go to state 94
    term1                          shift and go to state 95
    factor1                        shift and go to state 96

state 65

    (55) print -> PRINT COLON . ID

    ID              shift and go to state 97


state 66

    (56) conditional -> IF LPAREN . comp_expr RPAREN LBRACE stmt_list RBRACE else_stmt
    (57) conditional -> IF LPAREN . comp_expr RPAREN LBRACE stmt_list RBRACE
    (58) comp_expr -> . expr comp_op expr
    (41) expr -> . expr PLUS term
    (42) expr -> . expr MINUS term
    (43) expr -> . expr comp_op term
    (44) expr -> . term
    (45) term -> . term MULTIPLY factor
    (46) term -> . term DIVIDE factor
    (47) term -> . factor
    (48) factor -> . LPAREN expr RPAREN
    (49) factor -> . CTEI
    (50) factor -> . FLOAT_NUMBER
    (51) factor -> . STRING_LITERAL
    (52) factor -> . TRUE
    (53) factor -> . FALSE
    (54) factor -> . ID

    LPAREN          shift and go to state 85
    CTEI            shift and go to state 87
    FLOAT_NUMBER    shift and go to state 88
    STRING_LITERAL  shift and go to state 89
    TRUE            shift and go to state 90
    FALSE           shift and go to state 91
    ID              shift and go to state 100

    comp_expr                      shift and go to state 98
    expr                           shift and go to state 99
    term                           shift and go to state 84
    factor                         shift and go to state 86

state 67

    (68) loop -> WHILE LPAREN . comp_expr RPAREN LBRACE stmt_list RBRACE
    (58) comp_expr -> . expr comp_op expr
    (41) expr -> . expr PLUS term
    (42) expr -> . expr MINUS term
    (43) expr -> . expr comp_op term
    (44) expr -> . term
    (45) term -> . term MULTIPLY factor
    (46) term -> . term DIVIDE factor
    (47) term -> . factor
    (48) factor -> . LPAREN expr RPAREN
    (49) factor -> . CTEI
    (50) factor -> . FLOAT_NUMBER
    (51) factor -> . STRING_LITERAL
    (52) factor -> . TRUE
    (53) factor -> . FALSE
    (54) factor -> . ID

    LPAREN          shift and go to state 85
    CTEI            shift and go to state 87
    FLOAT_NUMBER    shift and go to state 88
    STRING_LITERAL  shift and go to state 89
    TRUE            shift and go to state 90
    FALSE           shift and go to state 91
    ID              shift and go to state 100

    comp_expr                      shift and go to state 101
    expr                           shift and go to state 99
    term                           shift and go to state 84
    factor                         shift and go to state 86

state 68

    (27) built_in_function -> TEACH_SUM LPAREN . RPAREN

    RPAREN          shift and go to state 102


state 69

    (28) built_in_function -> TEACH_SUBSTRACTION LPAREN . RPAREN

    RPAREN          shift and go to state 103


state 70

    (29) built_in_function -> TEACH_MULTIPLICATION LPAREN . RPAREN

    RPAREN          shift and go to state 104


state 71

    (30) built_in_function -> TEACH_DIVISION LPAREN . RPAREN

    RPAREN          shift and go to state 105


state 72

    (31) built_in_function -> TEACH_IF LPAREN . RPAREN

    RPAREN          shift and go to state 106


state 73

    (32) built_in_function -> TEACH_WHILE LPAREN . RPAREN

    RPAREN          shift and go to state 107


state 74

    (33) built_in_function -> TEACH_FUNCTION_DECLARATION LPAREN . RPAREN

    RPAREN          shift and go to state 108


state 75

    (34) built_in_function -> TEACH_FUNCTION_CALL LPAREN . RPAREN

    RPAREN          shift and go to state 109


state 76

    (35) built_in_function -> AYUDA LPAREN . RPAREN

    RPAREN          shift and go to state 110


state 77

    (70) function_decl -> type ID LPAREN . create_function_scope param_list RPAREN LBRACE stmt_list return_stmt end_scopes RBRACE
    (69) create_function_scope -> .

    INT             reduce using rule 69 (create_function_scope -> .)
    FLOAT           reduce using rule 69 (create_function_scope -> .)
    STRING          reduce using rule 69 (create_function_scope -> .)
    BOOL            reduce using rule 69 (create_function_scope -> .)
    RPAREN          reduce using rule 69 (create_function_scope -> .)

    create_function_scope          shift and go to state 111

state 78

    (71) function_decl -> VOID ID LPAREN . create_function_scope param_list RPAREN LBRACE stmt_list end_scopes RBRACE
    (69) create_function_scope -> .

    INT             reduce using rule 69 (create_function_scope -> .)
    FLOAT           reduce using rule 69 (create_function_scope -> .)
    STRING          reduce using rule 69 (create_function_scope -> .)
    BOOL            reduce using rule 69 (create_function_scope -> .)
    RPAREN          reduce using rule 69 (create_function_scope -> .)

    create_function_scope          shift and go to state 112

state 79

    (81) array_decl -> type ID LBRACKET CTEI RBRACKET .

    SEMICOLON       reduce using rule 81 (array_decl -> type ID LBRACKET CTEI RBRACKET .)


state 80

    (18) stmt_list -> stmt SEMICOLON stmt_list .

    RBRACE          reduce using rule 18 (stmt_list -> stmt SEMICOLON stmt_list .)
    RETURN          reduce using rule 18 (stmt_list -> stmt SEMICOLON stmt_list .)


state 81

    (74) function_call -> ID . LPAREN arg_list RPAREN
    (54) factor -> ID .

    LPAREN          shift and go to state 64
    MULTIPLY        reduce using rule 54 (factor -> ID .)
    DIVIDE          reduce using rule 54 (factor -> ID .)
    PLUS            reduce using rule 54 (factor -> ID .)
    MINUS           reduce using rule 54 (factor -> ID .)
    LESS_THAN       reduce using rule 54 (factor -> ID .)
    GREATER_THAN    reduce using rule 54 (factor -> ID .)
    LESS_EQUAL      reduce using rule 54 (factor -> ID .)
    GREATER_EQUAL   reduce using rule 54 (factor -> ID .)
    EQUAL_EQUAL     reduce using rule 54 (factor -> ID .)
    NOT_EQUAL       reduce using rule 54 (factor -> ID .)
    SEMICOLON       reduce using rule 54 (factor -> ID .)


state 82

    (36) assign -> ID EQUALS expr .
    (41) expr -> expr . PLUS term
    (42) expr -> expr . MINUS term
    (43) expr -> expr . comp_op term
    (59) comp_op -> . LESS_THAN
    (60) comp_op -> . GREATER_THAN
    (61) comp_op -> . LESS_EQUAL
    (62) comp_op -> . GREATER_EQUAL
    (63) comp_op -> . EQUAL_EQUAL
    (64) comp_op -> . NOT_EQUAL

    SEMICOLON       reduce using rule 36 (assign -> ID EQUALS expr .)
    PLUS            shift and go to state 113
    MINUS           shift and go to state 114
    LESS_THAN       shift and go to state 116
    GREATER_THAN    shift and go to state 117
    LESS_EQUAL      shift and go to state 118
    GREATER_EQUAL   shift and go to state 119
    EQUAL_EQUAL     shift and go to state 120
    NOT_EQUAL       shift and go to state 121

    comp_op                        shift and go to state 115

state 83

    (37) assign -> ID EQUALS function_call .

    SEMICOLON       reduce using rule 37 (assign -> ID EQUALS function_call .)


state 84

    (44) expr -> term .
    (45) term -> term . MULTIPLY factor
    (46) term -> term . DIVIDE factor

    PLUS            reduce using rule 44 (expr -> term .)
    MINUS           reduce using rule 44 (expr -> term .)
    LESS_THAN       reduce using rule 44 (expr -> term .)
    GREATER_THAN    reduce using rule 44 (expr -> term .)
    LESS_EQUAL      reduce using rule 44 (expr -> term .)
    GREATER_EQUAL   reduce using rule 44 (expr -> term .)
    EQUAL_EQUAL     reduce using rule 44 (expr -> term .)
    NOT_EQUAL       reduce using rule 44 (expr -> term .)
    SEMICOLON       reduce using rule 44 (expr -> term .)
    RPAREN          reduce using rule 44 (expr -> term .)
    MULTIPLY        shift and go to state 122
    DIVIDE          shift and go to state 123


state 85

    (48) factor -> LPAREN . expr RPAREN
    (41) expr -> . expr PLUS term
    (42) expr -> . expr MINUS term
    (43) expr -> . expr comp_op term
    (44) expr -> . term
    (45) term -> . term MULTIPLY factor
    (46) term -> . term DIVIDE factor
    (47) term -> . factor
    (48) factor -> . LPAREN expr RPAREN
    (49) factor -> . CTEI
    (50) factor -> . FLOAT_NUMBER
    (51) factor -> . STRING_LITERAL
    (52) factor -> . TRUE
    (53) factor -> . FALSE
    (54) factor -> . ID

    LPAREN          shift and go to state 85
    CTEI            shift and go to state 87
    FLOAT_NUMBER    shift and go to state 88
    STRING_LITERAL  shift and go to state 89
    TRUE            shift and go to state 90
    FALSE           shift and go to state 91
    ID              shift and go to state 100

    expr                           shift and go to state 124
    term                           shift and go to state 84
    factor                         shift and go to state 86

state 86

    (47) term -> factor .

    MULTIPLY        reduce using rule 47 (term -> factor .)
    DIVIDE          reduce using rule 47 (term -> factor .)
    PLUS            reduce using rule 47 (term -> factor .)
    MINUS           reduce using rule 47 (term -> factor .)
    LESS_THAN       reduce using rule 47 (term -> factor .)
    GREATER_THAN    reduce using rule 47 (term -> factor .)
    LESS_EQUAL      reduce using rule 47 (term -> factor .)
    GREATER_EQUAL   reduce using rule 47 (term -> factor .)
    EQUAL_EQUAL     reduce using rule 47 (term -> factor .)
    NOT_EQUAL       reduce using rule 47 (term -> factor .)
    SEMICOLON       reduce using rule 47 (term -> factor .)
    RPAREN          reduce using rule 47 (term -> factor .)


state 87

    (49) factor -> CTEI .

    MULTIPLY        reduce using rule 49 (factor -> CTEI .)
    DIVIDE          reduce using rule 49 (factor -> CTEI .)
    PLUS            reduce using rule 49 (factor -> CTEI .)
    MINUS           reduce using rule 49 (factor -> CTEI .)
    LESS_THAN       reduce using rule 49 (factor -> CTEI .)
    GREATER_THAN    reduce using rule 49 (factor -> CTEI .)
    LESS_EQUAL      reduce using rule 49 (factor -> CTEI .)
    GREATER_EQUAL   reduce using rule 49 (factor -> CTEI .)
    EQUAL_EQUAL     reduce using rule 49 (factor -> CTEI .)
    NOT_EQUAL       reduce using rule 49 (factor -> CTEI .)
    SEMICOLON       reduce using rule 49 (factor -> CTEI .)
    RPAREN          reduce using rule 49 (factor -> CTEI .)


state 88

    (50) factor -> FLOAT_NUMBER .

    MULTIPLY        reduce using rule 50 (factor -> FLOAT_NUMBER .)
    DIVIDE          reduce using rule 50 (factor -> FLOAT_NUMBER .)
    PLUS            reduce using rule 50 (factor -> FLOAT_NUMBER .)
    MINUS           reduce using rule 50 (factor -> FLOAT_NUMBER .)
    LESS_THAN       reduce using rule 50 (factor -> FLOAT_NUMBER .)
    GREATER_THAN    reduce using rule 50 (factor -> FLOAT_NUMBER .)
    LESS_EQUAL      reduce using rule 50 (factor -> FLOAT_NUMBER .)
    GREATER_EQUAL   reduce using rule 50 (factor -> FLOAT_NUMBER .)
    EQUAL_EQUAL     reduce using rule 50 (factor -> FLOAT_NUMBER .)
    NOT_EQUAL       reduce using rule 50 (factor -> FLOAT_NUMBER .)
    SEMICOLON       reduce using rule 50 (factor -> FLOAT_NUMBER .)
    RPAREN          reduce using rule 50 (factor -> FLOAT_NUMBER .)


state 89

    (51) factor -> STRING_LITERAL .

    MULTIPLY        reduce using rule 51 (factor -> STRING_LITERAL .)
    DIVIDE          reduce using rule 51 (factor -> STRING_LITERAL .)
    PLUS            reduce using rule 51 (factor -> STRING_LITERAL .)
    MINUS           reduce using rule 51 (factor -> STRING_LITERAL .)
    LESS_THAN       reduce using rule 51 (factor -> STRING_LITERAL .)
    GREATER_THAN    reduce using rule 51 (factor -> STRING_LITERAL .)
    LESS_EQUAL      reduce using rule 51 (factor -> STRING_LITERAL .)
    GREATER_EQUAL   reduce using rule 51 (factor -> STRING_LITERAL .)
    EQUAL_EQUAL     reduce using rule 51 (factor -> STRING_LITERAL .)
    NOT_EQUAL       reduce using rule 51 (factor -> STRING_LITERAL .)
    SEMICOLON       reduce using rule 51 (factor -> STRING_LITERAL .)
    RPAREN          reduce using rule 51 (factor -> STRING_LITERAL .)


state 90

    (52) factor -> TRUE .

    MULTIPLY        reduce using rule 52 (factor -> TRUE .)
    DIVIDE          reduce using rule 52 (factor -> TRUE .)
    PLUS            reduce using rule 52 (factor -> TRUE .)
    MINUS           reduce using rule 52 (factor -> TRUE .)
    LESS_THAN       reduce using rule 52 (factor -> TRUE .)
    GREATER_THAN    reduce using rule 52 (factor -> TRUE .)
    LESS_EQUAL      reduce using rule 52 (factor -> TRUE .)
    GREATER_EQUAL   reduce using rule 52 (factor -> TRUE .)
    EQUAL_EQUAL     reduce using rule 52 (factor -> TRUE .)
    NOT_EQUAL       reduce using rule 52 (factor -> TRUE .)
    SEMICOLON       reduce using rule 52 (factor -> TRUE .)
    RPAREN          reduce using rule 52 (factor -> TRUE .)


state 91

    (53) factor -> FALSE .

    MULTIPLY        reduce using rule 53 (factor -> FALSE .)
    DIVIDE          reduce using rule 53 (factor -> FALSE .)
    PLUS            reduce using rule 53 (factor -> FALSE .)
    MINUS           reduce using rule 53 (factor -> FALSE .)
    LESS_THAN       reduce using rule 53 (factor -> FALSE .)
    GREATER_THAN    reduce using rule 53 (factor -> FALSE .)
    LESS_EQUAL      reduce using rule 53 (factor -> FALSE .)
    GREATER_EQUAL   reduce using rule 53 (factor -> FALSE .)
    EQUAL_EQUAL     reduce using rule 53 (factor -> FALSE .)
    NOT_EQUAL       reduce using rule 53 (factor -> FALSE .)
    SEMICOLON       reduce using rule 53 (factor -> FALSE .)
    RPAREN          reduce using rule 53 (factor -> FALSE .)


state 92

    (40) factor1 -> ID .

    COMMA           reduce using rule 40 (factor1 -> ID .)
    RPAREN          reduce using rule 40 (factor1 -> ID .)
    SEMICOLON       reduce using rule 40 (factor1 -> ID .)


state 93

    (74) function_call -> ID LPAREN arg_list . RPAREN

    RPAREN          shift and go to state 125


state 94

    (79) arg_list -> expr1 .
    (80) arg_list -> expr1 . COMMA arg_list

    RPAREN          reduce using rule 79 (arg_list -> expr1 .)
    COMMA           shift and go to state 126


state 95

    (38) expr1 -> term1 .

    COMMA           reduce using rule 38 (expr1 -> term1 .)
    RPAREN          reduce using rule 38 (expr1 -> term1 .)
    SEMICOLON       reduce using rule 38 (expr1 -> term1 .)


state 96

    (39) term1 -> factor1 .

    COMMA           reduce using rule 39 (term1 -> factor1 .)
    RPAREN          reduce using rule 39 (term1 -> factor1 .)
    SEMICOLON       reduce using rule 39 (term1 -> factor1 .)


state 97

    (55) print -> PRINT COLON ID .

    SEMICOLON       reduce using rule 55 (print -> PRINT COLON ID .)


state 98

    (56) conditional -> IF LPAREN comp_expr . RPAREN LBRACE stmt_list RBRACE else_stmt
    (57) conditional -> IF LPAREN comp_expr . RPAREN LBRACE stmt_list RBRACE

    RPAREN          shift and go to state 127


state 99

    (58) comp_expr -> expr . comp_op expr
    (41) expr -> expr . PLUS term
    (42) expr -> expr . MINUS term
    (43) expr -> expr . comp_op term
    (59) comp_op -> . LESS_THAN
    (60) comp_op -> . GREATER_THAN
    (61) comp_op -> . LESS_EQUAL
    (62) comp_op -> . GREATER_EQUAL
    (63) comp_op -> . EQUAL_EQUAL
    (64) comp_op -> . NOT_EQUAL

    PLUS            shift and go to state 113
    MINUS           shift and go to state 114
    LESS_THAN       shift and go to state 116
    GREATER_THAN    shift and go to state 117
    LESS_EQUAL      shift and go to state 118
    GREATER_EQUAL   shift and go to state 119
    EQUAL_EQUAL     shift and go to state 120
    NOT_EQUAL       shift and go to state 121

    comp_op                        shift and go to state 128

state 100

    (54) factor -> ID .

    MULTIPLY        reduce using rule 54 (factor -> ID .)
    DIVIDE          reduce using rule 54 (factor -> ID .)
    PLUS            reduce using rule 54 (factor -> ID .)
    MINUS           reduce using rule 54 (factor -> ID .)
    LESS_THAN       reduce using rule 54 (factor -> ID .)
    GREATER_THAN    reduce using rule 54 (factor -> ID .)
    LESS_EQUAL      reduce using rule 54 (factor -> ID .)
    GREATER_EQUAL   reduce using rule 54 (factor -> ID .)
    EQUAL_EQUAL     reduce using rule 54 (factor -> ID .)
    NOT_EQUAL       reduce using rule 54 (factor -> ID .)
    RPAREN          reduce using rule 54 (factor -> ID .)
    SEMICOLON       reduce using rule 54 (factor -> ID .)


state 101

    (68) loop -> WHILE LPAREN comp_expr . RPAREN LBRACE stmt_list RBRACE

    RPAREN          shift and go to state 129


state 102

    (27) built_in_function -> TEACH_SUM LPAREN RPAREN .

    SEMICOLON       reduce using rule 27 (built_in_function -> TEACH_SUM LPAREN RPAREN .)


state 103

    (28) built_in_function -> TEACH_SUBSTRACTION LPAREN RPAREN .

    SEMICOLON       reduce using rule 28 (built_in_function -> TEACH_SUBSTRACTION LPAREN RPAREN .)


state 104

    (29) built_in_function -> TEACH_MULTIPLICATION LPAREN RPAREN .

    SEMICOLON       reduce using rule 29 (built_in_function -> TEACH_MULTIPLICATION LPAREN RPAREN .)


state 105

    (30) built_in_function -> TEACH_DIVISION LPAREN RPAREN .

    SEMICOLON       reduce using rule 30 (built_in_function -> TEACH_DIVISION LPAREN RPAREN .)


state 106

    (31) built_in_function -> TEACH_IF LPAREN RPAREN .

    SEMICOLON       reduce using rule 31 (built_in_function -> TEACH_IF LPAREN RPAREN .)


state 107

    (32) built_in_function -> TEACH_WHILE LPAREN RPAREN .

    SEMICOLON       reduce using rule 32 (built_in_function -> TEACH_WHILE LPAREN RPAREN .)


state 108

    (33) built_in_function -> TEACH_FUNCTION_DECLARATION LPAREN RPAREN .

    SEMICOLON       reduce using rule 33 (built_in_function -> TEACH_FUNCTION_DECLARATION LPAREN RPAREN .)


state 109

    (34) built_in_function -> TEACH_FUNCTION_CALL LPAREN RPAREN .

    SEMICOLON       reduce using rule 34 (built_in_function -> TEACH_FUNCTION_CALL LPAREN RPAREN .)


state 110

    (35) built_in_function -> AYUDA LPAREN RPAREN .

    SEMICOLON       reduce using rule 35 (built_in_function -> AYUDA LPAREN RPAREN .)


state 111

    (70) function_decl -> type ID LPAREN create_function_scope . param_list RPAREN LBRACE stmt_list return_stmt end_scopes RBRACE
    (75) param_list -> . param COMMA param_list
    (76) param_list -> . param
    (77) param_list -> . empty
    (78) param -> . type ID
    (82) empty -> .
    (14) type -> . INT
    (15) type -> . FLOAT
    (16) type -> . STRING
    (17) type -> . BOOL

    RPAREN          reduce using rule 82 (empty -> .)
    INT             shift and go to state 18
    FLOAT           shift and go to state 19
    STRING          shift and go to state 20
    BOOL            shift and go to state 21

    type                           shift and go to state 130
    param_list                     shift and go to state 131
    param                          shift and go to state 132
    empty                          shift and go to state 133

state 112

    (71) function_decl -> VOID ID LPAREN create_function_scope . param_list RPAREN LBRACE stmt_list end_scopes RBRACE
    (75) param_list -> . param COMMA param_list
    (76) param_list -> . param
    (77) param_list -> . empty
    (78) param -> . type ID
    (82) empty -> .
    (14) type -> . INT
    (15) type -> . FLOAT
    (16) type -> . STRING
    (17) type -> . BOOL

    RPAREN          reduce using rule 82 (empty -> .)
    INT             shift and go to state 18
    FLOAT           shift and go to state 19
    STRING          shift and go to state 20
    BOOL            shift and go to state 21

    param_list                     shift and go to state 134
    param                          shift and go to state 132
    empty                          shift and go to state 133
    type                           shift and go to state 130

state 113

    (41) expr -> expr PLUS . term
    (45) term -> . term MULTIPLY factor
    (46) term -> . term DIVIDE factor
    (47) term -> . factor
    (48) factor -> . LPAREN expr RPAREN
    (49) factor -> . CTEI
    (50) factor -> . FLOAT_NUMBER
    (51) factor -> . STRING_LITERAL
    (52) factor -> . TRUE
    (53) factor -> . FALSE
    (54) factor -> . ID

    LPAREN          shift and go to state 85
    CTEI            shift and go to state 87
    FLOAT_NUMBER    shift and go to state 88
    STRING_LITERAL  shift and go to state 89
    TRUE            shift and go to state 90
    FALSE           shift and go to state 91
    ID              shift and go to state 100

    term                           shift and go to state 135
    factor                         shift and go to state 86

state 114

    (42) expr -> expr MINUS . term
    (45) term -> . term MULTIPLY factor
    (46) term -> . term DIVIDE factor
    (47) term -> . factor
    (48) factor -> . LPAREN expr RPAREN
    (49) factor -> . CTEI
    (50) factor -> . FLOAT_NUMBER
    (51) factor -> . STRING_LITERAL
    (52) factor -> . TRUE
    (53) factor -> . FALSE
    (54) factor -> . ID

    LPAREN          shift and go to state 85
    CTEI            shift and go to state 87
    FLOAT_NUMBER    shift and go to state 88
    STRING_LITERAL  shift and go to state 89
    TRUE            shift and go to state 90
    FALSE           shift and go to state 91
    ID              shift and go to state 100

    term                           shift and go to state 136
    factor                         shift and go to state 86

state 115

    (43) expr -> expr comp_op . term
    (45) term -> . term MULTIPLY factor
    (46) term -> . term DIVIDE factor
    (47) term -> . factor
    (48) factor -> . LPAREN expr RPAREN
    (49) factor -> . CTEI
    (50) factor -> . FLOAT_NUMBER
    (51) factor -> . STRING_LITERAL
    (52) factor -> . TRUE
    (53) factor -> . FALSE
    (54) factor -> . ID

    LPAREN          shift and go to state 85
    CTEI            shift and go to state 87
    FLOAT_NUMBER    shift and go to state 88
    STRING_LITERAL  shift and go to state 89
    TRUE            shift and go to state 90
    FALSE           shift and go to state 91
    ID              shift and go to state 100

    term                           shift and go to state 137
    factor                         shift and go to state 86

state 116

    (59) comp_op -> LESS_THAN .

    LPAREN          reduce using rule 59 (comp_op -> LESS_THAN .)
    CTEI            reduce using rule 59 (comp_op -> LESS_THAN .)
    FLOAT_NUMBER    reduce using rule 59 (comp_op -> LESS_THAN .)
    STRING_LITERAL  reduce using rule 59 (comp_op -> LESS_THAN .)
    TRUE            reduce using rule 59 (comp_op -> LESS_THAN .)
    FALSE           reduce using rule 59 (comp_op -> LESS_THAN .)
    ID              reduce using rule 59 (comp_op -> LESS_THAN .)


state 117

    (60) comp_op -> GREATER_THAN .

    LPAREN          reduce using rule 60 (comp_op -> GREATER_THAN .)
    CTEI            reduce using rule 60 (comp_op -> GREATER_THAN .)
    FLOAT_NUMBER    reduce using rule 60 (comp_op -> GREATER_THAN .)
    STRING_LITERAL  reduce using rule 60 (comp_op -> GREATER_THAN .)
    TRUE            reduce using rule 60 (comp_op -> GREATER_THAN .)
    FALSE           reduce using rule 60 (comp_op -> GREATER_THAN .)
    ID              reduce using rule 60 (comp_op -> GREATER_THAN .)


state 118

    (61) comp_op -> LESS_EQUAL .

    LPAREN          reduce using rule 61 (comp_op -> LESS_EQUAL .)
    CTEI            reduce using rule 61 (comp_op -> LESS_EQUAL .)
    FLOAT_NUMBER    reduce using rule 61 (comp_op -> LESS_EQUAL .)
    STRING_LITERAL  reduce using rule 61 (comp_op -> LESS_EQUAL .)
    TRUE            reduce using rule 61 (comp_op -> LESS_EQUAL .)
    FALSE           reduce using rule 61 (comp_op -> LESS_EQUAL .)
    ID              reduce using rule 61 (comp_op -> LESS_EQUAL .)


state 119

    (62) comp_op -> GREATER_EQUAL .

    LPAREN          reduce using rule 62 (comp_op -> GREATER_EQUAL .)
    CTEI            reduce using rule 62 (comp_op -> GREATER_EQUAL .)
    FLOAT_NUMBER    reduce using rule 62 (comp_op -> GREATER_EQUAL .)
    STRING_LITERAL  reduce using rule 62 (comp_op -> GREATER_EQUAL .)
    TRUE            reduce using rule 62 (comp_op -> GREATER_EQUAL .)
    FALSE           reduce using rule 62 (comp_op -> GREATER_EQUAL .)
    ID              reduce using rule 62 (comp_op -> GREATER_EQUAL .)


state 120

    (63) comp_op -> EQUAL_EQUAL .

    LPAREN          reduce using rule 63 (comp_op -> EQUAL_EQUAL .)
    CTEI            reduce using rule 63 (comp_op -> EQUAL_EQUAL .)
    FLOAT_NUMBER    reduce using rule 63 (comp_op -> EQUAL_EQUAL .)
    STRING_LITERAL  reduce using rule 63 (comp_op -> EQUAL_EQUAL .)
    TRUE            reduce using rule 63 (comp_op -> EQUAL_EQUAL .)
    FALSE           reduce using rule 63 (comp_op -> EQUAL_EQUAL .)
    ID              reduce using rule 63 (comp_op -> EQUAL_EQUAL .)


state 121

    (64) comp_op -> NOT_EQUAL .

    LPAREN          reduce using rule 64 (comp_op -> NOT_EQUAL .)
    CTEI            reduce using rule 64 (comp_op -> NOT_EQUAL .)
    FLOAT_NUMBER    reduce using rule 64 (comp_op -> NOT_EQUAL .)
    STRING_LITERAL  reduce using rule 64 (comp_op -> NOT_EQUAL .)
    TRUE            reduce using rule 64 (comp_op -> NOT_EQUAL .)
    FALSE           reduce using rule 64 (comp_op -> NOT_EQUAL .)
    ID              reduce using rule 64 (comp_op -> NOT_EQUAL .)


state 122

    (45) term -> term MULTIPLY . factor
    (48) factor -> . LPAREN expr RPAREN
    (49) factor -> . CTEI
    (50) factor -> . FLOAT_NUMBER
    (51) factor -> . STRING_LITERAL
    (52) factor -> . TRUE
    (53) factor -> . FALSE
    (54) factor -> . ID

    LPAREN          shift and go to state 85
    CTEI            shift and go to state 87
    FLOAT_NUMBER    shift and go to state 88
    STRING_LITERAL  shift and go to state 89
    TRUE            shift and go to state 90
    FALSE           shift and go to state 91
    ID              shift and go to state 100

    factor                         shift and go to state 138

state 123

    (46) term -> term DIVIDE . factor
    (48) factor -> . LPAREN expr RPAREN
    (49) factor -> . CTEI
    (50) factor -> . FLOAT_NUMBER
    (51) factor -> . STRING_LITERAL
    (52) factor -> . TRUE
    (53) factor -> . FALSE
    (54) factor -> . ID

    LPAREN          shift and go to state 85
    CTEI            shift and go to state 87
    FLOAT_NUMBER    shift and go to state 88
    STRING_LITERAL  shift and go to state 89
    TRUE            shift and go to state 90
    FALSE           shift and go to state 91
    ID              shift and go to state 100

    factor                         shift and go to state 139

state 124

    (48) factor -> LPAREN expr . RPAREN
    (41) expr -> expr . PLUS term
    (42) expr -> expr . MINUS term
    (43) expr -> expr . comp_op term
    (59) comp_op -> . LESS_THAN
    (60) comp_op -> . GREATER_THAN
    (61) comp_op -> . LESS_EQUAL
    (62) comp_op -> . GREATER_EQUAL
    (63) comp_op -> . EQUAL_EQUAL
    (64) comp_op -> . NOT_EQUAL

    RPAREN          shift and go to state 140
    PLUS            shift and go to state 113
    MINUS           shift and go to state 114
    LESS_THAN       shift and go to state 116
    GREATER_THAN    shift and go to state 117
    LESS_EQUAL      shift and go to state 118
    GREATER_EQUAL   shift and go to state 119
    EQUAL_EQUAL     shift and go to state 120
    NOT_EQUAL       shift and go to state 121

    comp_op                        shift and go to state 115

state 125

    (74) function_call -> ID LPAREN arg_list RPAREN .

    SEMICOLON       reduce using rule 74 (function_call -> ID LPAREN arg_list RPAREN .)


state 126

    (80) arg_list -> expr1 COMMA . arg_list
    (79) arg_list -> . expr1
    (80) arg_list -> . expr1 COMMA arg_list
    (38) expr1 -> . term1
    (39) term1 -> . factor1
    (40) factor1 -> . ID

    ID              shift and go to state 92

    expr1                          shift and go to state 94
    arg_list                       shift and go to state 141
    term1                          shift and go to state 95
    factor1                        shift and go to state 96

state 127

    (56) conditional -> IF LPAREN comp_expr RPAREN . LBRACE stmt_list RBRACE else_stmt
    (57) conditional -> IF LPAREN comp_expr RPAREN . LBRACE stmt_list RBRACE

    LBRACE          shift and go to state 142


state 128

    (58) comp_expr -> expr comp_op . expr
    (43) expr -> expr comp_op . term
    (41) expr -> . expr PLUS term
    (42) expr -> . expr MINUS term
    (43) expr -> . expr comp_op term
    (44) expr -> . term
    (45) term -> . term MULTIPLY factor
    (46) term -> . term DIVIDE factor
    (47) term -> . factor
    (48) factor -> . LPAREN expr RPAREN
    (49) factor -> . CTEI
    (50) factor -> . FLOAT_NUMBER
    (51) factor -> . STRING_LITERAL
    (52) factor -> . TRUE
    (53) factor -> . FALSE
    (54) factor -> . ID

    LPAREN          shift and go to state 85
    CTEI            shift and go to state 87
    FLOAT_NUMBER    shift and go to state 88
    STRING_LITERAL  shift and go to state 89
    TRUE            shift and go to state 90
    FALSE           shift and go to state 91
    ID              shift and go to state 100

    expr                           shift and go to state 143
    term                           shift and go to state 144
    factor                         shift and go to state 86

state 129

    (68) loop -> WHILE LPAREN comp_expr RPAREN . LBRACE stmt_list RBRACE

    LBRACE          shift and go to state 145


state 130

    (78) param -> type . ID

    ID              shift and go to state 146


state 131

    (70) function_decl -> type ID LPAREN create_function_scope param_list . RPAREN LBRACE stmt_list return_stmt end_scopes RBRACE

    RPAREN          shift and go to state 147


state 132

    (75) param_list -> param . COMMA param_list
    (76) param_list -> param .

    COMMA           shift and go to state 148
    RPAREN          reduce using rule 76 (param_list -> param .)


state 133

    (77) param_list -> empty .

    RPAREN          reduce using rule 77 (param_list -> empty .)


state 134

    (71) function_decl -> VOID ID LPAREN create_function_scope param_list . RPAREN LBRACE stmt_list end_scopes RBRACE

    RPAREN          shift and go to state 149


state 135

    (41) expr -> expr PLUS term .
    (45) term -> term . MULTIPLY factor
    (46) term -> term . DIVIDE factor

    PLUS            reduce using rule 41 (expr -> expr PLUS term .)
    MINUS           reduce using rule 41 (expr -> expr PLUS term .)
    LESS_THAN       reduce using rule 41 (expr -> expr PLUS term .)
    GREATER_THAN    reduce using rule 41 (expr -> expr PLUS term .)
    LESS_EQUAL      reduce using rule 41 (expr -> expr PLUS term .)
    GREATER_EQUAL   reduce using rule 41 (expr -> expr PLUS term .)
    EQUAL_EQUAL     reduce using rule 41 (expr -> expr PLUS term .)
    NOT_EQUAL       reduce using rule 41 (expr -> expr PLUS term .)
    SEMICOLON       reduce using rule 41 (expr -> expr PLUS term .)
    RPAREN          reduce using rule 41 (expr -> expr PLUS term .)
    MULTIPLY        shift and go to state 122
    DIVIDE          shift and go to state 123


state 136

    (42) expr -> expr MINUS term .
    (45) term -> term . MULTIPLY factor
    (46) term -> term . DIVIDE factor

    PLUS            reduce using rule 42 (expr -> expr MINUS term .)
    MINUS           reduce using rule 42 (expr -> expr MINUS term .)
    LESS_THAN       reduce using rule 42 (expr -> expr MINUS term .)
    GREATER_THAN    reduce using rule 42 (expr -> expr MINUS term .)
    LESS_EQUAL      reduce using rule 42 (expr -> expr MINUS term .)
    GREATER_EQUAL   reduce using rule 42 (expr -> expr MINUS term .)
    EQUAL_EQUAL     reduce using rule 42 (expr -> expr MINUS term .)
    NOT_EQUAL       reduce using rule 42 (expr -> expr MINUS term .)
    SEMICOLON       reduce using rule 42 (expr -> expr MINUS term .)
    RPAREN          reduce using rule 42 (expr -> expr MINUS term .)
    MULTIPLY        shift and go to state 122
    DIVIDE          shift and go to state 123


state 137

    (43) expr -> expr comp_op term .
    (45) term -> term . MULTIPLY factor
    (46) term -> term . DIVIDE factor

    PLUS            reduce using rule 43 (expr -> expr comp_op term .)
    MINUS           reduce using rule 43 (expr -> expr comp_op term .)
    LESS_THAN       reduce using rule 43 (expr -> expr comp_op term .)
    GREATER_THAN    reduce using rule 43 (expr -> expr comp_op term .)
    LESS_EQUAL      reduce using rule 43 (expr -> expr comp_op term .)
    GREATER_EQUAL   reduce using rule 43 (expr -> expr comp_op term .)
    EQUAL_EQUAL     reduce using rule 43 (expr -> expr comp_op term .)
    NOT_EQUAL       reduce using rule 43 (expr -> expr comp_op term .)
    SEMICOLON       reduce using rule 43 (expr -> expr comp_op term .)
    RPAREN          reduce using rule 43 (expr -> expr comp_op term .)
    MULTIPLY        shift and go to state 122
    DIVIDE          shift and go to state 123


state 138

    (45) term -> term MULTIPLY factor .

    MULTIPLY        reduce using rule 45 (term -> term MULTIPLY factor .)
    DIVIDE          reduce using rule 45 (term -> term MULTIPLY factor .)
    PLUS            reduce using rule 45 (term -> term MULTIPLY factor .)
    MINUS           reduce using rule 45 (term -> term MULTIPLY factor .)
    LESS_THAN       reduce using rule 45 (term -> term MULTIPLY factor .)
    GREATER_THAN    reduce using rule 45 (term -> term MULTIPLY factor .)
    LESS_EQUAL      reduce using rule 45 (term -> term MULTIPLY factor .)
    GREATER_EQUAL   reduce using rule 45 (term -> term MULTIPLY factor .)
    EQUAL_EQUAL     reduce using rule 45 (term -> term MULTIPLY factor .)
    NOT_EQUAL       reduce using rule 45 (term -> term MULTIPLY factor .)
    SEMICOLON       reduce using rule 45 (term -> term MULTIPLY factor .)
    RPAREN          reduce using rule 45 (term -> term MULTIPLY factor .)


state 139

    (46) term -> term DIVIDE factor .

    MULTIPLY        reduce using rule 46 (term -> term DIVIDE factor .)
    DIVIDE          reduce using rule 46 (term -> term DIVIDE factor .)
    PLUS            reduce using rule 46 (term -> term DIVIDE factor .)
    MINUS           reduce using rule 46 (term -> term DIVIDE factor .)
    LESS_THAN       reduce using rule 46 (term -> term DIVIDE factor .)
    GREATER_THAN    reduce using rule 46 (term -> term DIVIDE factor .)
    LESS_EQUAL      reduce using rule 46 (term -> term DIVIDE factor .)
    GREATER_EQUAL   reduce using rule 46 (term -> term DIVIDE factor .)
    EQUAL_EQUAL     reduce using rule 46 (term -> term DIVIDE factor .)
    NOT_EQUAL       reduce using rule 46 (term -> term DIVIDE factor .)
    SEMICOLON       reduce using rule 46 (term -> term DIVIDE factor .)
    RPAREN          reduce using rule 46 (term -> term DIVIDE factor .)


state 140

    (48) factor -> LPAREN expr RPAREN .

    MULTIPLY        reduce using rule 48 (factor -> LPAREN expr RPAREN .)
    DIVIDE          reduce using rule 48 (factor -> LPAREN expr RPAREN .)
    PLUS            reduce using rule 48 (factor -> LPAREN expr RPAREN .)
    MINUS           reduce using rule 48 (factor -> LPAREN expr RPAREN .)
    LESS_THAN       reduce using rule 48 (factor -> LPAREN expr RPAREN .)
    GREATER_THAN    reduce using rule 48 (factor -> LPAREN expr RPAREN .)
    LESS_EQUAL      reduce using rule 48 (factor -> LPAREN expr RPAREN .)
    GREATER_EQUAL   reduce using rule 48 (factor -> LPAREN expr RPAREN .)
    EQUAL_EQUAL     reduce using rule 48 (factor -> LPAREN expr RPAREN .)
    NOT_EQUAL       reduce using rule 48 (factor -> LPAREN expr RPAREN .)
    SEMICOLON       reduce using rule 48 (factor -> LPAREN expr RPAREN .)
    RPAREN          reduce using rule 48 (factor -> LPAREN expr RPAREN .)


state 141

    (80) arg_list -> expr1 COMMA arg_list .

    RPAREN          reduce using rule 80 (arg_list -> expr1 COMMA arg_list .)


state 142

    (56) conditional -> IF LPAREN comp_expr RPAREN LBRACE . stmt_list RBRACE else_stmt
    (57) conditional -> IF LPAREN comp_expr RPAREN LBRACE . stmt_list RBRACE
    (18) stmt_list -> . stmt SEMICOLON stmt_list
    (19) stmt_list -> . stmt SEMICOLON
    (20) stmt -> . assign
    (21) stmt -> . print
    (22) stmt -> . conditional
    (23) stmt -> . loop
    (24) stmt -> . function_call
    (25) stmt -> . decl
    (26) stmt -> . built_in_function
    (36) assign -> . ID EQUALS expr
    (37) assign -> . ID EQUALS function_call
    (55) print -> . PRINT COLON ID
    (56) conditional -> . IF LPAREN comp_expr RPAREN LBRACE stmt_list RBRACE else_stmt
    (57) conditional -> . IF LPAREN comp_expr RPAREN LBRACE stmt_list RBRACE
    (68) loop -> . WHILE LPAREN comp_expr RPAREN LBRACE stmt_list RBRACE
    (74) function_call -> . ID LPAREN arg_list RPAREN
    (12) decl -> . type ID
    (13) decl -> . array_decl SEMICOLON
    (27) built_in_function -> . TEACH_SUM LPAREN RPAREN
    (28) built_in_function -> . TEACH_SUBSTRACTION LPAREN RPAREN
    (29) built_in_function -> . TEACH_MULTIPLICATION LPAREN RPAREN
    (30) built_in_function -> . TEACH_DIVISION LPAREN RPAREN
    (31) built_in_function -> . TEACH_IF LPAREN RPAREN
    (32) built_in_function -> . TEACH_WHILE LPAREN RPAREN
    (33) built_in_function -> . TEACH_FUNCTION_DECLARATION LPAREN RPAREN
    (34) built_in_function -> . TEACH_FUNCTION_CALL LPAREN RPAREN
    (35) built_in_function -> . AYUDA LPAREN RPAREN
    (14) type -> . INT
    (15) type -> . FLOAT
    (16) type -> . STRING
    (17) type -> . BOOL
    (81) array_decl -> . type ID LBRACKET CTEI RBRACKET

    ID              shift and go to state 44
    PRINT           shift and go to state 45
    IF              shift and go to state 46
    WHILE           shift and go to state 47
    TEACH_SUM       shift and go to state 48
    TEACH_SUBSTRACTION shift and go to state 49
    TEACH_MULTIPLICATION shift and go to state 50
    TEACH_DIVISION  shift and go to state 51
    TEACH_IF        shift and go to state 52
    TEACH_WHILE     shift and go to state 53
    TEACH_FUNCTION_DECLARATION shift and go to state 54
    TEACH_FUNCTION_CALL shift and go to state 55
    AYUDA           shift and go to state 56
    INT             shift and go to state 18
    FLOAT           shift and go to state 19
    STRING          shift and go to state 20
    BOOL            shift and go to state 21

    stmt_list                      shift and go to state 150
    stmt                           shift and go to state 36
    assign                         shift and go to state 37
    print                          shift and go to state 38
    conditional                    shift and go to state 39
    loop                           shift and go to state 40
    function_call                  shift and go to state 41
    decl                           shift and go to state 42
    built_in_function              shift and go to state 43
    type                           shift and go to state 16
    array_decl                     shift and go to state 17

state 143

    (58) comp_expr -> expr comp_op expr .
    (41) expr -> expr . PLUS term
    (42) expr -> expr . MINUS term
    (43) expr -> expr . comp_op term
    (59) comp_op -> . LESS_THAN
    (60) comp_op -> . GREATER_THAN
    (61) comp_op -> . LESS_EQUAL
    (62) comp_op -> . GREATER_EQUAL
    (63) comp_op -> . EQUAL_EQUAL
    (64) comp_op -> . NOT_EQUAL

    RPAREN          reduce using rule 58 (comp_expr -> expr comp_op expr .)
    PLUS            shift and go to state 113
    MINUS           shift and go to state 114
    LESS_THAN       shift and go to state 116
    GREATER_THAN    shift and go to state 117
    LESS_EQUAL      shift and go to state 118
    GREATER_EQUAL   shift and go to state 119
    EQUAL_EQUAL     shift and go to state 120
    NOT_EQUAL       shift and go to state 121

    comp_op                        shift and go to state 115

state 144

    (43) expr -> expr comp_op term .
    (44) expr -> term .
    (45) term -> term . MULTIPLY factor
    (46) term -> term . DIVIDE factor

  ! reduce/reduce conflict for PLUS resolved using rule 43 (expr -> expr comp_op term .)
  ! reduce/reduce conflict for MINUS resolved using rule 43 (expr -> expr comp_op term .)
  ! reduce/reduce conflict for LESS_THAN resolved using rule 43 (expr -> expr comp_op term .)
  ! reduce/reduce conflict for GREATER_THAN resolved using rule 43 (expr -> expr comp_op term .)
  ! reduce/reduce conflict for LESS_EQUAL resolved using rule 43 (expr -> expr comp_op term .)
  ! reduce/reduce conflict for GREATER_EQUAL resolved using rule 43 (expr -> expr comp_op term .)
  ! reduce/reduce conflict for EQUAL_EQUAL resolved using rule 43 (expr -> expr comp_op term .)
  ! reduce/reduce conflict for NOT_EQUAL resolved using rule 43 (expr -> expr comp_op term .)
    PLUS            reduce using rule 43 (expr -> expr comp_op term .)
    MINUS           reduce using rule 43 (expr -> expr comp_op term .)
    LESS_THAN       reduce using rule 43 (expr -> expr comp_op term .)
    GREATER_THAN    reduce using rule 43 (expr -> expr comp_op term .)
    LESS_EQUAL      reduce using rule 43 (expr -> expr comp_op term .)
    GREATER_EQUAL   reduce using rule 43 (expr -> expr comp_op term .)
    EQUAL_EQUAL     reduce using rule 43 (expr -> expr comp_op term .)
    NOT_EQUAL       reduce using rule 43 (expr -> expr comp_op term .)
    RPAREN          reduce using rule 44 (expr -> term .)
    MULTIPLY        shift and go to state 122
    DIVIDE          shift and go to state 123

  ! PLUS            [ reduce using rule 44 (expr -> term .) ]
  ! MINUS           [ reduce using rule 44 (expr -> term .) ]
  ! LESS_THAN       [ reduce using rule 44 (expr -> term .) ]
  ! GREATER_THAN    [ reduce using rule 44 (expr -> term .) ]
  ! LESS_EQUAL      [ reduce using rule 44 (expr -> term .) ]
  ! GREATER_EQUAL   [ reduce using rule 44 (expr -> term .) ]
  ! EQUAL_EQUAL     [ reduce using rule 44 (expr -> term .) ]
  ! NOT_EQUAL       [ reduce using rule 44 (expr -> term .) ]


state 145

    (68) loop -> WHILE LPAREN comp_expr RPAREN LBRACE . stmt_list RBRACE
    (18) stmt_list -> . stmt SEMICOLON stmt_list
    (19) stmt_list -> . stmt SEMICOLON
    (20) stmt -> . assign
    (21) stmt -> . print
    (22) stmt -> . conditional
    (23) stmt -> . loop
    (24) stmt -> . function_call
    (25) stmt -> . decl
    (26) stmt -> . built_in_function
    (36) assign -> . ID EQUALS expr
    (37) assign -> . ID EQUALS function_call
    (55) print -> . PRINT COLON ID
    (56) conditional -> . IF LPAREN comp_expr RPAREN LBRACE stmt_list RBRACE else_stmt
    (57) conditional -> . IF LPAREN comp_expr RPAREN LBRACE stmt_list RBRACE
    (68) loop -> . WHILE LPAREN comp_expr RPAREN LBRACE stmt_list RBRACE
    (74) function_call -> . ID LPAREN arg_list RPAREN
    (12) decl -> . type ID
    (13) decl -> . array_decl SEMICOLON
    (27) built_in_function -> . TEACH_SUM LPAREN RPAREN
    (28) built_in_function -> . TEACH_SUBSTRACTION LPAREN RPAREN
    (29) built_in_function -> . TEACH_MULTIPLICATION LPAREN RPAREN
    (30) built_in_function -> . TEACH_DIVISION LPAREN RPAREN
    (31) built_in_function -> . TEACH_IF LPAREN RPAREN
    (32) built_in_function -> . TEACH_WHILE LPAREN RPAREN
    (33) built_in_function -> . TEACH_FUNCTION_DECLARATION LPAREN RPAREN
    (34) built_in_function -> . TEACH_FUNCTION_CALL LPAREN RPAREN
    (35) built_in_function -> . AYUDA LPAREN RPAREN
    (14) type -> . INT
    (15) type -> . FLOAT
    (16) type -> . STRING
    (17) type -> . BOOL
    (81) array_decl -> . type ID LBRACKET CTEI RBRACKET

    ID              shift and go to state 44
    PRINT           shift and go to state 45
    IF              shift and go to state 46
    WHILE           shift and go to state 47
    TEACH_SUM       shift and go to state 48
    TEACH_SUBSTRACTION shift and go to state 49
    TEACH_MULTIPLICATION shift and go to state 50
    TEACH_DIVISION  shift and go to state 51
    TEACH_IF        shift and go to state 52
    TEACH_WHILE     shift and go to state 53
    TEACH_FUNCTION_DECLARATION shift and go to state 54
    TEACH_FUNCTION_CALL shift and go to state 55
    AYUDA           shift and go to state 56
    INT             shift and go to state 18
    FLOAT           shift and go to state 19
    STRING          shift and go to state 20
    BOOL            shift and go to state 21

    stmt_list                      shift and go to state 151
    stmt                           shift and go to state 36
    assign                         shift and go to state 37
    print                          shift and go to state 38
    conditional                    shift and go to state 39
    loop                           shift and go to state 40
    function_call                  shift and go to state 41
    decl                           shift and go to state 42
    built_in_function              shift and go to state 43
    type                           shift and go to state 16
    array_decl                     shift and go to state 17

state 146

    (78) param -> type ID .

    COMMA           reduce using rule 78 (param -> type ID .)
    RPAREN          reduce using rule 78 (param -> type ID .)


state 147

    (70) function_decl -> type ID LPAREN create_function_scope param_list RPAREN . LBRACE stmt_list return_stmt end_scopes RBRACE

    LBRACE          shift and go to state 152


state 148

    (75) param_list -> param COMMA . param_list
    (75) param_list -> . param COMMA param_list
    (76) param_list -> . param
    (77) param_list -> . empty
    (78) param -> . type ID
    (82) empty -> .
    (14) type -> . INT
    (15) type -> . FLOAT
    (16) type -> . STRING
    (17) type -> . BOOL

    RPAREN          reduce using rule 82 (empty -> .)
    INT             shift and go to state 18
    FLOAT           shift and go to state 19
    STRING          shift and go to state 20
    BOOL            shift and go to state 21

    param                          shift and go to state 132
    param_list                     shift and go to state 153
    empty                          shift and go to state 133
    type                           shift and go to state 130

state 149

    (71) function_decl -> VOID ID LPAREN create_function_scope param_list RPAREN . LBRACE stmt_list end_scopes RBRACE

    LBRACE          shift and go to state 154


state 150

    (56) conditional -> IF LPAREN comp_expr RPAREN LBRACE stmt_list . RBRACE else_stmt
    (57) conditional -> IF LPAREN comp_expr RPAREN LBRACE stmt_list . RBRACE

    RBRACE          shift and go to state 155


state 151

    (68) loop -> WHILE LPAREN comp_expr RPAREN LBRACE stmt_list . RBRACE

    RBRACE          shift and go to state 156


state 152

    (70) function_decl -> type ID LPAREN create_function_scope param_list RPAREN LBRACE . stmt_list return_stmt end_scopes RBRACE
    (18) stmt_list -> . stmt SEMICOLON stmt_list
    (19) stmt_list -> . stmt SEMICOLON
    (20) stmt -> . assign
    (21) stmt -> . print
    (22) stmt -> . conditional
    (23) stmt -> . loop
    (24) stmt -> . function_call
    (25) stmt -> . decl
    (26) stmt -> . built_in_function
    (36) assign -> . ID EQUALS expr
    (37) assign -> . ID EQUALS function_call
    (55) print -> . PRINT COLON ID
    (56) conditional -> . IF LPAREN comp_expr RPAREN LBRACE stmt_list RBRACE else_stmt
    (57) conditional -> . IF LPAREN comp_expr RPAREN LBRACE stmt_list RBRACE
    (68) loop -> . WHILE LPAREN comp_expr RPAREN LBRACE stmt_list RBRACE
    (74) function_call -> . ID LPAREN arg_list RPAREN
    (12) decl -> . type ID
    (13) decl -> . array_decl SEMICOLON
    (27) built_in_function -> . TEACH_SUM LPAREN RPAREN
    (28) built_in_function -> . TEACH_SUBSTRACTION LPAREN RPAREN
    (29) built_in_function -> . TEACH_MULTIPLICATION LPAREN RPAREN
    (30) built_in_function -> . TEACH_DIVISION LPAREN RPAREN
    (31) built_in_function -> . TEACH_IF LPAREN RPAREN
    (32) built_in_function -> . TEACH_WHILE LPAREN RPAREN
    (33) built_in_function -> . TEACH_FUNCTION_DECLARATION LPAREN RPAREN
    (34) built_in_function -> . TEACH_FUNCTION_CALL LPAREN RPAREN
    (35) built_in_function -> . AYUDA LPAREN RPAREN
    (14) type -> . INT
    (15) type -> . FLOAT
    (16) type -> . STRING
    (17) type -> . BOOL
    (81) array_decl -> . type ID LBRACKET CTEI RBRACKET

    ID              shift and go to state 44
    PRINT           shift and go to state 45
    IF              shift and go to state 46
    WHILE           shift and go to state 47
    TEACH_SUM       shift and go to state 48
    TEACH_SUBSTRACTION shift and go to state 49
    TEACH_MULTIPLICATION shift and go to state 50
    TEACH_DIVISION  shift and go to state 51
    TEACH_IF        shift and go to state 52
    TEACH_WHILE     shift and go to state 53
    TEACH_FUNCTION_DECLARATION shift and go to state 54
    TEACH_FUNCTION_CALL shift and go to state 55
    AYUDA           shift and go to state 56
    INT             shift and go to state 18
    FLOAT           shift and go to state 19
    STRING          shift and go to state 20
    BOOL            shift and go to state 21

    type                           shift and go to state 16
    stmt_list                      shift and go to state 157
    stmt                           shift and go to state 36
    assign                         shift and go to state 37
    print                          shift and go to state 38
    conditional                    shift and go to state 39
    loop                           shift and go to state 40
    function_call                  shift and go to state 41
    decl                           shift and go to state 42
    built_in_function              shift and go to state 43
    array_decl                     shift and go to state 17

state 153

    (75) param_list -> param COMMA param_list .

    RPAREN          reduce using rule 75 (param_list -> param COMMA param_list .)


state 154

    (71) function_decl -> VOID ID LPAREN create_function_scope param_list RPAREN LBRACE . stmt_list end_scopes RBRACE
    (18) stmt_list -> . stmt SEMICOLON stmt_list
    (19) stmt_list -> . stmt SEMICOLON
    (20) stmt -> . assign
    (21) stmt -> . print
    (22) stmt -> . conditional
    (23) stmt -> . loop
    (24) stmt -> . function_call
    (25) stmt -> . decl
    (26) stmt -> . built_in_function
    (36) assign -> . ID EQUALS expr
    (37) assign -> . ID EQUALS function_call
    (55) print -> . PRINT COLON ID
    (56) conditional -> . IF LPAREN comp_expr RPAREN LBRACE stmt_list RBRACE else_stmt
    (57) conditional -> . IF LPAREN comp_expr RPAREN LBRACE stmt_list RBRACE
    (68) loop -> . WHILE LPAREN comp_expr RPAREN LBRACE stmt_list RBRACE
    (74) function_call -> . ID LPAREN arg_list RPAREN
    (12) decl -> . type ID
    (13) decl -> . array_decl SEMICOLON
    (27) built_in_function -> . TEACH_SUM LPAREN RPAREN
    (28) built_in_function -> . TEACH_SUBSTRACTION LPAREN RPAREN
    (29) built_in_function -> . TEACH_MULTIPLICATION LPAREN RPAREN
    (30) built_in_function -> . TEACH_DIVISION LPAREN RPAREN
    (31) built_in_function -> . TEACH_IF LPAREN RPAREN
    (32) built_in_function -> . TEACH_WHILE LPAREN RPAREN
    (33) built_in_function -> . TEACH_FUNCTION_DECLARATION LPAREN RPAREN
    (34) built_in_function -> . TEACH_FUNCTION_CALL LPAREN RPAREN
    (35) built_in_function -> . AYUDA LPAREN RPAREN
    (14) type -> . INT
    (15) type -> . FLOAT
    (16) type -> . STRING
    (17) type -> . BOOL
    (81) array_decl -> . type ID LBRACKET CTEI RBRACKET

    ID              shift and go to state 44
    PRINT           shift and go to state 45
    IF              shift and go to state 46
    WHILE           shift and go to state 47
    TEACH_SUM       shift and go to state 48
    TEACH_SUBSTRACTION shift and go to state 49
    TEACH_MULTIPLICATION shift and go to state 50
    TEACH_DIVISION  shift and go to state 51
    TEACH_IF        shift and go to state 52
    TEACH_WHILE     shift and go to state 53
    TEACH_FUNCTION_DECLARATION shift and go to state 54
    TEACH_FUNCTION_CALL shift and go to state 55
    AYUDA           shift and go to state 56
    INT             shift and go to state 18
    FLOAT           shift and go to state 19
    STRING          shift and go to state 20
    BOOL            shift and go to state 21

    stmt_list                      shift and go to state 158
    stmt                           shift and go to state 36
    assign                         shift and go to state 37
    print                          shift and go to state 38
    conditional                    shift and go to state 39
    loop                           shift and go to state 40
    function_call                  shift and go to state 41
    decl                           shift and go to state 42
    built_in_function              shift and go to state 43
    type                           shift and go to state 16
    array_decl                     shift and go to state 17

state 155

    (56) conditional -> IF LPAREN comp_expr RPAREN LBRACE stmt_list RBRACE . else_stmt
    (57) conditional -> IF LPAREN comp_expr RPAREN LBRACE stmt_list RBRACE .
    (65) else_stmt -> . ELSE LBRACE else_part stmt_list RBRACE
    (66) else_stmt -> . empty
    (82) empty -> .

  ! reduce/reduce conflict for SEMICOLON resolved using rule 57 (conditional -> IF LPAREN comp_expr RPAREN LBRACE stmt_list RBRACE .)
    SEMICOLON       reduce using rule 57 (conditional -> IF LPAREN comp_expr RPAREN LBRACE stmt_list RBRACE .)
    ELSE            shift and go to state 160

  ! SEMICOLON       [ reduce using rule 82 (empty -> .) ]

    else_stmt                      shift and go to state 159
    empty                          shift and go to state 161

state 156

    (68) loop -> WHILE LPAREN comp_expr RPAREN LBRACE stmt_list RBRACE .

    SEMICOLON       reduce using rule 68 (loop -> WHILE LPAREN comp_expr RPAREN LBRACE stmt_list RBRACE .)


state 157

    (70) function_decl -> type ID LPAREN create_function_scope param_list RPAREN LBRACE stmt_list . return_stmt end_scopes RBRACE
    (72) return_stmt -> . RETURN expr1 SEMICOLON
    (73) return_stmt -> . empty
    (82) empty -> .

    RETURN          shift and go to state 163
    RBRACE          reduce using rule 82 (empty -> .)

    return_stmt                    shift and go to state 162
    empty                          shift and go to state 164

state 158

    (71) function_decl -> VOID ID LPAREN create_function_scope param_list RPAREN LBRACE stmt_list . end_scopes RBRACE
    (8) end_scopes -> .

    RBRACE          reduce using rule 8 (end_scopes -> .)

    end_scopes                     shift and go to state 165

state 159

    (56) conditional -> IF LPAREN comp_expr RPAREN LBRACE stmt_list RBRACE else_stmt .

    SEMICOLON       reduce using rule 56 (conditional -> IF LPAREN comp_expr RPAREN LBRACE stmt_list RBRACE else_stmt .)


state 160

    (65) else_stmt -> ELSE . LBRACE else_part stmt_list RBRACE

    LBRACE          shift and go to state 166


state 161

    (66) else_stmt -> empty .

    SEMICOLON       reduce using rule 66 (else_stmt -> empty .)


state 162

    (70) function_decl -> type ID LPAREN create_function_scope param_list RPAREN LBRACE stmt_list return_stmt . end_scopes RBRACE
    (8) end_scopes -> .

    RBRACE          reduce using rule 8 (end_scopes -> .)

    end_scopes                     shift and go to state 167

state 163

    (72) return_stmt -> RETURN . expr1 SEMICOLON
    (38) expr1 -> . term1
    (39) term1 -> . factor1
    (40) factor1 -> . ID

    ID              shift and go to state 92

    expr1                          shift and go to state 168
    term1                          shift and go to state 95
    factor1                        shift and go to state 96

state 164

    (73) return_stmt -> empty .

    RBRACE          reduce using rule 73 (return_stmt -> empty .)


state 165

    (71) function_decl -> VOID ID LPAREN create_function_scope param_list RPAREN LBRACE stmt_list end_scopes . RBRACE

    RBRACE          shift and go to state 169


state 166

    (65) else_stmt -> ELSE LBRACE . else_part stmt_list RBRACE
    (67) else_part -> .

    ID              reduce using rule 67 (else_part -> .)
    PRINT           reduce using rule 67 (else_part -> .)
    IF              reduce using rule 67 (else_part -> .)
    WHILE           reduce using rule 67 (else_part -> .)
    TEACH_SUM       reduce using rule 67 (else_part -> .)
    TEACH_SUBSTRACTION reduce using rule 67 (else_part -> .)
    TEACH_MULTIPLICATION reduce using rule 67 (else_part -> .)
    TEACH_DIVISION  reduce using rule 67 (else_part -> .)
    TEACH_IF        reduce using rule 67 (else_part -> .)
    TEACH_WHILE     reduce using rule 67 (else_part -> .)
    TEACH_FUNCTION_DECLARATION reduce using rule 67 (else_part -> .)
    TEACH_FUNCTION_CALL reduce using rule 67 (else_part -> .)
    AYUDA           reduce using rule 67 (else_part -> .)
    INT             reduce using rule 67 (else_part -> .)
    FLOAT           reduce using rule 67 (else_part -> .)
    STRING          reduce using rule 67 (else_part -> .)
    BOOL            reduce using rule 67 (else_part -> .)

    else_part                      shift and go to state 170

state 167

    (70) function_decl -> type ID LPAREN create_function_scope param_list RPAREN LBRACE stmt_list return_stmt end_scopes . RBRACE

    RBRACE          shift and go to state 171


state 168

    (72) return_stmt -> RETURN expr1 . SEMICOLON

    SEMICOLON       shift and go to state 172


state 169

    (71) function_decl -> VOID ID LPAREN create_function_scope param_list RPAREN LBRACE stmt_list end_scopes RBRACE .

    VOID            reduce using rule 71 (function_decl -> VOID ID LPAREN create_function_scope param_list RPAREN LBRACE stmt_list end_scopes RBRACE .)
    INT             reduce using rule 71 (function_decl -> VOID ID LPAREN create_function_scope param_list RPAREN LBRACE stmt_list end_scopes RBRACE .)
    FLOAT           reduce using rule 71 (function_decl -> VOID ID LPAREN create_function_scope param_list RPAREN LBRACE stmt_list end_scopes RBRACE .)
    STRING          reduce using rule 71 (function_decl -> VOID ID LPAREN create_function_scope param_list RPAREN LBRACE stmt_list end_scopes RBRACE .)
    BOOL            reduce using rule 71 (function_decl -> VOID ID LPAREN create_function_scope param_list RPAREN LBRACE stmt_list end_scopes RBRACE .)
    MAIN            reduce using rule 71 (function_decl -> VOID ID LPAREN create_function_scope param_list RPAREN LBRACE stmt_list end_scopes RBRACE .)


state 170

    (65) else_stmt -> ELSE LBRACE else_part . stmt_list RBRACE
    (18) stmt_list -> . stmt SEMICOLON stmt_list
    (19) stmt_list -> . stmt SEMICOLON
    (20) stmt -> . assign
    (21) stmt -> . print
    (22) stmt -> . conditional
    (23) stmt -> . loop
    (24) stmt -> . function_call
    (25) stmt -> . decl
    (26) stmt -> . built_in_function
    (36) assign -> . ID EQUALS expr
    (37) assign -> . ID EQUALS function_call
    (55) print -> . PRINT COLON ID
    (56) conditional -> . IF LPAREN comp_expr RPAREN LBRACE stmt_list RBRACE else_stmt
    (57) conditional -> . IF LPAREN comp_expr RPAREN LBRACE stmt_list RBRACE
    (68) loop -> . WHILE LPAREN comp_expr RPAREN LBRACE stmt_list RBRACE
    (74) function_call -> . ID LPAREN arg_list RPAREN
    (12) decl -> . type ID
    (13) decl -> . array_decl SEMICOLON
    (27) built_in_function -> . TEACH_SUM LPAREN RPAREN
    (28) built_in_function -> . TEACH_SUBSTRACTION LPAREN RPAREN
    (29) built_in_function -> . TEACH_MULTIPLICATION LPAREN RPAREN
    (30) built_in_function -> . TEACH_DIVISION LPAREN RPAREN
    (31) built_in_function -> . TEACH_IF LPAREN RPAREN
    (32) built_in_function -> . TEACH_WHILE LPAREN RPAREN
    (33) built_in_function -> . TEACH_FUNCTION_DECLARATION LPAREN RPAREN
    (34) built_in_function -> . TEACH_FUNCTION_CALL LPAREN RPAREN
    (35) built_in_function -> . AYUDA LPAREN RPAREN
    (14) type -> . INT
    (15) type -> . FLOAT
    (16) type -> . STRING
    (17) type -> . BOOL
    (81) array_decl -> . type ID LBRACKET CTEI RBRACKET

    ID              shift and go to state 44
    PRINT           shift and go to state 45
    IF              shift and go to state 46
    WHILE           shift and go to state 47
    TEACH_SUM       shift and go to state 48
    TEACH_SUBSTRACTION shift and go to state 49
    TEACH_MULTIPLICATION shift and go to state 50
    TEACH_DIVISION  shift and go to state 51
    TEACH_IF        shift and go to state 52
    TEACH_WHILE     shift and go to state 53
    TEACH_FUNCTION_DECLARATION shift and go to state 54
    TEACH_FUNCTION_CALL shift and go to state 55
    AYUDA           shift and go to state 56
    INT             shift and go to state 18
    FLOAT           shift and go to state 19
    STRING          shift and go to state 20
    BOOL            shift and go to state 21

    stmt_list                      shift and go to state 173
    stmt                           shift and go to state 36
    assign                         shift and go to state 37
    print                          shift and go to state 38
    conditional                    shift and go to state 39
    loop                           shift and go to state 40
    function_call                  shift and go to state 41
    decl                           shift and go to state 42
    built_in_function              shift and go to state 43
    type                           shift and go to state 16
    array_decl                     shift and go to state 17

state 171

    (70) function_decl -> type ID LPAREN create_function_scope param_list RPAREN LBRACE stmt_list return_stmt end_scopes RBRACE .

    VOID            reduce using rule 70 (function_decl -> type ID LPAREN create_function_scope param_list RPAREN LBRACE stmt_list return_stmt end_scopes RBRACE .)
    INT             reduce using rule 70 (function_decl -> type ID LPAREN create_function_scope param_list RPAREN LBRACE stmt_list return_stmt end_scopes RBRACE .)
    FLOAT           reduce using rule 70 (function_decl -> type ID LPAREN create_function_scope param_list RPAREN LBRACE stmt_list return_stmt end_scopes RBRACE .)
    STRING          reduce using rule 70 (function_decl -> type ID LPAREN create_function_scope param_list RPAREN LBRACE stmt_list return_stmt end_scopes RBRACE .)
    BOOL            reduce using rule 70 (function_decl -> type ID LPAREN create_function_scope param_list RPAREN LBRACE stmt_list return_stmt end_scopes RBRACE .)
    MAIN            reduce using rule 70 (function_decl -> type ID LPAREN create_function_scope param_list RPAREN LBRACE stmt_list return_stmt end_scopes RBRACE .)


state 172

    (72) return_stmt -> RETURN expr1 SEMICOLON .

    RBRACE          reduce using rule 72 (return_stmt -> RETURN expr1 SEMICOLON .)


state 173

    (65) else_stmt -> ELSE LBRACE else_part stmt_list . RBRACE

    RBRACE          shift and go to state 174


state 174

    (65) else_stmt -> ELSE LBRACE else_part stmt_list RBRACE .

    SEMICOLON       reduce using rule 65 (else_stmt -> ELSE LBRACE else_part stmt_list RBRACE .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: reduce/reduce conflict in state 23 resolved using rule (global_scope -> VARIABLES LBRACE decl_list RBRACE)
WARNING: rejected rule (empty -> <empty>) in state 23
WARNING: reduce/reduce conflict in state 24 resolved using rule (decl_list -> decl SEMICOLON)
WARNING: rejected rule (empty -> <empty>) in state 24
WARNING: reduce/reduce conflict in state 144 resolved using rule (expr -> expr comp_op term)
WARNING: rejected rule (expr -> term) in state 144
WARNING: reduce/reduce conflict in state 155 resolved using rule (conditional -> IF LPAREN comp_expr RPAREN LBRACE stmt_list RBRACE)
WARNING: rejected rule (empty -> <empty>) in state 155
