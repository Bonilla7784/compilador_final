Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> program
Rule 1     program -> PROGRAM ID SEMICOLON placeholder_goto_main create_scopes global_scope main_function end_scopes fill_goto_main
Rule 2     placeholder_goto_main -> <empty>
Rule 3     global_scope -> VARIABLES LBRACE decl_list RBRACE function_decl_list
Rule 4     global_scope -> VARIABLES LBRACE decl_list RBRACE
Rule 5     function_decl_list -> function_decl function_decl_list
Rule 6     function_decl_list -> empty
Rule 7     main_function -> MAIN LPAREN RPAREN LBRACE start_main stmt_list RBRACE
Rule 8     start_main -> <empty>
Rule 9     fill_goto_main -> <empty>
Rule 10    create_scopes -> <empty>
Rule 11    end_scopes -> <empty>
Rule 12    decl_list -> decl SEMICOLON decl_list
Rule 13    decl_list -> decl SEMICOLON
Rule 14    decl_list -> empty
Rule 15    decl -> type ID
Rule 16    decl -> array_decl
Rule 17    type -> INT
Rule 18    type -> FLOAT
Rule 19    type -> STRING
Rule 20    type -> BOOL
Rule 21    stmt_list -> stmt SEMICOLON stmt_list
Rule 22    stmt_list -> stmt SEMICOLON
Rule 23    stmt -> assign
Rule 24    stmt -> array_assign
Rule 25    stmt -> print
Rule 26    stmt -> conditional
Rule 27    stmt -> loop
Rule 28    stmt -> function_call
Rule 29    stmt -> decl
Rule 30    stmt -> built_in_function
Rule 31    stmt -> return_stmt
Rule 32    built_in_function -> TEACH_SUM LPAREN RPAREN
Rule 33    built_in_function -> TEACH_SUBSTRACTION LPAREN RPAREN
Rule 34    built_in_function -> TEACH_MULTIPLICATION LPAREN RPAREN
Rule 35    built_in_function -> TEACH_DIVISION LPAREN RPAREN
Rule 36    built_in_function -> TEACH_IF LPAREN RPAREN
Rule 37    built_in_function -> TEACH_WHILE LPAREN RPAREN
Rule 38    built_in_function -> TEACH_FUNCTION_DECLARATION LPAREN RPAREN
Rule 39    built_in_function -> TEACH_FUNCTION_CALL LPAREN RPAREN
Rule 40    built_in_function -> AYUDA LPAREN RPAREN
Rule 41    assign -> ID EQUALS expr
Rule 42    expr -> expr PLUS term
Rule 43    expr -> expr MINUS term
Rule 44    expr -> expr comp_op term
Rule 45    expr -> term
Rule 46    term -> term MULTIPLY factor
Rule 47    term -> term DIVIDE factor
Rule 48    term -> factor
Rule 49    term -> function_call
Rule 50    term -> array_access
Rule 51    factor -> LPAREN expr RPAREN
Rule 52    factor -> CTEI
Rule 53    factor -> FLOAT_NUMBER
Rule 54    factor -> STRING_LITERAL
Rule 55    factor -> TRUE
Rule 56    factor -> FALSE
Rule 57    factor -> ID
Rule 58    factor -> function_call
Rule 59    print -> PRINT COLON expr
Rule 60    conditional -> IF LPAREN comp_expr RPAREN LBRACE stmt_list RBRACE else_stmt
Rule 61    conditional -> IF LPAREN comp_expr RPAREN LBRACE stmt_list RBRACE
Rule 62    comp_expr -> expr comp_op expr
Rule 63    comp_op -> LESS_THAN
Rule 64    comp_op -> GREATER_THAN
Rule 65    comp_op -> LESS_EQUAL
Rule 66    comp_op -> GREATER_EQUAL
Rule 67    comp_op -> EQUAL_EQUAL
Rule 68    comp_op -> NOT_EQUAL
Rule 69    else_stmt -> ELSE LBRACE else_part stmt_list RBRACE
Rule 70    else_stmt -> empty
Rule 71    else_part -> <empty>
Rule 72    loop -> WHILE LPAREN comp_expr RPAREN LBRACE stmt_list RBRACE
Rule 73    create_function_scope -> <empty>
Rule 74    function_decl -> type ID LPAREN create_function_scope param_list RPAREN LBRACE stmt_list end_scopes RBRACE
Rule 75    function_decl -> VOID ID LPAREN create_function_scope param_list RPAREN LBRACE stmt_list end_scopes RBRACE
Rule 76    return_stmt -> RETURN expr
Rule 77    return_stmt -> empty
Rule 78    function_call -> ID LPAREN arg_list RPAREN
Rule 79    arg_list -> arg_list COMMA expr
Rule 80    arg_list -> expr
Rule 81    param_list -> param COMMA param_list
Rule 82    param_list -> param
Rule 83    param_list -> empty
Rule 84    param -> type ID
Rule 85    array_decl -> type ID LBRACKET CTEI RBRACKET
Rule 86    array_assign -> ID EQUALS LBRACE CTEI_list RBRACE
Rule 87    CTEI_list -> CTEI
Rule 88    CTEI_list -> CTEI_list COMMA CTEI
Rule 89    array_access -> ID LBRACKET expr RBRACKET
Rule 90    empty -> <empty>

Terminals, with rules where they appear

AYUDA                : 40
BOOL                 : 20
COLON                : 59
COMMA                : 79 81 88
CTEI                 : 52 85 87 88
DIVIDE               : 47
ELSE                 : 69
EQUALS               : 41 86
EQUAL_EQUAL          : 67
FALSE                : 56
FLOAT                : 18
FLOAT_NUMBER         : 53
GREATER_EQUAL        : 66
GREATER_THAN         : 64
ID                   : 1 15 41 57 74 75 78 84 85 86 89
IF                   : 60 61
INT                  : 17
LBRACE               : 3 4 7 60 61 69 72 74 75 86
LBRACKET             : 85 89
LESS_EQUAL           : 65
LESS_THAN            : 63
LPAREN               : 7 32 33 34 35 36 37 38 39 40 51 60 61 72 74 75 78
MAIN                 : 7
MINUS                : 43
MULTIPLY             : 46
NOT_EQUAL            : 68
PLUS                 : 42
PRINT                : 59
PROGRAM              : 1
RBRACE               : 3 4 7 60 61 69 72 74 75 86
RBRACKET             : 85 89
RETURN               : 76
RPAREN               : 7 32 33 34 35 36 37 38 39 40 51 60 61 72 74 75 78
SEMICOLON            : 1 12 13 21 22
STRING               : 19
STRING_LITERAL       : 54
TEACH_DIVISION       : 35
TEACH_FUNCTION_CALL  : 39
TEACH_FUNCTION_DECLARATION : 38
TEACH_IF             : 36
TEACH_MULTIPLICATION : 34
TEACH_SUBSTRACTION   : 33
TEACH_SUM            : 32
TEACH_WHILE          : 37
TRUE                 : 55
VARIABLES            : 3 4
VOID                 : 75
WHILE                : 72
error                : 

Nonterminals, with rules where they appear

CTEI_list            : 86 88
arg_list             : 78 79
array_access         : 50
array_assign         : 24
array_decl           : 16
assign               : 23
built_in_function    : 30
comp_expr            : 60 61 72
comp_op              : 44 62
conditional          : 26
create_function_scope : 74 75
create_scopes        : 1
decl                 : 12 13 29
decl_list            : 3 4 12
else_part            : 69
else_stmt            : 60
empty                : 6 14 70 77 83
end_scopes           : 1 74 75
expr                 : 41 42 43 44 51 59 62 62 76 79 80 89
factor               : 46 47 48
fill_goto_main       : 1
function_call        : 28 49 58
function_decl        : 5
function_decl_list   : 3 5
global_scope         : 1
loop                 : 27
main_function        : 1
param                : 81 82
param_list           : 74 75 81
placeholder_goto_main : 1
print                : 25
program              : 0
return_stmt          : 31
start_main           : 7
stmt                 : 21 22
stmt_list            : 7 21 60 61 69 72 74 75
term                 : 42 43 44 45 46 47
type                 : 15 74 84 85

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . PROGRAM ID SEMICOLON placeholder_goto_main create_scopes global_scope main_function end_scopes fill_goto_main

    PROGRAM         shift and go to state 2

    program                        shift and go to state 1

state 1

    (0) S' -> program .



state 2

    (1) program -> PROGRAM . ID SEMICOLON placeholder_goto_main create_scopes global_scope main_function end_scopes fill_goto_main

    ID              shift and go to state 3


state 3

    (1) program -> PROGRAM ID . SEMICOLON placeholder_goto_main create_scopes global_scope main_function end_scopes fill_goto_main

    SEMICOLON       shift and go to state 4


state 4

    (1) program -> PROGRAM ID SEMICOLON . placeholder_goto_main create_scopes global_scope main_function end_scopes fill_goto_main
    (2) placeholder_goto_main -> .

    VARIABLES       reduce using rule 2 (placeholder_goto_main -> .)

    placeholder_goto_main          shift and go to state 5

state 5

    (1) program -> PROGRAM ID SEMICOLON placeholder_goto_main . create_scopes global_scope main_function end_scopes fill_goto_main
    (10) create_scopes -> .

    VARIABLES       reduce using rule 10 (create_scopes -> .)

    create_scopes                  shift and go to state 6

state 6

    (1) program -> PROGRAM ID SEMICOLON placeholder_goto_main create_scopes . global_scope main_function end_scopes fill_goto_main
    (3) global_scope -> . VARIABLES LBRACE decl_list RBRACE function_decl_list
    (4) global_scope -> . VARIABLES LBRACE decl_list RBRACE

    VARIABLES       shift and go to state 8

    global_scope                   shift and go to state 7

state 7

    (1) program -> PROGRAM ID SEMICOLON placeholder_goto_main create_scopes global_scope . main_function end_scopes fill_goto_main
    (7) main_function -> . MAIN LPAREN RPAREN LBRACE start_main stmt_list RBRACE

    MAIN            shift and go to state 10

    main_function                  shift and go to state 9

state 8

    (3) global_scope -> VARIABLES . LBRACE decl_list RBRACE function_decl_list
    (4) global_scope -> VARIABLES . LBRACE decl_list RBRACE

    LBRACE          shift and go to state 11


state 9

    (1) program -> PROGRAM ID SEMICOLON placeholder_goto_main create_scopes global_scope main_function . end_scopes fill_goto_main
    (11) end_scopes -> .

    $end            reduce using rule 11 (end_scopes -> .)

    end_scopes                     shift and go to state 12

state 10

    (7) main_function -> MAIN . LPAREN RPAREN LBRACE start_main stmt_list RBRACE

    LPAREN          shift and go to state 13


state 11

    (3) global_scope -> VARIABLES LBRACE . decl_list RBRACE function_decl_list
    (4) global_scope -> VARIABLES LBRACE . decl_list RBRACE
    (12) decl_list -> . decl SEMICOLON decl_list
    (13) decl_list -> . decl SEMICOLON
    (14) decl_list -> . empty
    (15) decl -> . type ID
    (16) decl -> . array_decl
    (90) empty -> .
    (17) type -> . INT
    (18) type -> . FLOAT
    (19) type -> . STRING
    (20) type -> . BOOL
    (85) array_decl -> . type ID LBRACKET CTEI RBRACKET

    RBRACE          reduce using rule 90 (empty -> .)
    INT             shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 21
    BOOL            shift and go to state 22

    decl_list                      shift and go to state 14
    decl                           shift and go to state 15
    empty                          shift and go to state 16
    type                           shift and go to state 17
    array_decl                     shift and go to state 18

state 12

    (1) program -> PROGRAM ID SEMICOLON placeholder_goto_main create_scopes global_scope main_function end_scopes . fill_goto_main
    (9) fill_goto_main -> .

    $end            reduce using rule 9 (fill_goto_main -> .)

    fill_goto_main                 shift and go to state 23

state 13

    (7) main_function -> MAIN LPAREN . RPAREN LBRACE start_main stmt_list RBRACE

    RPAREN          shift and go to state 24


state 14

    (3) global_scope -> VARIABLES LBRACE decl_list . RBRACE function_decl_list
    (4) global_scope -> VARIABLES LBRACE decl_list . RBRACE

    RBRACE          shift and go to state 25


state 15

    (12) decl_list -> decl . SEMICOLON decl_list
    (13) decl_list -> decl . SEMICOLON

    SEMICOLON       shift and go to state 26


state 16

    (14) decl_list -> empty .

    RBRACE          reduce using rule 14 (decl_list -> empty .)


state 17

    (15) decl -> type . ID
    (85) array_decl -> type . ID LBRACKET CTEI RBRACKET

    ID              shift and go to state 27


state 18

    (16) decl -> array_decl .

    SEMICOLON       reduce using rule 16 (decl -> array_decl .)


state 19

    (17) type -> INT .

    ID              reduce using rule 17 (type -> INT .)


state 20

    (18) type -> FLOAT .

    ID              reduce using rule 18 (type -> FLOAT .)


state 21

    (19) type -> STRING .

    ID              reduce using rule 19 (type -> STRING .)


state 22

    (20) type -> BOOL .

    ID              reduce using rule 20 (type -> BOOL .)


state 23

    (1) program -> PROGRAM ID SEMICOLON placeholder_goto_main create_scopes global_scope main_function end_scopes fill_goto_main .

    $end            reduce using rule 1 (program -> PROGRAM ID SEMICOLON placeholder_goto_main create_scopes global_scope main_function end_scopes fill_goto_main .)


state 24

    (7) main_function -> MAIN LPAREN RPAREN . LBRACE start_main stmt_list RBRACE

    LBRACE          shift and go to state 28


state 25

    (3) global_scope -> VARIABLES LBRACE decl_list RBRACE . function_decl_list
    (4) global_scope -> VARIABLES LBRACE decl_list RBRACE .
    (5) function_decl_list -> . function_decl function_decl_list
    (6) function_decl_list -> . empty
    (74) function_decl -> . type ID LPAREN create_function_scope param_list RPAREN LBRACE stmt_list end_scopes RBRACE
    (75) function_decl -> . VOID ID LPAREN create_function_scope param_list RPAREN LBRACE stmt_list end_scopes RBRACE
    (90) empty -> .
    (17) type -> . INT
    (18) type -> . FLOAT
    (19) type -> . STRING
    (20) type -> . BOOL

  ! reduce/reduce conflict for MAIN resolved using rule 4 (global_scope -> VARIABLES LBRACE decl_list RBRACE .)
    MAIN            reduce using rule 4 (global_scope -> VARIABLES LBRACE decl_list RBRACE .)
    VOID            shift and go to state 33
    INT             shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 21
    BOOL            shift and go to state 22

  ! MAIN            [ reduce using rule 90 (empty -> .) ]

    function_decl_list             shift and go to state 29
    function_decl                  shift and go to state 30
    empty                          shift and go to state 31
    type                           shift and go to state 32

state 26

    (12) decl_list -> decl SEMICOLON . decl_list
    (13) decl_list -> decl SEMICOLON .
    (12) decl_list -> . decl SEMICOLON decl_list
    (13) decl_list -> . decl SEMICOLON
    (14) decl_list -> . empty
    (15) decl -> . type ID
    (16) decl -> . array_decl
    (90) empty -> .
    (17) type -> . INT
    (18) type -> . FLOAT
    (19) type -> . STRING
    (20) type -> . BOOL
    (85) array_decl -> . type ID LBRACKET CTEI RBRACKET

  ! reduce/reduce conflict for RBRACE resolved using rule 13 (decl_list -> decl SEMICOLON .)
    RBRACE          reduce using rule 13 (decl_list -> decl SEMICOLON .)
    INT             shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 21
    BOOL            shift and go to state 22

  ! RBRACE          [ reduce using rule 90 (empty -> .) ]

    decl                           shift and go to state 15
    decl_list                      shift and go to state 34
    empty                          shift and go to state 16
    type                           shift and go to state 17
    array_decl                     shift and go to state 18

state 27

    (15) decl -> type ID .
    (85) array_decl -> type ID . LBRACKET CTEI RBRACKET

    SEMICOLON       reduce using rule 15 (decl -> type ID .)
    LBRACKET        shift and go to state 35


state 28

    (7) main_function -> MAIN LPAREN RPAREN LBRACE . start_main stmt_list RBRACE
    (8) start_main -> .

    ID              reduce using rule 8 (start_main -> .)
    PRINT           reduce using rule 8 (start_main -> .)
    IF              reduce using rule 8 (start_main -> .)
    WHILE           reduce using rule 8 (start_main -> .)
    TEACH_SUM       reduce using rule 8 (start_main -> .)
    TEACH_SUBSTRACTION reduce using rule 8 (start_main -> .)
    TEACH_MULTIPLICATION reduce using rule 8 (start_main -> .)
    TEACH_DIVISION  reduce using rule 8 (start_main -> .)
    TEACH_IF        reduce using rule 8 (start_main -> .)
    TEACH_WHILE     reduce using rule 8 (start_main -> .)
    TEACH_FUNCTION_DECLARATION reduce using rule 8 (start_main -> .)
    TEACH_FUNCTION_CALL reduce using rule 8 (start_main -> .)
    AYUDA           reduce using rule 8 (start_main -> .)
    RETURN          reduce using rule 8 (start_main -> .)
    INT             reduce using rule 8 (start_main -> .)
    FLOAT           reduce using rule 8 (start_main -> .)
    STRING          reduce using rule 8 (start_main -> .)
    BOOL            reduce using rule 8 (start_main -> .)
    SEMICOLON       reduce using rule 8 (start_main -> .)

    start_main                     shift and go to state 36

state 29

    (3) global_scope -> VARIABLES LBRACE decl_list RBRACE function_decl_list .

    MAIN            reduce using rule 3 (global_scope -> VARIABLES LBRACE decl_list RBRACE function_decl_list .)


state 30

    (5) function_decl_list -> function_decl . function_decl_list
    (5) function_decl_list -> . function_decl function_decl_list
    (6) function_decl_list -> . empty
    (74) function_decl -> . type ID LPAREN create_function_scope param_list RPAREN LBRACE stmt_list end_scopes RBRACE
    (75) function_decl -> . VOID ID LPAREN create_function_scope param_list RPAREN LBRACE stmt_list end_scopes RBRACE
    (90) empty -> .
    (17) type -> . INT
    (18) type -> . FLOAT
    (19) type -> . STRING
    (20) type -> . BOOL

    VOID            shift and go to state 33
    MAIN            reduce using rule 90 (empty -> .)
    INT             shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 21
    BOOL            shift and go to state 22

    function_decl                  shift and go to state 30
    function_decl_list             shift and go to state 37
    empty                          shift and go to state 31
    type                           shift and go to state 32

state 31

    (6) function_decl_list -> empty .

    MAIN            reduce using rule 6 (function_decl_list -> empty .)


state 32

    (74) function_decl -> type . ID LPAREN create_function_scope param_list RPAREN LBRACE stmt_list end_scopes RBRACE

    ID              shift and go to state 38


state 33

    (75) function_decl -> VOID . ID LPAREN create_function_scope param_list RPAREN LBRACE stmt_list end_scopes RBRACE

    ID              shift and go to state 39


state 34

    (12) decl_list -> decl SEMICOLON decl_list .

    RBRACE          reduce using rule 12 (decl_list -> decl SEMICOLON decl_list .)


state 35

    (85) array_decl -> type ID LBRACKET . CTEI RBRACKET

    CTEI            shift and go to state 40


state 36

    (7) main_function -> MAIN LPAREN RPAREN LBRACE start_main . stmt_list RBRACE
    (21) stmt_list -> . stmt SEMICOLON stmt_list
    (22) stmt_list -> . stmt SEMICOLON
    (23) stmt -> . assign
    (24) stmt -> . array_assign
    (25) stmt -> . print
    (26) stmt -> . conditional
    (27) stmt -> . loop
    (28) stmt -> . function_call
    (29) stmt -> . decl
    (30) stmt -> . built_in_function
    (31) stmt -> . return_stmt
    (41) assign -> . ID EQUALS expr
    (86) array_assign -> . ID EQUALS LBRACE CTEI_list RBRACE
    (59) print -> . PRINT COLON expr
    (60) conditional -> . IF LPAREN comp_expr RPAREN LBRACE stmt_list RBRACE else_stmt
    (61) conditional -> . IF LPAREN comp_expr RPAREN LBRACE stmt_list RBRACE
    (72) loop -> . WHILE LPAREN comp_expr RPAREN LBRACE stmt_list RBRACE
    (78) function_call -> . ID LPAREN arg_list RPAREN
    (15) decl -> . type ID
    (16) decl -> . array_decl
    (32) built_in_function -> . TEACH_SUM LPAREN RPAREN
    (33) built_in_function -> . TEACH_SUBSTRACTION LPAREN RPAREN
    (34) built_in_function -> . TEACH_MULTIPLICATION LPAREN RPAREN
    (35) built_in_function -> . TEACH_DIVISION LPAREN RPAREN
    (36) built_in_function -> . TEACH_IF LPAREN RPAREN
    (37) built_in_function -> . TEACH_WHILE LPAREN RPAREN
    (38) built_in_function -> . TEACH_FUNCTION_DECLARATION LPAREN RPAREN
    (39) built_in_function -> . TEACH_FUNCTION_CALL LPAREN RPAREN
    (40) built_in_function -> . AYUDA LPAREN RPAREN
    (76) return_stmt -> . RETURN expr
    (77) return_stmt -> . empty
    (17) type -> . INT
    (18) type -> . FLOAT
    (19) type -> . STRING
    (20) type -> . BOOL
    (85) array_decl -> . type ID LBRACKET CTEI RBRACKET
    (90) empty -> .

    ID              shift and go to state 52
    PRINT           shift and go to state 53
    IF              shift and go to state 54
    WHILE           shift and go to state 55
    TEACH_SUM       shift and go to state 56
    TEACH_SUBSTRACTION shift and go to state 57
    TEACH_MULTIPLICATION shift and go to state 58
    TEACH_DIVISION  shift and go to state 59
    TEACH_IF        shift and go to state 60
    TEACH_WHILE     shift and go to state 61
    TEACH_FUNCTION_DECLARATION shift and go to state 62
    TEACH_FUNCTION_CALL shift and go to state 63
    AYUDA           shift and go to state 64
    RETURN          shift and go to state 65
    INT             shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 21
    BOOL            shift and go to state 22
    SEMICOLON       reduce using rule 90 (empty -> .)

    stmt_list                      shift and go to state 41
    stmt                           shift and go to state 42
    assign                         shift and go to state 43
    array_assign                   shift and go to state 44
    print                          shift and go to state 45
    conditional                    shift and go to state 46
    loop                           shift and go to state 47
    function_call                  shift and go to state 48
    decl                           shift and go to state 49
    built_in_function              shift and go to state 50
    return_stmt                    shift and go to state 51
    type                           shift and go to state 17
    array_decl                     shift and go to state 18
    empty                          shift and go to state 66

state 37

    (5) function_decl_list -> function_decl function_decl_list .

    MAIN            reduce using rule 5 (function_decl_list -> function_decl function_decl_list .)


state 38

    (74) function_decl -> type ID . LPAREN create_function_scope param_list RPAREN LBRACE stmt_list end_scopes RBRACE

    LPAREN          shift and go to state 67


state 39

    (75) function_decl -> VOID ID . LPAREN create_function_scope param_list RPAREN LBRACE stmt_list end_scopes RBRACE

    LPAREN          shift and go to state 68


state 40

    (85) array_decl -> type ID LBRACKET CTEI . RBRACKET

    RBRACKET        shift and go to state 69


state 41

    (7) main_function -> MAIN LPAREN RPAREN LBRACE start_main stmt_list . RBRACE

    RBRACE          shift and go to state 70


state 42

    (21) stmt_list -> stmt . SEMICOLON stmt_list
    (22) stmt_list -> stmt . SEMICOLON

    SEMICOLON       shift and go to state 71


state 43

    (23) stmt -> assign .

    SEMICOLON       reduce using rule 23 (stmt -> assign .)


state 44

    (24) stmt -> array_assign .

    SEMICOLON       reduce using rule 24 (stmt -> array_assign .)


state 45

    (25) stmt -> print .

    SEMICOLON       reduce using rule 25 (stmt -> print .)


state 46

    (26) stmt -> conditional .

    SEMICOLON       reduce using rule 26 (stmt -> conditional .)


state 47

    (27) stmt -> loop .

    SEMICOLON       reduce using rule 27 (stmt -> loop .)


state 48

    (28) stmt -> function_call .

    SEMICOLON       reduce using rule 28 (stmt -> function_call .)


state 49

    (29) stmt -> decl .

    SEMICOLON       reduce using rule 29 (stmt -> decl .)


state 50

    (30) stmt -> built_in_function .

    SEMICOLON       reduce using rule 30 (stmt -> built_in_function .)


state 51

    (31) stmt -> return_stmt .

    SEMICOLON       reduce using rule 31 (stmt -> return_stmt .)


state 52

    (41) assign -> ID . EQUALS expr
    (86) array_assign -> ID . EQUALS LBRACE CTEI_list RBRACE
    (78) function_call -> ID . LPAREN arg_list RPAREN

    EQUALS          shift and go to state 72
    LPAREN          shift and go to state 73


state 53

    (59) print -> PRINT . COLON expr

    COLON           shift and go to state 74


state 54

    (60) conditional -> IF . LPAREN comp_expr RPAREN LBRACE stmt_list RBRACE else_stmt
    (61) conditional -> IF . LPAREN comp_expr RPAREN LBRACE stmt_list RBRACE

    LPAREN          shift and go to state 75


state 55

    (72) loop -> WHILE . LPAREN comp_expr RPAREN LBRACE stmt_list RBRACE

    LPAREN          shift and go to state 76


state 56

    (32) built_in_function -> TEACH_SUM . LPAREN RPAREN

    LPAREN          shift and go to state 77


state 57

    (33) built_in_function -> TEACH_SUBSTRACTION . LPAREN RPAREN

    LPAREN          shift and go to state 78


state 58

    (34) built_in_function -> TEACH_MULTIPLICATION . LPAREN RPAREN

    LPAREN          shift and go to state 79


state 59

    (35) built_in_function -> TEACH_DIVISION . LPAREN RPAREN

    LPAREN          shift and go to state 80


state 60

    (36) built_in_function -> TEACH_IF . LPAREN RPAREN

    LPAREN          shift and go to state 81


state 61

    (37) built_in_function -> TEACH_WHILE . LPAREN RPAREN

    LPAREN          shift and go to state 82


state 62

    (38) built_in_function -> TEACH_FUNCTION_DECLARATION . LPAREN RPAREN

    LPAREN          shift and go to state 83


state 63

    (39) built_in_function -> TEACH_FUNCTION_CALL . LPAREN RPAREN

    LPAREN          shift and go to state 84


state 64

    (40) built_in_function -> AYUDA . LPAREN RPAREN

    LPAREN          shift and go to state 85


state 65

    (76) return_stmt -> RETURN . expr
    (42) expr -> . expr PLUS term
    (43) expr -> . expr MINUS term
    (44) expr -> . expr comp_op term
    (45) expr -> . term
    (46) term -> . term MULTIPLY factor
    (47) term -> . term DIVIDE factor
    (48) term -> . factor
    (49) term -> . function_call
    (50) term -> . array_access
    (51) factor -> . LPAREN expr RPAREN
    (52) factor -> . CTEI
    (53) factor -> . FLOAT_NUMBER
    (54) factor -> . STRING_LITERAL
    (55) factor -> . TRUE
    (56) factor -> . FALSE
    (57) factor -> . ID
    (58) factor -> . function_call
    (78) function_call -> . ID LPAREN arg_list RPAREN
    (89) array_access -> . ID LBRACKET expr RBRACKET

    LPAREN          shift and go to state 91
    CTEI            shift and go to state 92
    FLOAT_NUMBER    shift and go to state 93
    STRING_LITERAL  shift and go to state 94
    TRUE            shift and go to state 95
    FALSE           shift and go to state 96
    ID              shift and go to state 97

    expr                           shift and go to state 86
    term                           shift and go to state 87
    factor                         shift and go to state 88
    function_call                  shift and go to state 89
    array_access                   shift and go to state 90

state 66

    (77) return_stmt -> empty .

    SEMICOLON       reduce using rule 77 (return_stmt -> empty .)


state 67

    (74) function_decl -> type ID LPAREN . create_function_scope param_list RPAREN LBRACE stmt_list end_scopes RBRACE
    (73) create_function_scope -> .

    INT             reduce using rule 73 (create_function_scope -> .)
    FLOAT           reduce using rule 73 (create_function_scope -> .)
    STRING          reduce using rule 73 (create_function_scope -> .)
    BOOL            reduce using rule 73 (create_function_scope -> .)
    RPAREN          reduce using rule 73 (create_function_scope -> .)

    create_function_scope          shift and go to state 98

state 68

    (75) function_decl -> VOID ID LPAREN . create_function_scope param_list RPAREN LBRACE stmt_list end_scopes RBRACE
    (73) create_function_scope -> .

    INT             reduce using rule 73 (create_function_scope -> .)
    FLOAT           reduce using rule 73 (create_function_scope -> .)
    STRING          reduce using rule 73 (create_function_scope -> .)
    BOOL            reduce using rule 73 (create_function_scope -> .)
    RPAREN          reduce using rule 73 (create_function_scope -> .)

    create_function_scope          shift and go to state 99

state 69

    (85) array_decl -> type ID LBRACKET CTEI RBRACKET .

    SEMICOLON       reduce using rule 85 (array_decl -> type ID LBRACKET CTEI RBRACKET .)


state 70

    (7) main_function -> MAIN LPAREN RPAREN LBRACE start_main stmt_list RBRACE .

    $end            reduce using rule 7 (main_function -> MAIN LPAREN RPAREN LBRACE start_main stmt_list RBRACE .)


state 71

    (21) stmt_list -> stmt SEMICOLON . stmt_list
    (22) stmt_list -> stmt SEMICOLON .
    (21) stmt_list -> . stmt SEMICOLON stmt_list
    (22) stmt_list -> . stmt SEMICOLON
    (23) stmt -> . assign
    (24) stmt -> . array_assign
    (25) stmt -> . print
    (26) stmt -> . conditional
    (27) stmt -> . loop
    (28) stmt -> . function_call
    (29) stmt -> . decl
    (30) stmt -> . built_in_function
    (31) stmt -> . return_stmt
    (41) assign -> . ID EQUALS expr
    (86) array_assign -> . ID EQUALS LBRACE CTEI_list RBRACE
    (59) print -> . PRINT COLON expr
    (60) conditional -> . IF LPAREN comp_expr RPAREN LBRACE stmt_list RBRACE else_stmt
    (61) conditional -> . IF LPAREN comp_expr RPAREN LBRACE stmt_list RBRACE
    (72) loop -> . WHILE LPAREN comp_expr RPAREN LBRACE stmt_list RBRACE
    (78) function_call -> . ID LPAREN arg_list RPAREN
    (15) decl -> . type ID
    (16) decl -> . array_decl
    (32) built_in_function -> . TEACH_SUM LPAREN RPAREN
    (33) built_in_function -> . TEACH_SUBSTRACTION LPAREN RPAREN
    (34) built_in_function -> . TEACH_MULTIPLICATION LPAREN RPAREN
    (35) built_in_function -> . TEACH_DIVISION LPAREN RPAREN
    (36) built_in_function -> . TEACH_IF LPAREN RPAREN
    (37) built_in_function -> . TEACH_WHILE LPAREN RPAREN
    (38) built_in_function -> . TEACH_FUNCTION_DECLARATION LPAREN RPAREN
    (39) built_in_function -> . TEACH_FUNCTION_CALL LPAREN RPAREN
    (40) built_in_function -> . AYUDA LPAREN RPAREN
    (76) return_stmt -> . RETURN expr
    (77) return_stmt -> . empty
    (17) type -> . INT
    (18) type -> . FLOAT
    (19) type -> . STRING
    (20) type -> . BOOL
    (85) array_decl -> . type ID LBRACKET CTEI RBRACKET
    (90) empty -> .

    RBRACE          reduce using rule 22 (stmt_list -> stmt SEMICOLON .)
    ID              shift and go to state 52
    PRINT           shift and go to state 53
    IF              shift and go to state 54
    WHILE           shift and go to state 55
    TEACH_SUM       shift and go to state 56
    TEACH_SUBSTRACTION shift and go to state 57
    TEACH_MULTIPLICATION shift and go to state 58
    TEACH_DIVISION  shift and go to state 59
    TEACH_IF        shift and go to state 60
    TEACH_WHILE     shift and go to state 61
    TEACH_FUNCTION_DECLARATION shift and go to state 62
    TEACH_FUNCTION_CALL shift and go to state 63
    AYUDA           shift and go to state 64
    RETURN          shift and go to state 65
    INT             shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 21
    BOOL            shift and go to state 22
    SEMICOLON       reduce using rule 90 (empty -> .)

    stmt                           shift and go to state 42
    stmt_list                      shift and go to state 100
    assign                         shift and go to state 43
    array_assign                   shift and go to state 44
    print                          shift and go to state 45
    conditional                    shift and go to state 46
    loop                           shift and go to state 47
    function_call                  shift and go to state 48
    decl                           shift and go to state 49
    built_in_function              shift and go to state 50
    return_stmt                    shift and go to state 51
    type                           shift and go to state 17
    array_decl                     shift and go to state 18
    empty                          shift and go to state 66

state 72

    (41) assign -> ID EQUALS . expr
    (86) array_assign -> ID EQUALS . LBRACE CTEI_list RBRACE
    (42) expr -> . expr PLUS term
    (43) expr -> . expr MINUS term
    (44) expr -> . expr comp_op term
    (45) expr -> . term
    (46) term -> . term MULTIPLY factor
    (47) term -> . term DIVIDE factor
    (48) term -> . factor
    (49) term -> . function_call
    (50) term -> . array_access
    (51) factor -> . LPAREN expr RPAREN
    (52) factor -> . CTEI
    (53) factor -> . FLOAT_NUMBER
    (54) factor -> . STRING_LITERAL
    (55) factor -> . TRUE
    (56) factor -> . FALSE
    (57) factor -> . ID
    (58) factor -> . function_call
    (78) function_call -> . ID LPAREN arg_list RPAREN
    (89) array_access -> . ID LBRACKET expr RBRACKET

    LBRACE          shift and go to state 102
    LPAREN          shift and go to state 91
    CTEI            shift and go to state 92
    FLOAT_NUMBER    shift and go to state 93
    STRING_LITERAL  shift and go to state 94
    TRUE            shift and go to state 95
    FALSE           shift and go to state 96
    ID              shift and go to state 97

    expr                           shift and go to state 101
    term                           shift and go to state 87
    factor                         shift and go to state 88
    function_call                  shift and go to state 89
    array_access                   shift and go to state 90

state 73

    (78) function_call -> ID LPAREN . arg_list RPAREN
    (79) arg_list -> . arg_list COMMA expr
    (80) arg_list -> . expr
    (42) expr -> . expr PLUS term
    (43) expr -> . expr MINUS term
    (44) expr -> . expr comp_op term
    (45) expr -> . term
    (46) term -> . term MULTIPLY factor
    (47) term -> . term DIVIDE factor
    (48) term -> . factor
    (49) term -> . function_call
    (50) term -> . array_access
    (51) factor -> . LPAREN expr RPAREN
    (52) factor -> . CTEI
    (53) factor -> . FLOAT_NUMBER
    (54) factor -> . STRING_LITERAL
    (55) factor -> . TRUE
    (56) factor -> . FALSE
    (57) factor -> . ID
    (58) factor -> . function_call
    (78) function_call -> . ID LPAREN arg_list RPAREN
    (89) array_access -> . ID LBRACKET expr RBRACKET

    LPAREN          shift and go to state 91
    CTEI            shift and go to state 92
    FLOAT_NUMBER    shift and go to state 93
    STRING_LITERAL  shift and go to state 94
    TRUE            shift and go to state 95
    FALSE           shift and go to state 96
    ID              shift and go to state 97

    arg_list                       shift and go to state 103
    expr                           shift and go to state 104
    term                           shift and go to state 87
    factor                         shift and go to state 88
    function_call                  shift and go to state 89
    array_access                   shift and go to state 90

state 74

    (59) print -> PRINT COLON . expr
    (42) expr -> . expr PLUS term
    (43) expr -> . expr MINUS term
    (44) expr -> . expr comp_op term
    (45) expr -> . term
    (46) term -> . term MULTIPLY factor
    (47) term -> . term DIVIDE factor
    (48) term -> . factor
    (49) term -> . function_call
    (50) term -> . array_access
    (51) factor -> . LPAREN expr RPAREN
    (52) factor -> . CTEI
    (53) factor -> . FLOAT_NUMBER
    (54) factor -> . STRING_LITERAL
    (55) factor -> . TRUE
    (56) factor -> . FALSE
    (57) factor -> . ID
    (58) factor -> . function_call
    (78) function_call -> . ID LPAREN arg_list RPAREN
    (89) array_access -> . ID LBRACKET expr RBRACKET

    LPAREN          shift and go to state 91
    CTEI            shift and go to state 92
    FLOAT_NUMBER    shift and go to state 93
    STRING_LITERAL  shift and go to state 94
    TRUE            shift and go to state 95
    FALSE           shift and go to state 96
    ID              shift and go to state 97

    expr                           shift and go to state 105
    term                           shift and go to state 87
    factor                         shift and go to state 88
    function_call                  shift and go to state 89
    array_access                   shift and go to state 90

state 75

    (60) conditional -> IF LPAREN . comp_expr RPAREN LBRACE stmt_list RBRACE else_stmt
    (61) conditional -> IF LPAREN . comp_expr RPAREN LBRACE stmt_list RBRACE
    (62) comp_expr -> . expr comp_op expr
    (42) expr -> . expr PLUS term
    (43) expr -> . expr MINUS term
    (44) expr -> . expr comp_op term
    (45) expr -> . term
    (46) term -> . term MULTIPLY factor
    (47) term -> . term DIVIDE factor
    (48) term -> . factor
    (49) term -> . function_call
    (50) term -> . array_access
    (51) factor -> . LPAREN expr RPAREN
    (52) factor -> . CTEI
    (53) factor -> . FLOAT_NUMBER
    (54) factor -> . STRING_LITERAL
    (55) factor -> . TRUE
    (56) factor -> . FALSE
    (57) factor -> . ID
    (58) factor -> . function_call
    (78) function_call -> . ID LPAREN arg_list RPAREN
    (89) array_access -> . ID LBRACKET expr RBRACKET

    LPAREN          shift and go to state 91
    CTEI            shift and go to state 92
    FLOAT_NUMBER    shift and go to state 93
    STRING_LITERAL  shift and go to state 94
    TRUE            shift and go to state 95
    FALSE           shift and go to state 96
    ID              shift and go to state 97

    comp_expr                      shift and go to state 106
    expr                           shift and go to state 107
    term                           shift and go to state 87
    factor                         shift and go to state 88
    function_call                  shift and go to state 89
    array_access                   shift and go to state 90

state 76

    (72) loop -> WHILE LPAREN . comp_expr RPAREN LBRACE stmt_list RBRACE
    (62) comp_expr -> . expr comp_op expr
    (42) expr -> . expr PLUS term
    (43) expr -> . expr MINUS term
    (44) expr -> . expr comp_op term
    (45) expr -> . term
    (46) term -> . term MULTIPLY factor
    (47) term -> . term DIVIDE factor
    (48) term -> . factor
    (49) term -> . function_call
    (50) term -> . array_access
    (51) factor -> . LPAREN expr RPAREN
    (52) factor -> . CTEI
    (53) factor -> . FLOAT_NUMBER
    (54) factor -> . STRING_LITERAL
    (55) factor -> . TRUE
    (56) factor -> . FALSE
    (57) factor -> . ID
    (58) factor -> . function_call
    (78) function_call -> . ID LPAREN arg_list RPAREN
    (89) array_access -> . ID LBRACKET expr RBRACKET

    LPAREN          shift and go to state 91
    CTEI            shift and go to state 92
    FLOAT_NUMBER    shift and go to state 93
    STRING_LITERAL  shift and go to state 94
    TRUE            shift and go to state 95
    FALSE           shift and go to state 96
    ID              shift and go to state 97

    comp_expr                      shift and go to state 108
    expr                           shift and go to state 107
    term                           shift and go to state 87
    factor                         shift and go to state 88
    function_call                  shift and go to state 89
    array_access                   shift and go to state 90

state 77

    (32) built_in_function -> TEACH_SUM LPAREN . RPAREN

    RPAREN          shift and go to state 109


state 78

    (33) built_in_function -> TEACH_SUBSTRACTION LPAREN . RPAREN

    RPAREN          shift and go to state 110


state 79

    (34) built_in_function -> TEACH_MULTIPLICATION LPAREN . RPAREN

    RPAREN          shift and go to state 111


state 80

    (35) built_in_function -> TEACH_DIVISION LPAREN . RPAREN

    RPAREN          shift and go to state 112


state 81

    (36) built_in_function -> TEACH_IF LPAREN . RPAREN

    RPAREN          shift and go to state 113


state 82

    (37) built_in_function -> TEACH_WHILE LPAREN . RPAREN

    RPAREN          shift and go to state 114


state 83

    (38) built_in_function -> TEACH_FUNCTION_DECLARATION LPAREN . RPAREN

    RPAREN          shift and go to state 115


state 84

    (39) built_in_function -> TEACH_FUNCTION_CALL LPAREN . RPAREN

    RPAREN          shift and go to state 116


state 85

    (40) built_in_function -> AYUDA LPAREN . RPAREN

    RPAREN          shift and go to state 117


state 86

    (76) return_stmt -> RETURN expr .
    (42) expr -> expr . PLUS term
    (43) expr -> expr . MINUS term
    (44) expr -> expr . comp_op term
    (63) comp_op -> . LESS_THAN
    (64) comp_op -> . GREATER_THAN
    (65) comp_op -> . LESS_EQUAL
    (66) comp_op -> . GREATER_EQUAL
    (67) comp_op -> . EQUAL_EQUAL
    (68) comp_op -> . NOT_EQUAL

    SEMICOLON       reduce using rule 76 (return_stmt -> RETURN expr .)
    PLUS            shift and go to state 118
    MINUS           shift and go to state 119
    LESS_THAN       shift and go to state 121
    GREATER_THAN    shift and go to state 122
    LESS_EQUAL      shift and go to state 123
    GREATER_EQUAL   shift and go to state 124
    EQUAL_EQUAL     shift and go to state 125
    NOT_EQUAL       shift and go to state 126

    comp_op                        shift and go to state 120

state 87

    (45) expr -> term .
    (46) term -> term . MULTIPLY factor
    (47) term -> term . DIVIDE factor

    PLUS            reduce using rule 45 (expr -> term .)
    MINUS           reduce using rule 45 (expr -> term .)
    LESS_THAN       reduce using rule 45 (expr -> term .)
    GREATER_THAN    reduce using rule 45 (expr -> term .)
    LESS_EQUAL      reduce using rule 45 (expr -> term .)
    GREATER_EQUAL   reduce using rule 45 (expr -> term .)
    EQUAL_EQUAL     reduce using rule 45 (expr -> term .)
    NOT_EQUAL       reduce using rule 45 (expr -> term .)
    SEMICOLON       reduce using rule 45 (expr -> term .)
    RPAREN          reduce using rule 45 (expr -> term .)
    COMMA           reduce using rule 45 (expr -> term .)
    RBRACKET        reduce using rule 45 (expr -> term .)
    MULTIPLY        shift and go to state 127
    DIVIDE          shift and go to state 128


state 88

    (48) term -> factor .

    MULTIPLY        reduce using rule 48 (term -> factor .)
    DIVIDE          reduce using rule 48 (term -> factor .)
    PLUS            reduce using rule 48 (term -> factor .)
    MINUS           reduce using rule 48 (term -> factor .)
    LESS_THAN       reduce using rule 48 (term -> factor .)
    GREATER_THAN    reduce using rule 48 (term -> factor .)
    LESS_EQUAL      reduce using rule 48 (term -> factor .)
    GREATER_EQUAL   reduce using rule 48 (term -> factor .)
    EQUAL_EQUAL     reduce using rule 48 (term -> factor .)
    NOT_EQUAL       reduce using rule 48 (term -> factor .)
    SEMICOLON       reduce using rule 48 (term -> factor .)
    RPAREN          reduce using rule 48 (term -> factor .)
    COMMA           reduce using rule 48 (term -> factor .)
    RBRACKET        reduce using rule 48 (term -> factor .)


state 89

    (49) term -> function_call .
    (58) factor -> function_call .

  ! reduce/reduce conflict for MULTIPLY resolved using rule 49 (term -> function_call .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 49 (term -> function_call .)
  ! reduce/reduce conflict for PLUS resolved using rule 49 (term -> function_call .)
  ! reduce/reduce conflict for MINUS resolved using rule 49 (term -> function_call .)
  ! reduce/reduce conflict for LESS_THAN resolved using rule 49 (term -> function_call .)
  ! reduce/reduce conflict for GREATER_THAN resolved using rule 49 (term -> function_call .)
  ! reduce/reduce conflict for LESS_EQUAL resolved using rule 49 (term -> function_call .)
  ! reduce/reduce conflict for GREATER_EQUAL resolved using rule 49 (term -> function_call .)
  ! reduce/reduce conflict for EQUAL_EQUAL resolved using rule 49 (term -> function_call .)
  ! reduce/reduce conflict for NOT_EQUAL resolved using rule 49 (term -> function_call .)
  ! reduce/reduce conflict for SEMICOLON resolved using rule 49 (term -> function_call .)
  ! reduce/reduce conflict for RPAREN resolved using rule 49 (term -> function_call .)
  ! reduce/reduce conflict for COMMA resolved using rule 49 (term -> function_call .)
  ! reduce/reduce conflict for RBRACKET resolved using rule 49 (term -> function_call .)
    MULTIPLY        reduce using rule 49 (term -> function_call .)
    DIVIDE          reduce using rule 49 (term -> function_call .)
    PLUS            reduce using rule 49 (term -> function_call .)
    MINUS           reduce using rule 49 (term -> function_call .)
    LESS_THAN       reduce using rule 49 (term -> function_call .)
    GREATER_THAN    reduce using rule 49 (term -> function_call .)
    LESS_EQUAL      reduce using rule 49 (term -> function_call .)
    GREATER_EQUAL   reduce using rule 49 (term -> function_call .)
    EQUAL_EQUAL     reduce using rule 49 (term -> function_call .)
    NOT_EQUAL       reduce using rule 49 (term -> function_call .)
    SEMICOLON       reduce using rule 49 (term -> function_call .)
    RPAREN          reduce using rule 49 (term -> function_call .)
    COMMA           reduce using rule 49 (term -> function_call .)
    RBRACKET        reduce using rule 49 (term -> function_call .)

  ! MULTIPLY        [ reduce using rule 58 (factor -> function_call .) ]
  ! DIVIDE          [ reduce using rule 58 (factor -> function_call .) ]
  ! PLUS            [ reduce using rule 58 (factor -> function_call .) ]
  ! MINUS           [ reduce using rule 58 (factor -> function_call .) ]
  ! LESS_THAN       [ reduce using rule 58 (factor -> function_call .) ]
  ! GREATER_THAN    [ reduce using rule 58 (factor -> function_call .) ]
  ! LESS_EQUAL      [ reduce using rule 58 (factor -> function_call .) ]
  ! GREATER_EQUAL   [ reduce using rule 58 (factor -> function_call .) ]
  ! EQUAL_EQUAL     [ reduce using rule 58 (factor -> function_call .) ]
  ! NOT_EQUAL       [ reduce using rule 58 (factor -> function_call .) ]
  ! SEMICOLON       [ reduce using rule 58 (factor -> function_call .) ]
  ! RPAREN          [ reduce using rule 58 (factor -> function_call .) ]
  ! COMMA           [ reduce using rule 58 (factor -> function_call .) ]
  ! RBRACKET        [ reduce using rule 58 (factor -> function_call .) ]


state 90

    (50) term -> array_access .

    MULTIPLY        reduce using rule 50 (term -> array_access .)
    DIVIDE          reduce using rule 50 (term -> array_access .)
    PLUS            reduce using rule 50 (term -> array_access .)
    MINUS           reduce using rule 50 (term -> array_access .)
    LESS_THAN       reduce using rule 50 (term -> array_access .)
    GREATER_THAN    reduce using rule 50 (term -> array_access .)
    LESS_EQUAL      reduce using rule 50 (term -> array_access .)
    GREATER_EQUAL   reduce using rule 50 (term -> array_access .)
    EQUAL_EQUAL     reduce using rule 50 (term -> array_access .)
    NOT_EQUAL       reduce using rule 50 (term -> array_access .)
    SEMICOLON       reduce using rule 50 (term -> array_access .)
    RPAREN          reduce using rule 50 (term -> array_access .)
    COMMA           reduce using rule 50 (term -> array_access .)
    RBRACKET        reduce using rule 50 (term -> array_access .)


state 91

    (51) factor -> LPAREN . expr RPAREN
    (42) expr -> . expr PLUS term
    (43) expr -> . expr MINUS term
    (44) expr -> . expr comp_op term
    (45) expr -> . term
    (46) term -> . term MULTIPLY factor
    (47) term -> . term DIVIDE factor
    (48) term -> . factor
    (49) term -> . function_call
    (50) term -> . array_access
    (51) factor -> . LPAREN expr RPAREN
    (52) factor -> . CTEI
    (53) factor -> . FLOAT_NUMBER
    (54) factor -> . STRING_LITERAL
    (55) factor -> . TRUE
    (56) factor -> . FALSE
    (57) factor -> . ID
    (58) factor -> . function_call
    (78) function_call -> . ID LPAREN arg_list RPAREN
    (89) array_access -> . ID LBRACKET expr RBRACKET

    LPAREN          shift and go to state 91
    CTEI            shift and go to state 92
    FLOAT_NUMBER    shift and go to state 93
    STRING_LITERAL  shift and go to state 94
    TRUE            shift and go to state 95
    FALSE           shift and go to state 96
    ID              shift and go to state 97

    expr                           shift and go to state 129
    term                           shift and go to state 87
    factor                         shift and go to state 88
    function_call                  shift and go to state 89
    array_access                   shift and go to state 90

state 92

    (52) factor -> CTEI .

    MULTIPLY        reduce using rule 52 (factor -> CTEI .)
    DIVIDE          reduce using rule 52 (factor -> CTEI .)
    PLUS            reduce using rule 52 (factor -> CTEI .)
    MINUS           reduce using rule 52 (factor -> CTEI .)
    LESS_THAN       reduce using rule 52 (factor -> CTEI .)
    GREATER_THAN    reduce using rule 52 (factor -> CTEI .)
    LESS_EQUAL      reduce using rule 52 (factor -> CTEI .)
    GREATER_EQUAL   reduce using rule 52 (factor -> CTEI .)
    EQUAL_EQUAL     reduce using rule 52 (factor -> CTEI .)
    NOT_EQUAL       reduce using rule 52 (factor -> CTEI .)
    SEMICOLON       reduce using rule 52 (factor -> CTEI .)
    RPAREN          reduce using rule 52 (factor -> CTEI .)
    COMMA           reduce using rule 52 (factor -> CTEI .)
    RBRACKET        reduce using rule 52 (factor -> CTEI .)


state 93

    (53) factor -> FLOAT_NUMBER .

    MULTIPLY        reduce using rule 53 (factor -> FLOAT_NUMBER .)
    DIVIDE          reduce using rule 53 (factor -> FLOAT_NUMBER .)
    PLUS            reduce using rule 53 (factor -> FLOAT_NUMBER .)
    MINUS           reduce using rule 53 (factor -> FLOAT_NUMBER .)
    LESS_THAN       reduce using rule 53 (factor -> FLOAT_NUMBER .)
    GREATER_THAN    reduce using rule 53 (factor -> FLOAT_NUMBER .)
    LESS_EQUAL      reduce using rule 53 (factor -> FLOAT_NUMBER .)
    GREATER_EQUAL   reduce using rule 53 (factor -> FLOAT_NUMBER .)
    EQUAL_EQUAL     reduce using rule 53 (factor -> FLOAT_NUMBER .)
    NOT_EQUAL       reduce using rule 53 (factor -> FLOAT_NUMBER .)
    SEMICOLON       reduce using rule 53 (factor -> FLOAT_NUMBER .)
    RPAREN          reduce using rule 53 (factor -> FLOAT_NUMBER .)
    COMMA           reduce using rule 53 (factor -> FLOAT_NUMBER .)
    RBRACKET        reduce using rule 53 (factor -> FLOAT_NUMBER .)


state 94

    (54) factor -> STRING_LITERAL .

    MULTIPLY        reduce using rule 54 (factor -> STRING_LITERAL .)
    DIVIDE          reduce using rule 54 (factor -> STRING_LITERAL .)
    PLUS            reduce using rule 54 (factor -> STRING_LITERAL .)
    MINUS           reduce using rule 54 (factor -> STRING_LITERAL .)
    LESS_THAN       reduce using rule 54 (factor -> STRING_LITERAL .)
    GREATER_THAN    reduce using rule 54 (factor -> STRING_LITERAL .)
    LESS_EQUAL      reduce using rule 54 (factor -> STRING_LITERAL .)
    GREATER_EQUAL   reduce using rule 54 (factor -> STRING_LITERAL .)
    EQUAL_EQUAL     reduce using rule 54 (factor -> STRING_LITERAL .)
    NOT_EQUAL       reduce using rule 54 (factor -> STRING_LITERAL .)
    SEMICOLON       reduce using rule 54 (factor -> STRING_LITERAL .)
    RPAREN          reduce using rule 54 (factor -> STRING_LITERAL .)
    COMMA           reduce using rule 54 (factor -> STRING_LITERAL .)
    RBRACKET        reduce using rule 54 (factor -> STRING_LITERAL .)


state 95

    (55) factor -> TRUE .

    MULTIPLY        reduce using rule 55 (factor -> TRUE .)
    DIVIDE          reduce using rule 55 (factor -> TRUE .)
    PLUS            reduce using rule 55 (factor -> TRUE .)
    MINUS           reduce using rule 55 (factor -> TRUE .)
    LESS_THAN       reduce using rule 55 (factor -> TRUE .)
    GREATER_THAN    reduce using rule 55 (factor -> TRUE .)
    LESS_EQUAL      reduce using rule 55 (factor -> TRUE .)
    GREATER_EQUAL   reduce using rule 55 (factor -> TRUE .)
    EQUAL_EQUAL     reduce using rule 55 (factor -> TRUE .)
    NOT_EQUAL       reduce using rule 55 (factor -> TRUE .)
    SEMICOLON       reduce using rule 55 (factor -> TRUE .)
    RPAREN          reduce using rule 55 (factor -> TRUE .)
    COMMA           reduce using rule 55 (factor -> TRUE .)
    RBRACKET        reduce using rule 55 (factor -> TRUE .)


state 96

    (56) factor -> FALSE .

    MULTIPLY        reduce using rule 56 (factor -> FALSE .)
    DIVIDE          reduce using rule 56 (factor -> FALSE .)
    PLUS            reduce using rule 56 (factor -> FALSE .)
    MINUS           reduce using rule 56 (factor -> FALSE .)
    LESS_THAN       reduce using rule 56 (factor -> FALSE .)
    GREATER_THAN    reduce using rule 56 (factor -> FALSE .)
    LESS_EQUAL      reduce using rule 56 (factor -> FALSE .)
    GREATER_EQUAL   reduce using rule 56 (factor -> FALSE .)
    EQUAL_EQUAL     reduce using rule 56 (factor -> FALSE .)
    NOT_EQUAL       reduce using rule 56 (factor -> FALSE .)
    SEMICOLON       reduce using rule 56 (factor -> FALSE .)
    RPAREN          reduce using rule 56 (factor -> FALSE .)
    COMMA           reduce using rule 56 (factor -> FALSE .)
    RBRACKET        reduce using rule 56 (factor -> FALSE .)


state 97

    (57) factor -> ID .
    (78) function_call -> ID . LPAREN arg_list RPAREN
    (89) array_access -> ID . LBRACKET expr RBRACKET

    MULTIPLY        reduce using rule 57 (factor -> ID .)
    DIVIDE          reduce using rule 57 (factor -> ID .)
    PLUS            reduce using rule 57 (factor -> ID .)
    MINUS           reduce using rule 57 (factor -> ID .)
    LESS_THAN       reduce using rule 57 (factor -> ID .)
    GREATER_THAN    reduce using rule 57 (factor -> ID .)
    LESS_EQUAL      reduce using rule 57 (factor -> ID .)
    GREATER_EQUAL   reduce using rule 57 (factor -> ID .)
    EQUAL_EQUAL     reduce using rule 57 (factor -> ID .)
    NOT_EQUAL       reduce using rule 57 (factor -> ID .)
    SEMICOLON       reduce using rule 57 (factor -> ID .)
    RPAREN          reduce using rule 57 (factor -> ID .)
    COMMA           reduce using rule 57 (factor -> ID .)
    RBRACKET        reduce using rule 57 (factor -> ID .)
    LPAREN          shift and go to state 73
    LBRACKET        shift and go to state 130


state 98

    (74) function_decl -> type ID LPAREN create_function_scope . param_list RPAREN LBRACE stmt_list end_scopes RBRACE
    (81) param_list -> . param COMMA param_list
    (82) param_list -> . param
    (83) param_list -> . empty
    (84) param -> . type ID
    (90) empty -> .
    (17) type -> . INT
    (18) type -> . FLOAT
    (19) type -> . STRING
    (20) type -> . BOOL

    RPAREN          reduce using rule 90 (empty -> .)
    INT             shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 21
    BOOL            shift and go to state 22

    type                           shift and go to state 131
    param_list                     shift and go to state 132
    param                          shift and go to state 133
    empty                          shift and go to state 134

state 99

    (75) function_decl -> VOID ID LPAREN create_function_scope . param_list RPAREN LBRACE stmt_list end_scopes RBRACE
    (81) param_list -> . param COMMA param_list
    (82) param_list -> . param
    (83) param_list -> . empty
    (84) param -> . type ID
    (90) empty -> .
    (17) type -> . INT
    (18) type -> . FLOAT
    (19) type -> . STRING
    (20) type -> . BOOL

    RPAREN          reduce using rule 90 (empty -> .)
    INT             shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 21
    BOOL            shift and go to state 22

    param_list                     shift and go to state 135
    param                          shift and go to state 133
    empty                          shift and go to state 134
    type                           shift and go to state 131

state 100

    (21) stmt_list -> stmt SEMICOLON stmt_list .

    RBRACE          reduce using rule 21 (stmt_list -> stmt SEMICOLON stmt_list .)


state 101

    (41) assign -> ID EQUALS expr .
    (42) expr -> expr . PLUS term
    (43) expr -> expr . MINUS term
    (44) expr -> expr . comp_op term
    (63) comp_op -> . LESS_THAN
    (64) comp_op -> . GREATER_THAN
    (65) comp_op -> . LESS_EQUAL
    (66) comp_op -> . GREATER_EQUAL
    (67) comp_op -> . EQUAL_EQUAL
    (68) comp_op -> . NOT_EQUAL

    SEMICOLON       reduce using rule 41 (assign -> ID EQUALS expr .)
    PLUS            shift and go to state 118
    MINUS           shift and go to state 119
    LESS_THAN       shift and go to state 121
    GREATER_THAN    shift and go to state 122
    LESS_EQUAL      shift and go to state 123
    GREATER_EQUAL   shift and go to state 124
    EQUAL_EQUAL     shift and go to state 125
    NOT_EQUAL       shift and go to state 126

    comp_op                        shift and go to state 120

state 102

    (86) array_assign -> ID EQUALS LBRACE . CTEI_list RBRACE
    (87) CTEI_list -> . CTEI
    (88) CTEI_list -> . CTEI_list COMMA CTEI

    CTEI            shift and go to state 137

    CTEI_list                      shift and go to state 136

state 103

    (78) function_call -> ID LPAREN arg_list . RPAREN
    (79) arg_list -> arg_list . COMMA expr

    RPAREN          shift and go to state 138
    COMMA           shift and go to state 139


state 104

    (80) arg_list -> expr .
    (42) expr -> expr . PLUS term
    (43) expr -> expr . MINUS term
    (44) expr -> expr . comp_op term
    (63) comp_op -> . LESS_THAN
    (64) comp_op -> . GREATER_THAN
    (65) comp_op -> . LESS_EQUAL
    (66) comp_op -> . GREATER_EQUAL
    (67) comp_op -> . EQUAL_EQUAL
    (68) comp_op -> . NOT_EQUAL

    RPAREN          reduce using rule 80 (arg_list -> expr .)
    COMMA           reduce using rule 80 (arg_list -> expr .)
    PLUS            shift and go to state 118
    MINUS           shift and go to state 119
    LESS_THAN       shift and go to state 121
    GREATER_THAN    shift and go to state 122
    LESS_EQUAL      shift and go to state 123
    GREATER_EQUAL   shift and go to state 124
    EQUAL_EQUAL     shift and go to state 125
    NOT_EQUAL       shift and go to state 126

    comp_op                        shift and go to state 120

state 105

    (59) print -> PRINT COLON expr .
    (42) expr -> expr . PLUS term
    (43) expr -> expr . MINUS term
    (44) expr -> expr . comp_op term
    (63) comp_op -> . LESS_THAN
    (64) comp_op -> . GREATER_THAN
    (65) comp_op -> . LESS_EQUAL
    (66) comp_op -> . GREATER_EQUAL
    (67) comp_op -> . EQUAL_EQUAL
    (68) comp_op -> . NOT_EQUAL

    SEMICOLON       reduce using rule 59 (print -> PRINT COLON expr .)
    PLUS            shift and go to state 118
    MINUS           shift and go to state 119
    LESS_THAN       shift and go to state 121
    GREATER_THAN    shift and go to state 122
    LESS_EQUAL      shift and go to state 123
    GREATER_EQUAL   shift and go to state 124
    EQUAL_EQUAL     shift and go to state 125
    NOT_EQUAL       shift and go to state 126

    comp_op                        shift and go to state 120

state 106

    (60) conditional -> IF LPAREN comp_expr . RPAREN LBRACE stmt_list RBRACE else_stmt
    (61) conditional -> IF LPAREN comp_expr . RPAREN LBRACE stmt_list RBRACE

    RPAREN          shift and go to state 140


state 107

    (62) comp_expr -> expr . comp_op expr
    (42) expr -> expr . PLUS term
    (43) expr -> expr . MINUS term
    (44) expr -> expr . comp_op term
    (63) comp_op -> . LESS_THAN
    (64) comp_op -> . GREATER_THAN
    (65) comp_op -> . LESS_EQUAL
    (66) comp_op -> . GREATER_EQUAL
    (67) comp_op -> . EQUAL_EQUAL
    (68) comp_op -> . NOT_EQUAL

    PLUS            shift and go to state 118
    MINUS           shift and go to state 119
    LESS_THAN       shift and go to state 121
    GREATER_THAN    shift and go to state 122
    LESS_EQUAL      shift and go to state 123
    GREATER_EQUAL   shift and go to state 124
    EQUAL_EQUAL     shift and go to state 125
    NOT_EQUAL       shift and go to state 126

    comp_op                        shift and go to state 141

state 108

    (72) loop -> WHILE LPAREN comp_expr . RPAREN LBRACE stmt_list RBRACE

    RPAREN          shift and go to state 142


state 109

    (32) built_in_function -> TEACH_SUM LPAREN RPAREN .

    SEMICOLON       reduce using rule 32 (built_in_function -> TEACH_SUM LPAREN RPAREN .)


state 110

    (33) built_in_function -> TEACH_SUBSTRACTION LPAREN RPAREN .

    SEMICOLON       reduce using rule 33 (built_in_function -> TEACH_SUBSTRACTION LPAREN RPAREN .)


state 111

    (34) built_in_function -> TEACH_MULTIPLICATION LPAREN RPAREN .

    SEMICOLON       reduce using rule 34 (built_in_function -> TEACH_MULTIPLICATION LPAREN RPAREN .)


state 112

    (35) built_in_function -> TEACH_DIVISION LPAREN RPAREN .

    SEMICOLON       reduce using rule 35 (built_in_function -> TEACH_DIVISION LPAREN RPAREN .)


state 113

    (36) built_in_function -> TEACH_IF LPAREN RPAREN .

    SEMICOLON       reduce using rule 36 (built_in_function -> TEACH_IF LPAREN RPAREN .)


state 114

    (37) built_in_function -> TEACH_WHILE LPAREN RPAREN .

    SEMICOLON       reduce using rule 37 (built_in_function -> TEACH_WHILE LPAREN RPAREN .)


state 115

    (38) built_in_function -> TEACH_FUNCTION_DECLARATION LPAREN RPAREN .

    SEMICOLON       reduce using rule 38 (built_in_function -> TEACH_FUNCTION_DECLARATION LPAREN RPAREN .)


state 116

    (39) built_in_function -> TEACH_FUNCTION_CALL LPAREN RPAREN .

    SEMICOLON       reduce using rule 39 (built_in_function -> TEACH_FUNCTION_CALL LPAREN RPAREN .)


state 117

    (40) built_in_function -> AYUDA LPAREN RPAREN .

    SEMICOLON       reduce using rule 40 (built_in_function -> AYUDA LPAREN RPAREN .)


state 118

    (42) expr -> expr PLUS . term
    (46) term -> . term MULTIPLY factor
    (47) term -> . term DIVIDE factor
    (48) term -> . factor
    (49) term -> . function_call
    (50) term -> . array_access
    (51) factor -> . LPAREN expr RPAREN
    (52) factor -> . CTEI
    (53) factor -> . FLOAT_NUMBER
    (54) factor -> . STRING_LITERAL
    (55) factor -> . TRUE
    (56) factor -> . FALSE
    (57) factor -> . ID
    (58) factor -> . function_call
    (78) function_call -> . ID LPAREN arg_list RPAREN
    (89) array_access -> . ID LBRACKET expr RBRACKET

    LPAREN          shift and go to state 91
    CTEI            shift and go to state 92
    FLOAT_NUMBER    shift and go to state 93
    STRING_LITERAL  shift and go to state 94
    TRUE            shift and go to state 95
    FALSE           shift and go to state 96
    ID              shift and go to state 97

    term                           shift and go to state 143
    factor                         shift and go to state 88
    function_call                  shift and go to state 89
    array_access                   shift and go to state 90

state 119

    (43) expr -> expr MINUS . term
    (46) term -> . term MULTIPLY factor
    (47) term -> . term DIVIDE factor
    (48) term -> . factor
    (49) term -> . function_call
    (50) term -> . array_access
    (51) factor -> . LPAREN expr RPAREN
    (52) factor -> . CTEI
    (53) factor -> . FLOAT_NUMBER
    (54) factor -> . STRING_LITERAL
    (55) factor -> . TRUE
    (56) factor -> . FALSE
    (57) factor -> . ID
    (58) factor -> . function_call
    (78) function_call -> . ID LPAREN arg_list RPAREN
    (89) array_access -> . ID LBRACKET expr RBRACKET

    LPAREN          shift and go to state 91
    CTEI            shift and go to state 92
    FLOAT_NUMBER    shift and go to state 93
    STRING_LITERAL  shift and go to state 94
    TRUE            shift and go to state 95
    FALSE           shift and go to state 96
    ID              shift and go to state 97

    term                           shift and go to state 144
    factor                         shift and go to state 88
    function_call                  shift and go to state 89
    array_access                   shift and go to state 90

state 120

    (44) expr -> expr comp_op . term
    (46) term -> . term MULTIPLY factor
    (47) term -> . term DIVIDE factor
    (48) term -> . factor
    (49) term -> . function_call
    (50) term -> . array_access
    (51) factor -> . LPAREN expr RPAREN
    (52) factor -> . CTEI
    (53) factor -> . FLOAT_NUMBER
    (54) factor -> . STRING_LITERAL
    (55) factor -> . TRUE
    (56) factor -> . FALSE
    (57) factor -> . ID
    (58) factor -> . function_call
    (78) function_call -> . ID LPAREN arg_list RPAREN
    (89) array_access -> . ID LBRACKET expr RBRACKET

    LPAREN          shift and go to state 91
    CTEI            shift and go to state 92
    FLOAT_NUMBER    shift and go to state 93
    STRING_LITERAL  shift and go to state 94
    TRUE            shift and go to state 95
    FALSE           shift and go to state 96
    ID              shift and go to state 97

    term                           shift and go to state 145
    factor                         shift and go to state 88
    function_call                  shift and go to state 89
    array_access                   shift and go to state 90

state 121

    (63) comp_op -> LESS_THAN .

    LPAREN          reduce using rule 63 (comp_op -> LESS_THAN .)
    CTEI            reduce using rule 63 (comp_op -> LESS_THAN .)
    FLOAT_NUMBER    reduce using rule 63 (comp_op -> LESS_THAN .)
    STRING_LITERAL  reduce using rule 63 (comp_op -> LESS_THAN .)
    TRUE            reduce using rule 63 (comp_op -> LESS_THAN .)
    FALSE           reduce using rule 63 (comp_op -> LESS_THAN .)
    ID              reduce using rule 63 (comp_op -> LESS_THAN .)


state 122

    (64) comp_op -> GREATER_THAN .

    LPAREN          reduce using rule 64 (comp_op -> GREATER_THAN .)
    CTEI            reduce using rule 64 (comp_op -> GREATER_THAN .)
    FLOAT_NUMBER    reduce using rule 64 (comp_op -> GREATER_THAN .)
    STRING_LITERAL  reduce using rule 64 (comp_op -> GREATER_THAN .)
    TRUE            reduce using rule 64 (comp_op -> GREATER_THAN .)
    FALSE           reduce using rule 64 (comp_op -> GREATER_THAN .)
    ID              reduce using rule 64 (comp_op -> GREATER_THAN .)


state 123

    (65) comp_op -> LESS_EQUAL .

    LPAREN          reduce using rule 65 (comp_op -> LESS_EQUAL .)
    CTEI            reduce using rule 65 (comp_op -> LESS_EQUAL .)
    FLOAT_NUMBER    reduce using rule 65 (comp_op -> LESS_EQUAL .)
    STRING_LITERAL  reduce using rule 65 (comp_op -> LESS_EQUAL .)
    TRUE            reduce using rule 65 (comp_op -> LESS_EQUAL .)
    FALSE           reduce using rule 65 (comp_op -> LESS_EQUAL .)
    ID              reduce using rule 65 (comp_op -> LESS_EQUAL .)


state 124

    (66) comp_op -> GREATER_EQUAL .

    LPAREN          reduce using rule 66 (comp_op -> GREATER_EQUAL .)
    CTEI            reduce using rule 66 (comp_op -> GREATER_EQUAL .)
    FLOAT_NUMBER    reduce using rule 66 (comp_op -> GREATER_EQUAL .)
    STRING_LITERAL  reduce using rule 66 (comp_op -> GREATER_EQUAL .)
    TRUE            reduce using rule 66 (comp_op -> GREATER_EQUAL .)
    FALSE           reduce using rule 66 (comp_op -> GREATER_EQUAL .)
    ID              reduce using rule 66 (comp_op -> GREATER_EQUAL .)


state 125

    (67) comp_op -> EQUAL_EQUAL .

    LPAREN          reduce using rule 67 (comp_op -> EQUAL_EQUAL .)
    CTEI            reduce using rule 67 (comp_op -> EQUAL_EQUAL .)
    FLOAT_NUMBER    reduce using rule 67 (comp_op -> EQUAL_EQUAL .)
    STRING_LITERAL  reduce using rule 67 (comp_op -> EQUAL_EQUAL .)
    TRUE            reduce using rule 67 (comp_op -> EQUAL_EQUAL .)
    FALSE           reduce using rule 67 (comp_op -> EQUAL_EQUAL .)
    ID              reduce using rule 67 (comp_op -> EQUAL_EQUAL .)


state 126

    (68) comp_op -> NOT_EQUAL .

    LPAREN          reduce using rule 68 (comp_op -> NOT_EQUAL .)
    CTEI            reduce using rule 68 (comp_op -> NOT_EQUAL .)
    FLOAT_NUMBER    reduce using rule 68 (comp_op -> NOT_EQUAL .)
    STRING_LITERAL  reduce using rule 68 (comp_op -> NOT_EQUAL .)
    TRUE            reduce using rule 68 (comp_op -> NOT_EQUAL .)
    FALSE           reduce using rule 68 (comp_op -> NOT_EQUAL .)
    ID              reduce using rule 68 (comp_op -> NOT_EQUAL .)


state 127

    (46) term -> term MULTIPLY . factor
    (51) factor -> . LPAREN expr RPAREN
    (52) factor -> . CTEI
    (53) factor -> . FLOAT_NUMBER
    (54) factor -> . STRING_LITERAL
    (55) factor -> . TRUE
    (56) factor -> . FALSE
    (57) factor -> . ID
    (58) factor -> . function_call
    (78) function_call -> . ID LPAREN arg_list RPAREN

    LPAREN          shift and go to state 91
    CTEI            shift and go to state 92
    FLOAT_NUMBER    shift and go to state 93
    STRING_LITERAL  shift and go to state 94
    TRUE            shift and go to state 95
    FALSE           shift and go to state 96
    ID              shift and go to state 147

    factor                         shift and go to state 146
    function_call                  shift and go to state 148

state 128

    (47) term -> term DIVIDE . factor
    (51) factor -> . LPAREN expr RPAREN
    (52) factor -> . CTEI
    (53) factor -> . FLOAT_NUMBER
    (54) factor -> . STRING_LITERAL
    (55) factor -> . TRUE
    (56) factor -> . FALSE
    (57) factor -> . ID
    (58) factor -> . function_call
    (78) function_call -> . ID LPAREN arg_list RPAREN

    LPAREN          shift and go to state 91
    CTEI            shift and go to state 92
    FLOAT_NUMBER    shift and go to state 93
    STRING_LITERAL  shift and go to state 94
    TRUE            shift and go to state 95
    FALSE           shift and go to state 96
    ID              shift and go to state 147

    factor                         shift and go to state 149
    function_call                  shift and go to state 148

state 129

    (51) factor -> LPAREN expr . RPAREN
    (42) expr -> expr . PLUS term
    (43) expr -> expr . MINUS term
    (44) expr -> expr . comp_op term
    (63) comp_op -> . LESS_THAN
    (64) comp_op -> . GREATER_THAN
    (65) comp_op -> . LESS_EQUAL
    (66) comp_op -> . GREATER_EQUAL
    (67) comp_op -> . EQUAL_EQUAL
    (68) comp_op -> . NOT_EQUAL

    RPAREN          shift and go to state 150
    PLUS            shift and go to state 118
    MINUS           shift and go to state 119
    LESS_THAN       shift and go to state 121
    GREATER_THAN    shift and go to state 122
    LESS_EQUAL      shift and go to state 123
    GREATER_EQUAL   shift and go to state 124
    EQUAL_EQUAL     shift and go to state 125
    NOT_EQUAL       shift and go to state 126

    comp_op                        shift and go to state 120

state 130

    (89) array_access -> ID LBRACKET . expr RBRACKET
    (42) expr -> . expr PLUS term
    (43) expr -> . expr MINUS term
    (44) expr -> . expr comp_op term
    (45) expr -> . term
    (46) term -> . term MULTIPLY factor
    (47) term -> . term DIVIDE factor
    (48) term -> . factor
    (49) term -> . function_call
    (50) term -> . array_access
    (51) factor -> . LPAREN expr RPAREN
    (52) factor -> . CTEI
    (53) factor -> . FLOAT_NUMBER
    (54) factor -> . STRING_LITERAL
    (55) factor -> . TRUE
    (56) factor -> . FALSE
    (57) factor -> . ID
    (58) factor -> . function_call
    (78) function_call -> . ID LPAREN arg_list RPAREN
    (89) array_access -> . ID LBRACKET expr RBRACKET

    LPAREN          shift and go to state 91
    CTEI            shift and go to state 92
    FLOAT_NUMBER    shift and go to state 93
    STRING_LITERAL  shift and go to state 94
    TRUE            shift and go to state 95
    FALSE           shift and go to state 96
    ID              shift and go to state 97

    expr                           shift and go to state 151
    term                           shift and go to state 87
    factor                         shift and go to state 88
    function_call                  shift and go to state 89
    array_access                   shift and go to state 90

state 131

    (84) param -> type . ID

    ID              shift and go to state 152


state 132

    (74) function_decl -> type ID LPAREN create_function_scope param_list . RPAREN LBRACE stmt_list end_scopes RBRACE

    RPAREN          shift and go to state 153


state 133

    (81) param_list -> param . COMMA param_list
    (82) param_list -> param .

    COMMA           shift and go to state 154
    RPAREN          reduce using rule 82 (param_list -> param .)


state 134

    (83) param_list -> empty .

    RPAREN          reduce using rule 83 (param_list -> empty .)


state 135

    (75) function_decl -> VOID ID LPAREN create_function_scope param_list . RPAREN LBRACE stmt_list end_scopes RBRACE

    RPAREN          shift and go to state 155


state 136

    (86) array_assign -> ID EQUALS LBRACE CTEI_list . RBRACE
    (88) CTEI_list -> CTEI_list . COMMA CTEI

    RBRACE          shift and go to state 156
    COMMA           shift and go to state 157


state 137

    (87) CTEI_list -> CTEI .

    RBRACE          reduce using rule 87 (CTEI_list -> CTEI .)
    COMMA           reduce using rule 87 (CTEI_list -> CTEI .)


state 138

    (78) function_call -> ID LPAREN arg_list RPAREN .

    SEMICOLON       reduce using rule 78 (function_call -> ID LPAREN arg_list RPAREN .)
    MULTIPLY        reduce using rule 78 (function_call -> ID LPAREN arg_list RPAREN .)
    DIVIDE          reduce using rule 78 (function_call -> ID LPAREN arg_list RPAREN .)
    PLUS            reduce using rule 78 (function_call -> ID LPAREN arg_list RPAREN .)
    MINUS           reduce using rule 78 (function_call -> ID LPAREN arg_list RPAREN .)
    LESS_THAN       reduce using rule 78 (function_call -> ID LPAREN arg_list RPAREN .)
    GREATER_THAN    reduce using rule 78 (function_call -> ID LPAREN arg_list RPAREN .)
    LESS_EQUAL      reduce using rule 78 (function_call -> ID LPAREN arg_list RPAREN .)
    GREATER_EQUAL   reduce using rule 78 (function_call -> ID LPAREN arg_list RPAREN .)
    EQUAL_EQUAL     reduce using rule 78 (function_call -> ID LPAREN arg_list RPAREN .)
    NOT_EQUAL       reduce using rule 78 (function_call -> ID LPAREN arg_list RPAREN .)
    RPAREN          reduce using rule 78 (function_call -> ID LPAREN arg_list RPAREN .)
    COMMA           reduce using rule 78 (function_call -> ID LPAREN arg_list RPAREN .)
    RBRACKET        reduce using rule 78 (function_call -> ID LPAREN arg_list RPAREN .)


state 139

    (79) arg_list -> arg_list COMMA . expr
    (42) expr -> . expr PLUS term
    (43) expr -> . expr MINUS term
    (44) expr -> . expr comp_op term
    (45) expr -> . term
    (46) term -> . term MULTIPLY factor
    (47) term -> . term DIVIDE factor
    (48) term -> . factor
    (49) term -> . function_call
    (50) term -> . array_access
    (51) factor -> . LPAREN expr RPAREN
    (52) factor -> . CTEI
    (53) factor -> . FLOAT_NUMBER
    (54) factor -> . STRING_LITERAL
    (55) factor -> . TRUE
    (56) factor -> . FALSE
    (57) factor -> . ID
    (58) factor -> . function_call
    (78) function_call -> . ID LPAREN arg_list RPAREN
    (89) array_access -> . ID LBRACKET expr RBRACKET

    LPAREN          shift and go to state 91
    CTEI            shift and go to state 92
    FLOAT_NUMBER    shift and go to state 93
    STRING_LITERAL  shift and go to state 94
    TRUE            shift and go to state 95
    FALSE           shift and go to state 96
    ID              shift and go to state 97

    expr                           shift and go to state 158
    term                           shift and go to state 87
    factor                         shift and go to state 88
    function_call                  shift and go to state 89
    array_access                   shift and go to state 90

state 140

    (60) conditional -> IF LPAREN comp_expr RPAREN . LBRACE stmt_list RBRACE else_stmt
    (61) conditional -> IF LPAREN comp_expr RPAREN . LBRACE stmt_list RBRACE

    LBRACE          shift and go to state 159


state 141

    (62) comp_expr -> expr comp_op . expr
    (44) expr -> expr comp_op . term
    (42) expr -> . expr PLUS term
    (43) expr -> . expr MINUS term
    (44) expr -> . expr comp_op term
    (45) expr -> . term
    (46) term -> . term MULTIPLY factor
    (47) term -> . term DIVIDE factor
    (48) term -> . factor
    (49) term -> . function_call
    (50) term -> . array_access
    (51) factor -> . LPAREN expr RPAREN
    (52) factor -> . CTEI
    (53) factor -> . FLOAT_NUMBER
    (54) factor -> . STRING_LITERAL
    (55) factor -> . TRUE
    (56) factor -> . FALSE
    (57) factor -> . ID
    (58) factor -> . function_call
    (78) function_call -> . ID LPAREN arg_list RPAREN
    (89) array_access -> . ID LBRACKET expr RBRACKET

    LPAREN          shift and go to state 91
    CTEI            shift and go to state 92
    FLOAT_NUMBER    shift and go to state 93
    STRING_LITERAL  shift and go to state 94
    TRUE            shift and go to state 95
    FALSE           shift and go to state 96
    ID              shift and go to state 97

    expr                           shift and go to state 160
    term                           shift and go to state 161
    factor                         shift and go to state 88
    function_call                  shift and go to state 89
    array_access                   shift and go to state 90

state 142

    (72) loop -> WHILE LPAREN comp_expr RPAREN . LBRACE stmt_list RBRACE

    LBRACE          shift and go to state 162


state 143

    (42) expr -> expr PLUS term .
    (46) term -> term . MULTIPLY factor
    (47) term -> term . DIVIDE factor

    PLUS            reduce using rule 42 (expr -> expr PLUS term .)
    MINUS           reduce using rule 42 (expr -> expr PLUS term .)
    LESS_THAN       reduce using rule 42 (expr -> expr PLUS term .)
    GREATER_THAN    reduce using rule 42 (expr -> expr PLUS term .)
    LESS_EQUAL      reduce using rule 42 (expr -> expr PLUS term .)
    GREATER_EQUAL   reduce using rule 42 (expr -> expr PLUS term .)
    EQUAL_EQUAL     reduce using rule 42 (expr -> expr PLUS term .)
    NOT_EQUAL       reduce using rule 42 (expr -> expr PLUS term .)
    SEMICOLON       reduce using rule 42 (expr -> expr PLUS term .)
    RPAREN          reduce using rule 42 (expr -> expr PLUS term .)
    COMMA           reduce using rule 42 (expr -> expr PLUS term .)
    RBRACKET        reduce using rule 42 (expr -> expr PLUS term .)
    MULTIPLY        shift and go to state 127
    DIVIDE          shift and go to state 128


state 144

    (43) expr -> expr MINUS term .
    (46) term -> term . MULTIPLY factor
    (47) term -> term . DIVIDE factor

    PLUS            reduce using rule 43 (expr -> expr MINUS term .)
    MINUS           reduce using rule 43 (expr -> expr MINUS term .)
    LESS_THAN       reduce using rule 43 (expr -> expr MINUS term .)
    GREATER_THAN    reduce using rule 43 (expr -> expr MINUS term .)
    LESS_EQUAL      reduce using rule 43 (expr -> expr MINUS term .)
    GREATER_EQUAL   reduce using rule 43 (expr -> expr MINUS term .)
    EQUAL_EQUAL     reduce using rule 43 (expr -> expr MINUS term .)
    NOT_EQUAL       reduce using rule 43 (expr -> expr MINUS term .)
    SEMICOLON       reduce using rule 43 (expr -> expr MINUS term .)
    RPAREN          reduce using rule 43 (expr -> expr MINUS term .)
    COMMA           reduce using rule 43 (expr -> expr MINUS term .)
    RBRACKET        reduce using rule 43 (expr -> expr MINUS term .)
    MULTIPLY        shift and go to state 127
    DIVIDE          shift and go to state 128


state 145

    (44) expr -> expr comp_op term .
    (46) term -> term . MULTIPLY factor
    (47) term -> term . DIVIDE factor

    PLUS            reduce using rule 44 (expr -> expr comp_op term .)
    MINUS           reduce using rule 44 (expr -> expr comp_op term .)
    LESS_THAN       reduce using rule 44 (expr -> expr comp_op term .)
    GREATER_THAN    reduce using rule 44 (expr -> expr comp_op term .)
    LESS_EQUAL      reduce using rule 44 (expr -> expr comp_op term .)
    GREATER_EQUAL   reduce using rule 44 (expr -> expr comp_op term .)
    EQUAL_EQUAL     reduce using rule 44 (expr -> expr comp_op term .)
    NOT_EQUAL       reduce using rule 44 (expr -> expr comp_op term .)
    SEMICOLON       reduce using rule 44 (expr -> expr comp_op term .)
    RPAREN          reduce using rule 44 (expr -> expr comp_op term .)
    COMMA           reduce using rule 44 (expr -> expr comp_op term .)
    RBRACKET        reduce using rule 44 (expr -> expr comp_op term .)
    MULTIPLY        shift and go to state 127
    DIVIDE          shift and go to state 128


state 146

    (46) term -> term MULTIPLY factor .

    MULTIPLY        reduce using rule 46 (term -> term MULTIPLY factor .)
    DIVIDE          reduce using rule 46 (term -> term MULTIPLY factor .)
    PLUS            reduce using rule 46 (term -> term MULTIPLY factor .)
    MINUS           reduce using rule 46 (term -> term MULTIPLY factor .)
    LESS_THAN       reduce using rule 46 (term -> term MULTIPLY factor .)
    GREATER_THAN    reduce using rule 46 (term -> term MULTIPLY factor .)
    LESS_EQUAL      reduce using rule 46 (term -> term MULTIPLY factor .)
    GREATER_EQUAL   reduce using rule 46 (term -> term MULTIPLY factor .)
    EQUAL_EQUAL     reduce using rule 46 (term -> term MULTIPLY factor .)
    NOT_EQUAL       reduce using rule 46 (term -> term MULTIPLY factor .)
    SEMICOLON       reduce using rule 46 (term -> term MULTIPLY factor .)
    RPAREN          reduce using rule 46 (term -> term MULTIPLY factor .)
    COMMA           reduce using rule 46 (term -> term MULTIPLY factor .)
    RBRACKET        reduce using rule 46 (term -> term MULTIPLY factor .)


state 147

    (57) factor -> ID .
    (78) function_call -> ID . LPAREN arg_list RPAREN

    MULTIPLY        reduce using rule 57 (factor -> ID .)
    DIVIDE          reduce using rule 57 (factor -> ID .)
    PLUS            reduce using rule 57 (factor -> ID .)
    MINUS           reduce using rule 57 (factor -> ID .)
    LESS_THAN       reduce using rule 57 (factor -> ID .)
    GREATER_THAN    reduce using rule 57 (factor -> ID .)
    LESS_EQUAL      reduce using rule 57 (factor -> ID .)
    GREATER_EQUAL   reduce using rule 57 (factor -> ID .)
    EQUAL_EQUAL     reduce using rule 57 (factor -> ID .)
    NOT_EQUAL       reduce using rule 57 (factor -> ID .)
    SEMICOLON       reduce using rule 57 (factor -> ID .)
    RPAREN          reduce using rule 57 (factor -> ID .)
    COMMA           reduce using rule 57 (factor -> ID .)
    RBRACKET        reduce using rule 57 (factor -> ID .)
    LPAREN          shift and go to state 73


state 148

    (58) factor -> function_call .

    MULTIPLY        reduce using rule 58 (factor -> function_call .)
    DIVIDE          reduce using rule 58 (factor -> function_call .)
    PLUS            reduce using rule 58 (factor -> function_call .)
    MINUS           reduce using rule 58 (factor -> function_call .)
    LESS_THAN       reduce using rule 58 (factor -> function_call .)
    GREATER_THAN    reduce using rule 58 (factor -> function_call .)
    LESS_EQUAL      reduce using rule 58 (factor -> function_call .)
    GREATER_EQUAL   reduce using rule 58 (factor -> function_call .)
    EQUAL_EQUAL     reduce using rule 58 (factor -> function_call .)
    NOT_EQUAL       reduce using rule 58 (factor -> function_call .)
    SEMICOLON       reduce using rule 58 (factor -> function_call .)
    RPAREN          reduce using rule 58 (factor -> function_call .)
    COMMA           reduce using rule 58 (factor -> function_call .)
    RBRACKET        reduce using rule 58 (factor -> function_call .)


state 149

    (47) term -> term DIVIDE factor .

    MULTIPLY        reduce using rule 47 (term -> term DIVIDE factor .)
    DIVIDE          reduce using rule 47 (term -> term DIVIDE factor .)
    PLUS            reduce using rule 47 (term -> term DIVIDE factor .)
    MINUS           reduce using rule 47 (term -> term DIVIDE factor .)
    LESS_THAN       reduce using rule 47 (term -> term DIVIDE factor .)
    GREATER_THAN    reduce using rule 47 (term -> term DIVIDE factor .)
    LESS_EQUAL      reduce using rule 47 (term -> term DIVIDE factor .)
    GREATER_EQUAL   reduce using rule 47 (term -> term DIVIDE factor .)
    EQUAL_EQUAL     reduce using rule 47 (term -> term DIVIDE factor .)
    NOT_EQUAL       reduce using rule 47 (term -> term DIVIDE factor .)
    SEMICOLON       reduce using rule 47 (term -> term DIVIDE factor .)
    RPAREN          reduce using rule 47 (term -> term DIVIDE factor .)
    COMMA           reduce using rule 47 (term -> term DIVIDE factor .)
    RBRACKET        reduce using rule 47 (term -> term DIVIDE factor .)


state 150

    (51) factor -> LPAREN expr RPAREN .

    MULTIPLY        reduce using rule 51 (factor -> LPAREN expr RPAREN .)
    DIVIDE          reduce using rule 51 (factor -> LPAREN expr RPAREN .)
    PLUS            reduce using rule 51 (factor -> LPAREN expr RPAREN .)
    MINUS           reduce using rule 51 (factor -> LPAREN expr RPAREN .)
    LESS_THAN       reduce using rule 51 (factor -> LPAREN expr RPAREN .)
    GREATER_THAN    reduce using rule 51 (factor -> LPAREN expr RPAREN .)
    LESS_EQUAL      reduce using rule 51 (factor -> LPAREN expr RPAREN .)
    GREATER_EQUAL   reduce using rule 51 (factor -> LPAREN expr RPAREN .)
    EQUAL_EQUAL     reduce using rule 51 (factor -> LPAREN expr RPAREN .)
    NOT_EQUAL       reduce using rule 51 (factor -> LPAREN expr RPAREN .)
    SEMICOLON       reduce using rule 51 (factor -> LPAREN expr RPAREN .)
    RPAREN          reduce using rule 51 (factor -> LPAREN expr RPAREN .)
    COMMA           reduce using rule 51 (factor -> LPAREN expr RPAREN .)
    RBRACKET        reduce using rule 51 (factor -> LPAREN expr RPAREN .)


state 151

    (89) array_access -> ID LBRACKET expr . RBRACKET
    (42) expr -> expr . PLUS term
    (43) expr -> expr . MINUS term
    (44) expr -> expr . comp_op term
    (63) comp_op -> . LESS_THAN
    (64) comp_op -> . GREATER_THAN
    (65) comp_op -> . LESS_EQUAL
    (66) comp_op -> . GREATER_EQUAL
    (67) comp_op -> . EQUAL_EQUAL
    (68) comp_op -> . NOT_EQUAL

    RBRACKET        shift and go to state 163
    PLUS            shift and go to state 118
    MINUS           shift and go to state 119
    LESS_THAN       shift and go to state 121
    GREATER_THAN    shift and go to state 122
    LESS_EQUAL      shift and go to state 123
    GREATER_EQUAL   shift and go to state 124
    EQUAL_EQUAL     shift and go to state 125
    NOT_EQUAL       shift and go to state 126

    comp_op                        shift and go to state 120

state 152

    (84) param -> type ID .

    COMMA           reduce using rule 84 (param -> type ID .)
    RPAREN          reduce using rule 84 (param -> type ID .)


state 153

    (74) function_decl -> type ID LPAREN create_function_scope param_list RPAREN . LBRACE stmt_list end_scopes RBRACE

    LBRACE          shift and go to state 164


state 154

    (81) param_list -> param COMMA . param_list
    (81) param_list -> . param COMMA param_list
    (82) param_list -> . param
    (83) param_list -> . empty
    (84) param -> . type ID
    (90) empty -> .
    (17) type -> . INT
    (18) type -> . FLOAT
    (19) type -> . STRING
    (20) type -> . BOOL

    RPAREN          reduce using rule 90 (empty -> .)
    INT             shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 21
    BOOL            shift and go to state 22

    param                          shift and go to state 133
    param_list                     shift and go to state 165
    empty                          shift and go to state 134
    type                           shift and go to state 131

state 155

    (75) function_decl -> VOID ID LPAREN create_function_scope param_list RPAREN . LBRACE stmt_list end_scopes RBRACE

    LBRACE          shift and go to state 166


state 156

    (86) array_assign -> ID EQUALS LBRACE CTEI_list RBRACE .

    SEMICOLON       reduce using rule 86 (array_assign -> ID EQUALS LBRACE CTEI_list RBRACE .)


state 157

    (88) CTEI_list -> CTEI_list COMMA . CTEI

    CTEI            shift and go to state 167


state 158

    (79) arg_list -> arg_list COMMA expr .
    (42) expr -> expr . PLUS term
    (43) expr -> expr . MINUS term
    (44) expr -> expr . comp_op term
    (63) comp_op -> . LESS_THAN
    (64) comp_op -> . GREATER_THAN
    (65) comp_op -> . LESS_EQUAL
    (66) comp_op -> . GREATER_EQUAL
    (67) comp_op -> . EQUAL_EQUAL
    (68) comp_op -> . NOT_EQUAL

    RPAREN          reduce using rule 79 (arg_list -> arg_list COMMA expr .)
    COMMA           reduce using rule 79 (arg_list -> arg_list COMMA expr .)
    PLUS            shift and go to state 118
    MINUS           shift and go to state 119
    LESS_THAN       shift and go to state 121
    GREATER_THAN    shift and go to state 122
    LESS_EQUAL      shift and go to state 123
    GREATER_EQUAL   shift and go to state 124
    EQUAL_EQUAL     shift and go to state 125
    NOT_EQUAL       shift and go to state 126

    comp_op                        shift and go to state 120

state 159

    (60) conditional -> IF LPAREN comp_expr RPAREN LBRACE . stmt_list RBRACE else_stmt
    (61) conditional -> IF LPAREN comp_expr RPAREN LBRACE . stmt_list RBRACE
    (21) stmt_list -> . stmt SEMICOLON stmt_list
    (22) stmt_list -> . stmt SEMICOLON
    (23) stmt -> . assign
    (24) stmt -> . array_assign
    (25) stmt -> . print
    (26) stmt -> . conditional
    (27) stmt -> . loop
    (28) stmt -> . function_call
    (29) stmt -> . decl
    (30) stmt -> . built_in_function
    (31) stmt -> . return_stmt
    (41) assign -> . ID EQUALS expr
    (86) array_assign -> . ID EQUALS LBRACE CTEI_list RBRACE
    (59) print -> . PRINT COLON expr
    (60) conditional -> . IF LPAREN comp_expr RPAREN LBRACE stmt_list RBRACE else_stmt
    (61) conditional -> . IF LPAREN comp_expr RPAREN LBRACE stmt_list RBRACE
    (72) loop -> . WHILE LPAREN comp_expr RPAREN LBRACE stmt_list RBRACE
    (78) function_call -> . ID LPAREN arg_list RPAREN
    (15) decl -> . type ID
    (16) decl -> . array_decl
    (32) built_in_function -> . TEACH_SUM LPAREN RPAREN
    (33) built_in_function -> . TEACH_SUBSTRACTION LPAREN RPAREN
    (34) built_in_function -> . TEACH_MULTIPLICATION LPAREN RPAREN
    (35) built_in_function -> . TEACH_DIVISION LPAREN RPAREN
    (36) built_in_function -> . TEACH_IF LPAREN RPAREN
    (37) built_in_function -> . TEACH_WHILE LPAREN RPAREN
    (38) built_in_function -> . TEACH_FUNCTION_DECLARATION LPAREN RPAREN
    (39) built_in_function -> . TEACH_FUNCTION_CALL LPAREN RPAREN
    (40) built_in_function -> . AYUDA LPAREN RPAREN
    (76) return_stmt -> . RETURN expr
    (77) return_stmt -> . empty
    (17) type -> . INT
    (18) type -> . FLOAT
    (19) type -> . STRING
    (20) type -> . BOOL
    (85) array_decl -> . type ID LBRACKET CTEI RBRACKET
    (90) empty -> .

    ID              shift and go to state 52
    PRINT           shift and go to state 53
    IF              shift and go to state 54
    WHILE           shift and go to state 55
    TEACH_SUM       shift and go to state 56
    TEACH_SUBSTRACTION shift and go to state 57
    TEACH_MULTIPLICATION shift and go to state 58
    TEACH_DIVISION  shift and go to state 59
    TEACH_IF        shift and go to state 60
    TEACH_WHILE     shift and go to state 61
    TEACH_FUNCTION_DECLARATION shift and go to state 62
    TEACH_FUNCTION_CALL shift and go to state 63
    AYUDA           shift and go to state 64
    RETURN          shift and go to state 65
    INT             shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 21
    BOOL            shift and go to state 22
    SEMICOLON       reduce using rule 90 (empty -> .)

    stmt_list                      shift and go to state 168
    stmt                           shift and go to state 42
    assign                         shift and go to state 43
    array_assign                   shift and go to state 44
    print                          shift and go to state 45
    conditional                    shift and go to state 46
    loop                           shift and go to state 47
    function_call                  shift and go to state 48
    decl                           shift and go to state 49
    built_in_function              shift and go to state 50
    return_stmt                    shift and go to state 51
    type                           shift and go to state 17
    array_decl                     shift and go to state 18
    empty                          shift and go to state 66

state 160

    (62) comp_expr -> expr comp_op expr .
    (42) expr -> expr . PLUS term
    (43) expr -> expr . MINUS term
    (44) expr -> expr . comp_op term
    (63) comp_op -> . LESS_THAN
    (64) comp_op -> . GREATER_THAN
    (65) comp_op -> . LESS_EQUAL
    (66) comp_op -> . GREATER_EQUAL
    (67) comp_op -> . EQUAL_EQUAL
    (68) comp_op -> . NOT_EQUAL

    RPAREN          reduce using rule 62 (comp_expr -> expr comp_op expr .)
    PLUS            shift and go to state 118
    MINUS           shift and go to state 119
    LESS_THAN       shift and go to state 121
    GREATER_THAN    shift and go to state 122
    LESS_EQUAL      shift and go to state 123
    GREATER_EQUAL   shift and go to state 124
    EQUAL_EQUAL     shift and go to state 125
    NOT_EQUAL       shift and go to state 126

    comp_op                        shift and go to state 120

state 161

    (44) expr -> expr comp_op term .
    (45) expr -> term .
    (46) term -> term . MULTIPLY factor
    (47) term -> term . DIVIDE factor

  ! reduce/reduce conflict for PLUS resolved using rule 44 (expr -> expr comp_op term .)
  ! reduce/reduce conflict for MINUS resolved using rule 44 (expr -> expr comp_op term .)
  ! reduce/reduce conflict for LESS_THAN resolved using rule 44 (expr -> expr comp_op term .)
  ! reduce/reduce conflict for GREATER_THAN resolved using rule 44 (expr -> expr comp_op term .)
  ! reduce/reduce conflict for LESS_EQUAL resolved using rule 44 (expr -> expr comp_op term .)
  ! reduce/reduce conflict for GREATER_EQUAL resolved using rule 44 (expr -> expr comp_op term .)
  ! reduce/reduce conflict for EQUAL_EQUAL resolved using rule 44 (expr -> expr comp_op term .)
  ! reduce/reduce conflict for NOT_EQUAL resolved using rule 44 (expr -> expr comp_op term .)
    PLUS            reduce using rule 44 (expr -> expr comp_op term .)
    MINUS           reduce using rule 44 (expr -> expr comp_op term .)
    LESS_THAN       reduce using rule 44 (expr -> expr comp_op term .)
    GREATER_THAN    reduce using rule 44 (expr -> expr comp_op term .)
    LESS_EQUAL      reduce using rule 44 (expr -> expr comp_op term .)
    GREATER_EQUAL   reduce using rule 44 (expr -> expr comp_op term .)
    EQUAL_EQUAL     reduce using rule 44 (expr -> expr comp_op term .)
    NOT_EQUAL       reduce using rule 44 (expr -> expr comp_op term .)
    RPAREN          reduce using rule 45 (expr -> term .)
    MULTIPLY        shift and go to state 127
    DIVIDE          shift and go to state 128

  ! PLUS            [ reduce using rule 45 (expr -> term .) ]
  ! MINUS           [ reduce using rule 45 (expr -> term .) ]
  ! LESS_THAN       [ reduce using rule 45 (expr -> term .) ]
  ! GREATER_THAN    [ reduce using rule 45 (expr -> term .) ]
  ! LESS_EQUAL      [ reduce using rule 45 (expr -> term .) ]
  ! GREATER_EQUAL   [ reduce using rule 45 (expr -> term .) ]
  ! EQUAL_EQUAL     [ reduce using rule 45 (expr -> term .) ]
  ! NOT_EQUAL       [ reduce using rule 45 (expr -> term .) ]


state 162

    (72) loop -> WHILE LPAREN comp_expr RPAREN LBRACE . stmt_list RBRACE
    (21) stmt_list -> . stmt SEMICOLON stmt_list
    (22) stmt_list -> . stmt SEMICOLON
    (23) stmt -> . assign
    (24) stmt -> . array_assign
    (25) stmt -> . print
    (26) stmt -> . conditional
    (27) stmt -> . loop
    (28) stmt -> . function_call
    (29) stmt -> . decl
    (30) stmt -> . built_in_function
    (31) stmt -> . return_stmt
    (41) assign -> . ID EQUALS expr
    (86) array_assign -> . ID EQUALS LBRACE CTEI_list RBRACE
    (59) print -> . PRINT COLON expr
    (60) conditional -> . IF LPAREN comp_expr RPAREN LBRACE stmt_list RBRACE else_stmt
    (61) conditional -> . IF LPAREN comp_expr RPAREN LBRACE stmt_list RBRACE
    (72) loop -> . WHILE LPAREN comp_expr RPAREN LBRACE stmt_list RBRACE
    (78) function_call -> . ID LPAREN arg_list RPAREN
    (15) decl -> . type ID
    (16) decl -> . array_decl
    (32) built_in_function -> . TEACH_SUM LPAREN RPAREN
    (33) built_in_function -> . TEACH_SUBSTRACTION LPAREN RPAREN
    (34) built_in_function -> . TEACH_MULTIPLICATION LPAREN RPAREN
    (35) built_in_function -> . TEACH_DIVISION LPAREN RPAREN
    (36) built_in_function -> . TEACH_IF LPAREN RPAREN
    (37) built_in_function -> . TEACH_WHILE LPAREN RPAREN
    (38) built_in_function -> . TEACH_FUNCTION_DECLARATION LPAREN RPAREN
    (39) built_in_function -> . TEACH_FUNCTION_CALL LPAREN RPAREN
    (40) built_in_function -> . AYUDA LPAREN RPAREN
    (76) return_stmt -> . RETURN expr
    (77) return_stmt -> . empty
    (17) type -> . INT
    (18) type -> . FLOAT
    (19) type -> . STRING
    (20) type -> . BOOL
    (85) array_decl -> . type ID LBRACKET CTEI RBRACKET
    (90) empty -> .

    ID              shift and go to state 52
    PRINT           shift and go to state 53
    IF              shift and go to state 54
    WHILE           shift and go to state 55
    TEACH_SUM       shift and go to state 56
    TEACH_SUBSTRACTION shift and go to state 57
    TEACH_MULTIPLICATION shift and go to state 58
    TEACH_DIVISION  shift and go to state 59
    TEACH_IF        shift and go to state 60
    TEACH_WHILE     shift and go to state 61
    TEACH_FUNCTION_DECLARATION shift and go to state 62
    TEACH_FUNCTION_CALL shift and go to state 63
    AYUDA           shift and go to state 64
    RETURN          shift and go to state 65
    INT             shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 21
    BOOL            shift and go to state 22
    SEMICOLON       reduce using rule 90 (empty -> .)

    stmt_list                      shift and go to state 169
    stmt                           shift and go to state 42
    assign                         shift and go to state 43
    array_assign                   shift and go to state 44
    print                          shift and go to state 45
    conditional                    shift and go to state 46
    loop                           shift and go to state 47
    function_call                  shift and go to state 48
    decl                           shift and go to state 49
    built_in_function              shift and go to state 50
    return_stmt                    shift and go to state 51
    type                           shift and go to state 17
    array_decl                     shift and go to state 18
    empty                          shift and go to state 66

state 163

    (89) array_access -> ID LBRACKET expr RBRACKET .

    MULTIPLY        reduce using rule 89 (array_access -> ID LBRACKET expr RBRACKET .)
    DIVIDE          reduce using rule 89 (array_access -> ID LBRACKET expr RBRACKET .)
    PLUS            reduce using rule 89 (array_access -> ID LBRACKET expr RBRACKET .)
    MINUS           reduce using rule 89 (array_access -> ID LBRACKET expr RBRACKET .)
    LESS_THAN       reduce using rule 89 (array_access -> ID LBRACKET expr RBRACKET .)
    GREATER_THAN    reduce using rule 89 (array_access -> ID LBRACKET expr RBRACKET .)
    LESS_EQUAL      reduce using rule 89 (array_access -> ID LBRACKET expr RBRACKET .)
    GREATER_EQUAL   reduce using rule 89 (array_access -> ID LBRACKET expr RBRACKET .)
    EQUAL_EQUAL     reduce using rule 89 (array_access -> ID LBRACKET expr RBRACKET .)
    NOT_EQUAL       reduce using rule 89 (array_access -> ID LBRACKET expr RBRACKET .)
    SEMICOLON       reduce using rule 89 (array_access -> ID LBRACKET expr RBRACKET .)
    RPAREN          reduce using rule 89 (array_access -> ID LBRACKET expr RBRACKET .)
    COMMA           reduce using rule 89 (array_access -> ID LBRACKET expr RBRACKET .)
    RBRACKET        reduce using rule 89 (array_access -> ID LBRACKET expr RBRACKET .)


state 164

    (74) function_decl -> type ID LPAREN create_function_scope param_list RPAREN LBRACE . stmt_list end_scopes RBRACE
    (21) stmt_list -> . stmt SEMICOLON stmt_list
    (22) stmt_list -> . stmt SEMICOLON
    (23) stmt -> . assign
    (24) stmt -> . array_assign
    (25) stmt -> . print
    (26) stmt -> . conditional
    (27) stmt -> . loop
    (28) stmt -> . function_call
    (29) stmt -> . decl
    (30) stmt -> . built_in_function
    (31) stmt -> . return_stmt
    (41) assign -> . ID EQUALS expr
    (86) array_assign -> . ID EQUALS LBRACE CTEI_list RBRACE
    (59) print -> . PRINT COLON expr
    (60) conditional -> . IF LPAREN comp_expr RPAREN LBRACE stmt_list RBRACE else_stmt
    (61) conditional -> . IF LPAREN comp_expr RPAREN LBRACE stmt_list RBRACE
    (72) loop -> . WHILE LPAREN comp_expr RPAREN LBRACE stmt_list RBRACE
    (78) function_call -> . ID LPAREN arg_list RPAREN
    (15) decl -> . type ID
    (16) decl -> . array_decl
    (32) built_in_function -> . TEACH_SUM LPAREN RPAREN
    (33) built_in_function -> . TEACH_SUBSTRACTION LPAREN RPAREN
    (34) built_in_function -> . TEACH_MULTIPLICATION LPAREN RPAREN
    (35) built_in_function -> . TEACH_DIVISION LPAREN RPAREN
    (36) built_in_function -> . TEACH_IF LPAREN RPAREN
    (37) built_in_function -> . TEACH_WHILE LPAREN RPAREN
    (38) built_in_function -> . TEACH_FUNCTION_DECLARATION LPAREN RPAREN
    (39) built_in_function -> . TEACH_FUNCTION_CALL LPAREN RPAREN
    (40) built_in_function -> . AYUDA LPAREN RPAREN
    (76) return_stmt -> . RETURN expr
    (77) return_stmt -> . empty
    (17) type -> . INT
    (18) type -> . FLOAT
    (19) type -> . STRING
    (20) type -> . BOOL
    (85) array_decl -> . type ID LBRACKET CTEI RBRACKET
    (90) empty -> .

    ID              shift and go to state 52
    PRINT           shift and go to state 53
    IF              shift and go to state 54
    WHILE           shift and go to state 55
    TEACH_SUM       shift and go to state 56
    TEACH_SUBSTRACTION shift and go to state 57
    TEACH_MULTIPLICATION shift and go to state 58
    TEACH_DIVISION  shift and go to state 59
    TEACH_IF        shift and go to state 60
    TEACH_WHILE     shift and go to state 61
    TEACH_FUNCTION_DECLARATION shift and go to state 62
    TEACH_FUNCTION_CALL shift and go to state 63
    AYUDA           shift and go to state 64
    RETURN          shift and go to state 65
    INT             shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 21
    BOOL            shift and go to state 22
    SEMICOLON       reduce using rule 90 (empty -> .)

    type                           shift and go to state 17
    stmt_list                      shift and go to state 170
    stmt                           shift and go to state 42
    assign                         shift and go to state 43
    array_assign                   shift and go to state 44
    print                          shift and go to state 45
    conditional                    shift and go to state 46
    loop                           shift and go to state 47
    function_call                  shift and go to state 48
    decl                           shift and go to state 49
    built_in_function              shift and go to state 50
    return_stmt                    shift and go to state 51
    array_decl                     shift and go to state 18
    empty                          shift and go to state 66

state 165

    (81) param_list -> param COMMA param_list .

    RPAREN          reduce using rule 81 (param_list -> param COMMA param_list .)


state 166

    (75) function_decl -> VOID ID LPAREN create_function_scope param_list RPAREN LBRACE . stmt_list end_scopes RBRACE
    (21) stmt_list -> . stmt SEMICOLON stmt_list
    (22) stmt_list -> . stmt SEMICOLON
    (23) stmt -> . assign
    (24) stmt -> . array_assign
    (25) stmt -> . print
    (26) stmt -> . conditional
    (27) stmt -> . loop
    (28) stmt -> . function_call
    (29) stmt -> . decl
    (30) stmt -> . built_in_function
    (31) stmt -> . return_stmt
    (41) assign -> . ID EQUALS expr
    (86) array_assign -> . ID EQUALS LBRACE CTEI_list RBRACE
    (59) print -> . PRINT COLON expr
    (60) conditional -> . IF LPAREN comp_expr RPAREN LBRACE stmt_list RBRACE else_stmt
    (61) conditional -> . IF LPAREN comp_expr RPAREN LBRACE stmt_list RBRACE
    (72) loop -> . WHILE LPAREN comp_expr RPAREN LBRACE stmt_list RBRACE
    (78) function_call -> . ID LPAREN arg_list RPAREN
    (15) decl -> . type ID
    (16) decl -> . array_decl
    (32) built_in_function -> . TEACH_SUM LPAREN RPAREN
    (33) built_in_function -> . TEACH_SUBSTRACTION LPAREN RPAREN
    (34) built_in_function -> . TEACH_MULTIPLICATION LPAREN RPAREN
    (35) built_in_function -> . TEACH_DIVISION LPAREN RPAREN
    (36) built_in_function -> . TEACH_IF LPAREN RPAREN
    (37) built_in_function -> . TEACH_WHILE LPAREN RPAREN
    (38) built_in_function -> . TEACH_FUNCTION_DECLARATION LPAREN RPAREN
    (39) built_in_function -> . TEACH_FUNCTION_CALL LPAREN RPAREN
    (40) built_in_function -> . AYUDA LPAREN RPAREN
    (76) return_stmt -> . RETURN expr
    (77) return_stmt -> . empty
    (17) type -> . INT
    (18) type -> . FLOAT
    (19) type -> . STRING
    (20) type -> . BOOL
    (85) array_decl -> . type ID LBRACKET CTEI RBRACKET
    (90) empty -> .

    ID              shift and go to state 52
    PRINT           shift and go to state 53
    IF              shift and go to state 54
    WHILE           shift and go to state 55
    TEACH_SUM       shift and go to state 56
    TEACH_SUBSTRACTION shift and go to state 57
    TEACH_MULTIPLICATION shift and go to state 58
    TEACH_DIVISION  shift and go to state 59
    TEACH_IF        shift and go to state 60
    TEACH_WHILE     shift and go to state 61
    TEACH_FUNCTION_DECLARATION shift and go to state 62
    TEACH_FUNCTION_CALL shift and go to state 63
    AYUDA           shift and go to state 64
    RETURN          shift and go to state 65
    INT             shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 21
    BOOL            shift and go to state 22
    SEMICOLON       reduce using rule 90 (empty -> .)

    stmt_list                      shift and go to state 171
    stmt                           shift and go to state 42
    assign                         shift and go to state 43
    array_assign                   shift and go to state 44
    print                          shift and go to state 45
    conditional                    shift and go to state 46
    loop                           shift and go to state 47
    function_call                  shift and go to state 48
    decl                           shift and go to state 49
    built_in_function              shift and go to state 50
    return_stmt                    shift and go to state 51
    type                           shift and go to state 17
    array_decl                     shift and go to state 18
    empty                          shift and go to state 66

state 167

    (88) CTEI_list -> CTEI_list COMMA CTEI .

    RBRACE          reduce using rule 88 (CTEI_list -> CTEI_list COMMA CTEI .)
    COMMA           reduce using rule 88 (CTEI_list -> CTEI_list COMMA CTEI .)


state 168

    (60) conditional -> IF LPAREN comp_expr RPAREN LBRACE stmt_list . RBRACE else_stmt
    (61) conditional -> IF LPAREN comp_expr RPAREN LBRACE stmt_list . RBRACE

    RBRACE          shift and go to state 172


state 169

    (72) loop -> WHILE LPAREN comp_expr RPAREN LBRACE stmt_list . RBRACE

    RBRACE          shift and go to state 173


state 170

    (74) function_decl -> type ID LPAREN create_function_scope param_list RPAREN LBRACE stmt_list . end_scopes RBRACE
    (11) end_scopes -> .

    RBRACE          reduce using rule 11 (end_scopes -> .)

    end_scopes                     shift and go to state 174

state 171

    (75) function_decl -> VOID ID LPAREN create_function_scope param_list RPAREN LBRACE stmt_list . end_scopes RBRACE
    (11) end_scopes -> .

    RBRACE          reduce using rule 11 (end_scopes -> .)

    end_scopes                     shift and go to state 175

state 172

    (60) conditional -> IF LPAREN comp_expr RPAREN LBRACE stmt_list RBRACE . else_stmt
    (61) conditional -> IF LPAREN comp_expr RPAREN LBRACE stmt_list RBRACE .
    (69) else_stmt -> . ELSE LBRACE else_part stmt_list RBRACE
    (70) else_stmt -> . empty
    (90) empty -> .

  ! reduce/reduce conflict for SEMICOLON resolved using rule 61 (conditional -> IF LPAREN comp_expr RPAREN LBRACE stmt_list RBRACE .)
    SEMICOLON       reduce using rule 61 (conditional -> IF LPAREN comp_expr RPAREN LBRACE stmt_list RBRACE .)
    ELSE            shift and go to state 177

  ! SEMICOLON       [ reduce using rule 90 (empty -> .) ]

    else_stmt                      shift and go to state 176
    empty                          shift and go to state 178

state 173

    (72) loop -> WHILE LPAREN comp_expr RPAREN LBRACE stmt_list RBRACE .

    SEMICOLON       reduce using rule 72 (loop -> WHILE LPAREN comp_expr RPAREN LBRACE stmt_list RBRACE .)


state 174

    (74) function_decl -> type ID LPAREN create_function_scope param_list RPAREN LBRACE stmt_list end_scopes . RBRACE

    RBRACE          shift and go to state 179


state 175

    (75) function_decl -> VOID ID LPAREN create_function_scope param_list RPAREN LBRACE stmt_list end_scopes . RBRACE

    RBRACE          shift and go to state 180


state 176

    (60) conditional -> IF LPAREN comp_expr RPAREN LBRACE stmt_list RBRACE else_stmt .

    SEMICOLON       reduce using rule 60 (conditional -> IF LPAREN comp_expr RPAREN LBRACE stmt_list RBRACE else_stmt .)


state 177

    (69) else_stmt -> ELSE . LBRACE else_part stmt_list RBRACE

    LBRACE          shift and go to state 181


state 178

    (70) else_stmt -> empty .

    SEMICOLON       reduce using rule 70 (else_stmt -> empty .)


state 179

    (74) function_decl -> type ID LPAREN create_function_scope param_list RPAREN LBRACE stmt_list end_scopes RBRACE .

    VOID            reduce using rule 74 (function_decl -> type ID LPAREN create_function_scope param_list RPAREN LBRACE stmt_list end_scopes RBRACE .)
    INT             reduce using rule 74 (function_decl -> type ID LPAREN create_function_scope param_list RPAREN LBRACE stmt_list end_scopes RBRACE .)
    FLOAT           reduce using rule 74 (function_decl -> type ID LPAREN create_function_scope param_list RPAREN LBRACE stmt_list end_scopes RBRACE .)
    STRING          reduce using rule 74 (function_decl -> type ID LPAREN create_function_scope param_list RPAREN LBRACE stmt_list end_scopes RBRACE .)
    BOOL            reduce using rule 74 (function_decl -> type ID LPAREN create_function_scope param_list RPAREN LBRACE stmt_list end_scopes RBRACE .)
    MAIN            reduce using rule 74 (function_decl -> type ID LPAREN create_function_scope param_list RPAREN LBRACE stmt_list end_scopes RBRACE .)


state 180

    (75) function_decl -> VOID ID LPAREN create_function_scope param_list RPAREN LBRACE stmt_list end_scopes RBRACE .

    VOID            reduce using rule 75 (function_decl -> VOID ID LPAREN create_function_scope param_list RPAREN LBRACE stmt_list end_scopes RBRACE .)
    INT             reduce using rule 75 (function_decl -> VOID ID LPAREN create_function_scope param_list RPAREN LBRACE stmt_list end_scopes RBRACE .)
    FLOAT           reduce using rule 75 (function_decl -> VOID ID LPAREN create_function_scope param_list RPAREN LBRACE stmt_list end_scopes RBRACE .)
    STRING          reduce using rule 75 (function_decl -> VOID ID LPAREN create_function_scope param_list RPAREN LBRACE stmt_list end_scopes RBRACE .)
    BOOL            reduce using rule 75 (function_decl -> VOID ID LPAREN create_function_scope param_list RPAREN LBRACE stmt_list end_scopes RBRACE .)
    MAIN            reduce using rule 75 (function_decl -> VOID ID LPAREN create_function_scope param_list RPAREN LBRACE stmt_list end_scopes RBRACE .)


state 181

    (69) else_stmt -> ELSE LBRACE . else_part stmt_list RBRACE
    (71) else_part -> .

    ID              reduce using rule 71 (else_part -> .)
    PRINT           reduce using rule 71 (else_part -> .)
    IF              reduce using rule 71 (else_part -> .)
    WHILE           reduce using rule 71 (else_part -> .)
    TEACH_SUM       reduce using rule 71 (else_part -> .)
    TEACH_SUBSTRACTION reduce using rule 71 (else_part -> .)
    TEACH_MULTIPLICATION reduce using rule 71 (else_part -> .)
    TEACH_DIVISION  reduce using rule 71 (else_part -> .)
    TEACH_IF        reduce using rule 71 (else_part -> .)
    TEACH_WHILE     reduce using rule 71 (else_part -> .)
    TEACH_FUNCTION_DECLARATION reduce using rule 71 (else_part -> .)
    TEACH_FUNCTION_CALL reduce using rule 71 (else_part -> .)
    AYUDA           reduce using rule 71 (else_part -> .)
    RETURN          reduce using rule 71 (else_part -> .)
    INT             reduce using rule 71 (else_part -> .)
    FLOAT           reduce using rule 71 (else_part -> .)
    STRING          reduce using rule 71 (else_part -> .)
    BOOL            reduce using rule 71 (else_part -> .)
    SEMICOLON       reduce using rule 71 (else_part -> .)

    else_part                      shift and go to state 182

state 182

    (69) else_stmt -> ELSE LBRACE else_part . stmt_list RBRACE
    (21) stmt_list -> . stmt SEMICOLON stmt_list
    (22) stmt_list -> . stmt SEMICOLON
    (23) stmt -> . assign
    (24) stmt -> . array_assign
    (25) stmt -> . print
    (26) stmt -> . conditional
    (27) stmt -> . loop
    (28) stmt -> . function_call
    (29) stmt -> . decl
    (30) stmt -> . built_in_function
    (31) stmt -> . return_stmt
    (41) assign -> . ID EQUALS expr
    (86) array_assign -> . ID EQUALS LBRACE CTEI_list RBRACE
    (59) print -> . PRINT COLON expr
    (60) conditional -> . IF LPAREN comp_expr RPAREN LBRACE stmt_list RBRACE else_stmt
    (61) conditional -> . IF LPAREN comp_expr RPAREN LBRACE stmt_list RBRACE
    (72) loop -> . WHILE LPAREN comp_expr RPAREN LBRACE stmt_list RBRACE
    (78) function_call -> . ID LPAREN arg_list RPAREN
    (15) decl -> . type ID
    (16) decl -> . array_decl
    (32) built_in_function -> . TEACH_SUM LPAREN RPAREN
    (33) built_in_function -> . TEACH_SUBSTRACTION LPAREN RPAREN
    (34) built_in_function -> . TEACH_MULTIPLICATION LPAREN RPAREN
    (35) built_in_function -> . TEACH_DIVISION LPAREN RPAREN
    (36) built_in_function -> . TEACH_IF LPAREN RPAREN
    (37) built_in_function -> . TEACH_WHILE LPAREN RPAREN
    (38) built_in_function -> . TEACH_FUNCTION_DECLARATION LPAREN RPAREN
    (39) built_in_function -> . TEACH_FUNCTION_CALL LPAREN RPAREN
    (40) built_in_function -> . AYUDA LPAREN RPAREN
    (76) return_stmt -> . RETURN expr
    (77) return_stmt -> . empty
    (17) type -> . INT
    (18) type -> . FLOAT
    (19) type -> . STRING
    (20) type -> . BOOL
    (85) array_decl -> . type ID LBRACKET CTEI RBRACKET
    (90) empty -> .

    ID              shift and go to state 52
    PRINT           shift and go to state 53
    IF              shift and go to state 54
    WHILE           shift and go to state 55
    TEACH_SUM       shift and go to state 56
    TEACH_SUBSTRACTION shift and go to state 57
    TEACH_MULTIPLICATION shift and go to state 58
    TEACH_DIVISION  shift and go to state 59
    TEACH_IF        shift and go to state 60
    TEACH_WHILE     shift and go to state 61
    TEACH_FUNCTION_DECLARATION shift and go to state 62
    TEACH_FUNCTION_CALL shift and go to state 63
    AYUDA           shift and go to state 64
    RETURN          shift and go to state 65
    INT             shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 21
    BOOL            shift and go to state 22
    SEMICOLON       reduce using rule 90 (empty -> .)

    stmt_list                      shift and go to state 183
    stmt                           shift and go to state 42
    assign                         shift and go to state 43
    array_assign                   shift and go to state 44
    print                          shift and go to state 45
    conditional                    shift and go to state 46
    loop                           shift and go to state 47
    function_call                  shift and go to state 48
    decl                           shift and go to state 49
    built_in_function              shift and go to state 50
    return_stmt                    shift and go to state 51
    type                           shift and go to state 17
    array_decl                     shift and go to state 18
    empty                          shift and go to state 66

state 183

    (69) else_stmt -> ELSE LBRACE else_part stmt_list . RBRACE

    RBRACE          shift and go to state 184


state 184

    (69) else_stmt -> ELSE LBRACE else_part stmt_list RBRACE .

    SEMICOLON       reduce using rule 69 (else_stmt -> ELSE LBRACE else_part stmt_list RBRACE .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: reduce/reduce conflict in state 25 resolved using rule (global_scope -> VARIABLES LBRACE decl_list RBRACE)
WARNING: rejected rule (empty -> <empty>) in state 25
WARNING: reduce/reduce conflict in state 26 resolved using rule (decl_list -> decl SEMICOLON)
WARNING: rejected rule (empty -> <empty>) in state 26
WARNING: reduce/reduce conflict in state 89 resolved using rule (term -> function_call)
WARNING: rejected rule (factor -> function_call) in state 89
WARNING: reduce/reduce conflict in state 161 resolved using rule (expr -> expr comp_op term)
WARNING: rejected rule (expr -> term) in state 161
WARNING: reduce/reduce conflict in state 172 resolved using rule (conditional -> IF LPAREN comp_expr RPAREN LBRACE stmt_list RBRACE)
WARNING: rejected rule (empty -> <empty>) in state 172
