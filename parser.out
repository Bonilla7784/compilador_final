Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> program
Rule 1     program -> PROGRAM ID SEMICOLON placeholder_goto_main create_scopes global_scope main_function end_scopes fill_goto_main
Rule 2     placeholder_goto_main -> <empty>
Rule 3     global_scope -> VARIABLES LBRACE decl_list RBRACE function_decl_list
Rule 4     global_scope -> VARIABLES LBRACE decl_list RBRACE
Rule 5     function_decl_list -> function_decl function_decl_list
Rule 6     function_decl_list -> empty
Rule 7     main_function -> MAIN LPAREN RPAREN LBRACE start_main stmt_list RBRACE
Rule 8     start_main -> <empty>
Rule 9     fill_goto_main -> <empty>
Rule 10    create_scopes -> <empty>
Rule 11    end_scopes -> <empty>
Rule 12    decl_list -> decl SEMICOLON decl_list
Rule 13    decl_list -> decl SEMICOLON
Rule 14    decl_list -> empty
Rule 15    decl -> type ID
Rule 16    decl -> array_decl
Rule 17    type -> INT
Rule 18    type -> FLOAT
Rule 19    type -> STRING
Rule 20    type -> BOOL
Rule 21    stmt_list -> stmt SEMICOLON stmt_list
Rule 22    stmt_list -> stmt SEMICOLON
Rule 23    stmt -> assign
Rule 24    stmt -> print
Rule 25    stmt -> conditional
Rule 26    stmt -> loop
Rule 27    stmt -> function_call
Rule 28    stmt -> decl
Rule 29    stmt -> built_in_function
Rule 30    stmt -> return_stmt
Rule 31    built_in_function -> TEACH_SUM LPAREN RPAREN
Rule 32    built_in_function -> TEACH_SUBSTRACTION LPAREN RPAREN
Rule 33    built_in_function -> TEACH_MULTIPLICATION LPAREN RPAREN
Rule 34    built_in_function -> TEACH_DIVISION LPAREN RPAREN
Rule 35    built_in_function -> TEACH_IF LPAREN RPAREN
Rule 36    built_in_function -> TEACH_WHILE LPAREN RPAREN
Rule 37    built_in_function -> TEACH_FUNCTION_DECLARATION LPAREN RPAREN
Rule 38    built_in_function -> TEACH_FUNCTION_CALL LPAREN RPAREN
Rule 39    built_in_function -> AYUDA LPAREN RPAREN
Rule 40    assign -> ID EQUALS expr
Rule 41    expr -> expr PLUS term
Rule 42    expr -> expr MINUS term
Rule 43    expr -> expr comp_op term
Rule 44    expr -> term
Rule 45    term -> term MULTIPLY factor
Rule 46    term -> term DIVIDE factor
Rule 47    term -> factor
Rule 48    term -> function_call
Rule 49    factor -> LPAREN expr RPAREN
Rule 50    factor -> CTEI
Rule 51    factor -> FLOAT_NUMBER
Rule 52    factor -> STRING_LITERAL
Rule 53    factor -> TRUE
Rule 54    factor -> FALSE
Rule 55    factor -> ID
Rule 56    factor -> function_call
Rule 57    print -> PRINT COLON expr
Rule 58    conditional -> IF LPAREN comp_expr RPAREN LBRACE stmt_list RBRACE else_stmt
Rule 59    conditional -> IF LPAREN comp_expr RPAREN LBRACE stmt_list RBRACE
Rule 60    comp_expr -> expr comp_op expr
Rule 61    comp_op -> LESS_THAN
Rule 62    comp_op -> GREATER_THAN
Rule 63    comp_op -> LESS_EQUAL
Rule 64    comp_op -> GREATER_EQUAL
Rule 65    comp_op -> EQUAL_EQUAL
Rule 66    comp_op -> NOT_EQUAL
Rule 67    else_stmt -> ELSE LBRACE else_part stmt_list RBRACE
Rule 68    else_stmt -> empty
Rule 69    else_part -> <empty>
Rule 70    loop -> WHILE LPAREN comp_expr RPAREN LBRACE stmt_list RBRACE
Rule 71    create_function_scope -> <empty>
Rule 72    function_decl -> type ID LPAREN create_function_scope param_list RPAREN LBRACE stmt_list end_scopes RBRACE
Rule 73    function_decl -> VOID ID LPAREN create_function_scope param_list RPAREN LBRACE stmt_list end_scopes RBRACE
Rule 74    return_stmt -> RETURN expr
Rule 75    return_stmt -> empty
Rule 76    function_call -> ID LPAREN arg_list RPAREN
Rule 77    arg_list -> arg_list COMMA expr
Rule 78    arg_list -> expr
Rule 79    param_list -> param COMMA param_list
Rule 80    param_list -> param
Rule 81    param_list -> empty
Rule 82    param -> type ID
Rule 83    array_decl -> type ID LBRACKET CTEI RBRACKET
Rule 84    empty -> <empty>

Terminals, with rules where they appear

AYUDA                : 39
BOOL                 : 20
COLON                : 57
COMMA                : 77 79
CTEI                 : 50 83
DIVIDE               : 46
ELSE                 : 67
EQUALS               : 40
EQUAL_EQUAL          : 65
FALSE                : 54
FLOAT                : 18
FLOAT_NUMBER         : 51
GREATER_EQUAL        : 64
GREATER_THAN         : 62
ID                   : 1 15 40 55 72 73 76 82 83
IF                   : 58 59
INT                  : 17
LBRACE               : 3 4 7 58 59 67 70 72 73
LBRACKET             : 83
LESS_EQUAL           : 63
LESS_THAN            : 61
LPAREN               : 7 31 32 33 34 35 36 37 38 39 49 58 59 70 72 73 76
MAIN                 : 7
MINUS                : 42
MULTIPLY             : 45
NOT_EQUAL            : 66
PLUS                 : 41
PRINT                : 57
PROGRAM              : 1
RBRACE               : 3 4 7 58 59 67 70 72 73
RBRACKET             : 83
RETURN               : 74
RPAREN               : 7 31 32 33 34 35 36 37 38 39 49 58 59 70 72 73 76
SEMICOLON            : 1 12 13 21 22
STRING               : 19
STRING_LITERAL       : 52
TEACH_DIVISION       : 34
TEACH_FUNCTION_CALL  : 38
TEACH_FUNCTION_DECLARATION : 37
TEACH_IF             : 35
TEACH_MULTIPLICATION : 33
TEACH_SUBSTRACTION   : 32
TEACH_SUM            : 31
TEACH_WHILE          : 36
TRUE                 : 53
VARIABLES            : 3 4
VOID                 : 73
WHILE                : 70
error                : 

Nonterminals, with rules where they appear

arg_list             : 76 77
array_decl           : 16
assign               : 23
built_in_function    : 29
comp_expr            : 58 59 70
comp_op              : 43 60
conditional          : 25
create_function_scope : 72 73
create_scopes        : 1
decl                 : 12 13 28
decl_list            : 3 4 12
else_part            : 67
else_stmt            : 58
empty                : 6 14 68 75 81
end_scopes           : 1 72 73
expr                 : 40 41 42 43 49 57 60 60 74 77 78
factor               : 45 46 47
fill_goto_main       : 1
function_call        : 27 48 56
function_decl        : 5
function_decl_list   : 3 5
global_scope         : 1
loop                 : 26
main_function        : 1
param                : 79 80
param_list           : 72 73 79
placeholder_goto_main : 1
print                : 24
program              : 0
return_stmt          : 30
start_main           : 7
stmt                 : 21 22
stmt_list            : 7 21 58 59 67 70 72 73
term                 : 41 42 43 44 45 46
type                 : 15 72 82 83

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . PROGRAM ID SEMICOLON placeholder_goto_main create_scopes global_scope main_function end_scopes fill_goto_main

    PROGRAM         shift and go to state 2

    program                        shift and go to state 1

state 1

    (0) S' -> program .



state 2

    (1) program -> PROGRAM . ID SEMICOLON placeholder_goto_main create_scopes global_scope main_function end_scopes fill_goto_main

    ID              shift and go to state 3


state 3

    (1) program -> PROGRAM ID . SEMICOLON placeholder_goto_main create_scopes global_scope main_function end_scopes fill_goto_main

    SEMICOLON       shift and go to state 4


state 4

    (1) program -> PROGRAM ID SEMICOLON . placeholder_goto_main create_scopes global_scope main_function end_scopes fill_goto_main
    (2) placeholder_goto_main -> .

    VARIABLES       reduce using rule 2 (placeholder_goto_main -> .)

    placeholder_goto_main          shift and go to state 5

state 5

    (1) program -> PROGRAM ID SEMICOLON placeholder_goto_main . create_scopes global_scope main_function end_scopes fill_goto_main
    (10) create_scopes -> .

    VARIABLES       reduce using rule 10 (create_scopes -> .)

    create_scopes                  shift and go to state 6

state 6

    (1) program -> PROGRAM ID SEMICOLON placeholder_goto_main create_scopes . global_scope main_function end_scopes fill_goto_main
    (3) global_scope -> . VARIABLES LBRACE decl_list RBRACE function_decl_list
    (4) global_scope -> . VARIABLES LBRACE decl_list RBRACE

    VARIABLES       shift and go to state 8

    global_scope                   shift and go to state 7

state 7

    (1) program -> PROGRAM ID SEMICOLON placeholder_goto_main create_scopes global_scope . main_function end_scopes fill_goto_main
    (7) main_function -> . MAIN LPAREN RPAREN LBRACE start_main stmt_list RBRACE

    MAIN            shift and go to state 10

    main_function                  shift and go to state 9

state 8

    (3) global_scope -> VARIABLES . LBRACE decl_list RBRACE function_decl_list
    (4) global_scope -> VARIABLES . LBRACE decl_list RBRACE

    LBRACE          shift and go to state 11


state 9

    (1) program -> PROGRAM ID SEMICOLON placeholder_goto_main create_scopes global_scope main_function . end_scopes fill_goto_main
    (11) end_scopes -> .

    $end            reduce using rule 11 (end_scopes -> .)

    end_scopes                     shift and go to state 12

state 10

    (7) main_function -> MAIN . LPAREN RPAREN LBRACE start_main stmt_list RBRACE

    LPAREN          shift and go to state 13


state 11

    (3) global_scope -> VARIABLES LBRACE . decl_list RBRACE function_decl_list
    (4) global_scope -> VARIABLES LBRACE . decl_list RBRACE
    (12) decl_list -> . decl SEMICOLON decl_list
    (13) decl_list -> . decl SEMICOLON
    (14) decl_list -> . empty
    (15) decl -> . type ID
    (16) decl -> . array_decl
    (84) empty -> .
    (17) type -> . INT
    (18) type -> . FLOAT
    (19) type -> . STRING
    (20) type -> . BOOL
    (83) array_decl -> . type ID LBRACKET CTEI RBRACKET

    RBRACE          reduce using rule 84 (empty -> .)
    INT             shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 21
    BOOL            shift and go to state 22

    decl_list                      shift and go to state 14
    decl                           shift and go to state 15
    empty                          shift and go to state 16
    type                           shift and go to state 17
    array_decl                     shift and go to state 18

state 12

    (1) program -> PROGRAM ID SEMICOLON placeholder_goto_main create_scopes global_scope main_function end_scopes . fill_goto_main
    (9) fill_goto_main -> .

    $end            reduce using rule 9 (fill_goto_main -> .)

    fill_goto_main                 shift and go to state 23

state 13

    (7) main_function -> MAIN LPAREN . RPAREN LBRACE start_main stmt_list RBRACE

    RPAREN          shift and go to state 24


state 14

    (3) global_scope -> VARIABLES LBRACE decl_list . RBRACE function_decl_list
    (4) global_scope -> VARIABLES LBRACE decl_list . RBRACE

    RBRACE          shift and go to state 25


state 15

    (12) decl_list -> decl . SEMICOLON decl_list
    (13) decl_list -> decl . SEMICOLON

    SEMICOLON       shift and go to state 26


state 16

    (14) decl_list -> empty .

    RBRACE          reduce using rule 14 (decl_list -> empty .)


state 17

    (15) decl -> type . ID
    (83) array_decl -> type . ID LBRACKET CTEI RBRACKET

    ID              shift and go to state 27


state 18

    (16) decl -> array_decl .

    SEMICOLON       reduce using rule 16 (decl -> array_decl .)


state 19

    (17) type -> INT .

    ID              reduce using rule 17 (type -> INT .)


state 20

    (18) type -> FLOAT .

    ID              reduce using rule 18 (type -> FLOAT .)


state 21

    (19) type -> STRING .

    ID              reduce using rule 19 (type -> STRING .)


state 22

    (20) type -> BOOL .

    ID              reduce using rule 20 (type -> BOOL .)


state 23

    (1) program -> PROGRAM ID SEMICOLON placeholder_goto_main create_scopes global_scope main_function end_scopes fill_goto_main .

    $end            reduce using rule 1 (program -> PROGRAM ID SEMICOLON placeholder_goto_main create_scopes global_scope main_function end_scopes fill_goto_main .)


state 24

    (7) main_function -> MAIN LPAREN RPAREN . LBRACE start_main stmt_list RBRACE

    LBRACE          shift and go to state 28


state 25

    (3) global_scope -> VARIABLES LBRACE decl_list RBRACE . function_decl_list
    (4) global_scope -> VARIABLES LBRACE decl_list RBRACE .
    (5) function_decl_list -> . function_decl function_decl_list
    (6) function_decl_list -> . empty
    (72) function_decl -> . type ID LPAREN create_function_scope param_list RPAREN LBRACE stmt_list end_scopes RBRACE
    (73) function_decl -> . VOID ID LPAREN create_function_scope param_list RPAREN LBRACE stmt_list end_scopes RBRACE
    (84) empty -> .
    (17) type -> . INT
    (18) type -> . FLOAT
    (19) type -> . STRING
    (20) type -> . BOOL

  ! reduce/reduce conflict for MAIN resolved using rule 4 (global_scope -> VARIABLES LBRACE decl_list RBRACE .)
    MAIN            reduce using rule 4 (global_scope -> VARIABLES LBRACE decl_list RBRACE .)
    VOID            shift and go to state 33
    INT             shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 21
    BOOL            shift and go to state 22

  ! MAIN            [ reduce using rule 84 (empty -> .) ]

    function_decl_list             shift and go to state 29
    function_decl                  shift and go to state 30
    empty                          shift and go to state 31
    type                           shift and go to state 32

state 26

    (12) decl_list -> decl SEMICOLON . decl_list
    (13) decl_list -> decl SEMICOLON .
    (12) decl_list -> . decl SEMICOLON decl_list
    (13) decl_list -> . decl SEMICOLON
    (14) decl_list -> . empty
    (15) decl -> . type ID
    (16) decl -> . array_decl
    (84) empty -> .
    (17) type -> . INT
    (18) type -> . FLOAT
    (19) type -> . STRING
    (20) type -> . BOOL
    (83) array_decl -> . type ID LBRACKET CTEI RBRACKET

  ! reduce/reduce conflict for RBRACE resolved using rule 13 (decl_list -> decl SEMICOLON .)
    RBRACE          reduce using rule 13 (decl_list -> decl SEMICOLON .)
    INT             shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 21
    BOOL            shift and go to state 22

  ! RBRACE          [ reduce using rule 84 (empty -> .) ]

    decl                           shift and go to state 15
    decl_list                      shift and go to state 34
    empty                          shift and go to state 16
    type                           shift and go to state 17
    array_decl                     shift and go to state 18

state 27

    (15) decl -> type ID .
    (83) array_decl -> type ID . LBRACKET CTEI RBRACKET

    SEMICOLON       reduce using rule 15 (decl -> type ID .)
    LBRACKET        shift and go to state 35


state 28

    (7) main_function -> MAIN LPAREN RPAREN LBRACE . start_main stmt_list RBRACE
    (8) start_main -> .

    ID              reduce using rule 8 (start_main -> .)
    PRINT           reduce using rule 8 (start_main -> .)
    IF              reduce using rule 8 (start_main -> .)
    WHILE           reduce using rule 8 (start_main -> .)
    TEACH_SUM       reduce using rule 8 (start_main -> .)
    TEACH_SUBSTRACTION reduce using rule 8 (start_main -> .)
    TEACH_MULTIPLICATION reduce using rule 8 (start_main -> .)
    TEACH_DIVISION  reduce using rule 8 (start_main -> .)
    TEACH_IF        reduce using rule 8 (start_main -> .)
    TEACH_WHILE     reduce using rule 8 (start_main -> .)
    TEACH_FUNCTION_DECLARATION reduce using rule 8 (start_main -> .)
    TEACH_FUNCTION_CALL reduce using rule 8 (start_main -> .)
    AYUDA           reduce using rule 8 (start_main -> .)
    RETURN          reduce using rule 8 (start_main -> .)
    INT             reduce using rule 8 (start_main -> .)
    FLOAT           reduce using rule 8 (start_main -> .)
    STRING          reduce using rule 8 (start_main -> .)
    BOOL            reduce using rule 8 (start_main -> .)
    SEMICOLON       reduce using rule 8 (start_main -> .)

    start_main                     shift and go to state 36

state 29

    (3) global_scope -> VARIABLES LBRACE decl_list RBRACE function_decl_list .

    MAIN            reduce using rule 3 (global_scope -> VARIABLES LBRACE decl_list RBRACE function_decl_list .)


state 30

    (5) function_decl_list -> function_decl . function_decl_list
    (5) function_decl_list -> . function_decl function_decl_list
    (6) function_decl_list -> . empty
    (72) function_decl -> . type ID LPAREN create_function_scope param_list RPAREN LBRACE stmt_list end_scopes RBRACE
    (73) function_decl -> . VOID ID LPAREN create_function_scope param_list RPAREN LBRACE stmt_list end_scopes RBRACE
    (84) empty -> .
    (17) type -> . INT
    (18) type -> . FLOAT
    (19) type -> . STRING
    (20) type -> . BOOL

    VOID            shift and go to state 33
    MAIN            reduce using rule 84 (empty -> .)
    INT             shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 21
    BOOL            shift and go to state 22

    function_decl                  shift and go to state 30
    function_decl_list             shift and go to state 37
    empty                          shift and go to state 31
    type                           shift and go to state 32

state 31

    (6) function_decl_list -> empty .

    MAIN            reduce using rule 6 (function_decl_list -> empty .)


state 32

    (72) function_decl -> type . ID LPAREN create_function_scope param_list RPAREN LBRACE stmt_list end_scopes RBRACE

    ID              shift and go to state 38


state 33

    (73) function_decl -> VOID . ID LPAREN create_function_scope param_list RPAREN LBRACE stmt_list end_scopes RBRACE

    ID              shift and go to state 39


state 34

    (12) decl_list -> decl SEMICOLON decl_list .

    RBRACE          reduce using rule 12 (decl_list -> decl SEMICOLON decl_list .)


state 35

    (83) array_decl -> type ID LBRACKET . CTEI RBRACKET

    CTEI            shift and go to state 40


state 36

    (7) main_function -> MAIN LPAREN RPAREN LBRACE start_main . stmt_list RBRACE
    (21) stmt_list -> . stmt SEMICOLON stmt_list
    (22) stmt_list -> . stmt SEMICOLON
    (23) stmt -> . assign
    (24) stmt -> . print
    (25) stmt -> . conditional
    (26) stmt -> . loop
    (27) stmt -> . function_call
    (28) stmt -> . decl
    (29) stmt -> . built_in_function
    (30) stmt -> . return_stmt
    (40) assign -> . ID EQUALS expr
    (57) print -> . PRINT COLON expr
    (58) conditional -> . IF LPAREN comp_expr RPAREN LBRACE stmt_list RBRACE else_stmt
    (59) conditional -> . IF LPAREN comp_expr RPAREN LBRACE stmt_list RBRACE
    (70) loop -> . WHILE LPAREN comp_expr RPAREN LBRACE stmt_list RBRACE
    (76) function_call -> . ID LPAREN arg_list RPAREN
    (15) decl -> . type ID
    (16) decl -> . array_decl
    (31) built_in_function -> . TEACH_SUM LPAREN RPAREN
    (32) built_in_function -> . TEACH_SUBSTRACTION LPAREN RPAREN
    (33) built_in_function -> . TEACH_MULTIPLICATION LPAREN RPAREN
    (34) built_in_function -> . TEACH_DIVISION LPAREN RPAREN
    (35) built_in_function -> . TEACH_IF LPAREN RPAREN
    (36) built_in_function -> . TEACH_WHILE LPAREN RPAREN
    (37) built_in_function -> . TEACH_FUNCTION_DECLARATION LPAREN RPAREN
    (38) built_in_function -> . TEACH_FUNCTION_CALL LPAREN RPAREN
    (39) built_in_function -> . AYUDA LPAREN RPAREN
    (74) return_stmt -> . RETURN expr
    (75) return_stmt -> . empty
    (17) type -> . INT
    (18) type -> . FLOAT
    (19) type -> . STRING
    (20) type -> . BOOL
    (83) array_decl -> . type ID LBRACKET CTEI RBRACKET
    (84) empty -> .

    ID              shift and go to state 51
    PRINT           shift and go to state 52
    IF              shift and go to state 53
    WHILE           shift and go to state 54
    TEACH_SUM       shift and go to state 55
    TEACH_SUBSTRACTION shift and go to state 56
    TEACH_MULTIPLICATION shift and go to state 57
    TEACH_DIVISION  shift and go to state 58
    TEACH_IF        shift and go to state 59
    TEACH_WHILE     shift and go to state 60
    TEACH_FUNCTION_DECLARATION shift and go to state 61
    TEACH_FUNCTION_CALL shift and go to state 62
    AYUDA           shift and go to state 63
    RETURN          shift and go to state 64
    INT             shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 21
    BOOL            shift and go to state 22
    SEMICOLON       reduce using rule 84 (empty -> .)

    stmt_list                      shift and go to state 41
    stmt                           shift and go to state 42
    assign                         shift and go to state 43
    print                          shift and go to state 44
    conditional                    shift and go to state 45
    loop                           shift and go to state 46
    function_call                  shift and go to state 47
    decl                           shift and go to state 48
    built_in_function              shift and go to state 49
    return_stmt                    shift and go to state 50
    type                           shift and go to state 17
    array_decl                     shift and go to state 18
    empty                          shift and go to state 65

state 37

    (5) function_decl_list -> function_decl function_decl_list .

    MAIN            reduce using rule 5 (function_decl_list -> function_decl function_decl_list .)


state 38

    (72) function_decl -> type ID . LPAREN create_function_scope param_list RPAREN LBRACE stmt_list end_scopes RBRACE

    LPAREN          shift and go to state 66


state 39

    (73) function_decl -> VOID ID . LPAREN create_function_scope param_list RPAREN LBRACE stmt_list end_scopes RBRACE

    LPAREN          shift and go to state 67


state 40

    (83) array_decl -> type ID LBRACKET CTEI . RBRACKET

    RBRACKET        shift and go to state 68


state 41

    (7) main_function -> MAIN LPAREN RPAREN LBRACE start_main stmt_list . RBRACE

    RBRACE          shift and go to state 69


state 42

    (21) stmt_list -> stmt . SEMICOLON stmt_list
    (22) stmt_list -> stmt . SEMICOLON

    SEMICOLON       shift and go to state 70


state 43

    (23) stmt -> assign .

    SEMICOLON       reduce using rule 23 (stmt -> assign .)


state 44

    (24) stmt -> print .

    SEMICOLON       reduce using rule 24 (stmt -> print .)


state 45

    (25) stmt -> conditional .

    SEMICOLON       reduce using rule 25 (stmt -> conditional .)


state 46

    (26) stmt -> loop .

    SEMICOLON       reduce using rule 26 (stmt -> loop .)


state 47

    (27) stmt -> function_call .

    SEMICOLON       reduce using rule 27 (stmt -> function_call .)


state 48

    (28) stmt -> decl .

    SEMICOLON       reduce using rule 28 (stmt -> decl .)


state 49

    (29) stmt -> built_in_function .

    SEMICOLON       reduce using rule 29 (stmt -> built_in_function .)


state 50

    (30) stmt -> return_stmt .

    SEMICOLON       reduce using rule 30 (stmt -> return_stmt .)


state 51

    (40) assign -> ID . EQUALS expr
    (76) function_call -> ID . LPAREN arg_list RPAREN

    EQUALS          shift and go to state 71
    LPAREN          shift and go to state 72


state 52

    (57) print -> PRINT . COLON expr

    COLON           shift and go to state 73


state 53

    (58) conditional -> IF . LPAREN comp_expr RPAREN LBRACE stmt_list RBRACE else_stmt
    (59) conditional -> IF . LPAREN comp_expr RPAREN LBRACE stmt_list RBRACE

    LPAREN          shift and go to state 74


state 54

    (70) loop -> WHILE . LPAREN comp_expr RPAREN LBRACE stmt_list RBRACE

    LPAREN          shift and go to state 75


state 55

    (31) built_in_function -> TEACH_SUM . LPAREN RPAREN

    LPAREN          shift and go to state 76


state 56

    (32) built_in_function -> TEACH_SUBSTRACTION . LPAREN RPAREN

    LPAREN          shift and go to state 77


state 57

    (33) built_in_function -> TEACH_MULTIPLICATION . LPAREN RPAREN

    LPAREN          shift and go to state 78


state 58

    (34) built_in_function -> TEACH_DIVISION . LPAREN RPAREN

    LPAREN          shift and go to state 79


state 59

    (35) built_in_function -> TEACH_IF . LPAREN RPAREN

    LPAREN          shift and go to state 80


state 60

    (36) built_in_function -> TEACH_WHILE . LPAREN RPAREN

    LPAREN          shift and go to state 81


state 61

    (37) built_in_function -> TEACH_FUNCTION_DECLARATION . LPAREN RPAREN

    LPAREN          shift and go to state 82


state 62

    (38) built_in_function -> TEACH_FUNCTION_CALL . LPAREN RPAREN

    LPAREN          shift and go to state 83


state 63

    (39) built_in_function -> AYUDA . LPAREN RPAREN

    LPAREN          shift and go to state 84


state 64

    (74) return_stmt -> RETURN . expr
    (41) expr -> . expr PLUS term
    (42) expr -> . expr MINUS term
    (43) expr -> . expr comp_op term
    (44) expr -> . term
    (45) term -> . term MULTIPLY factor
    (46) term -> . term DIVIDE factor
    (47) term -> . factor
    (48) term -> . function_call
    (49) factor -> . LPAREN expr RPAREN
    (50) factor -> . CTEI
    (51) factor -> . FLOAT_NUMBER
    (52) factor -> . STRING_LITERAL
    (53) factor -> . TRUE
    (54) factor -> . FALSE
    (55) factor -> . ID
    (56) factor -> . function_call
    (76) function_call -> . ID LPAREN arg_list RPAREN

    LPAREN          shift and go to state 89
    CTEI            shift and go to state 90
    FLOAT_NUMBER    shift and go to state 91
    STRING_LITERAL  shift and go to state 92
    TRUE            shift and go to state 93
    FALSE           shift and go to state 94
    ID              shift and go to state 95

    expr                           shift and go to state 85
    term                           shift and go to state 86
    factor                         shift and go to state 87
    function_call                  shift and go to state 88

state 65

    (75) return_stmt -> empty .

    SEMICOLON       reduce using rule 75 (return_stmt -> empty .)


state 66

    (72) function_decl -> type ID LPAREN . create_function_scope param_list RPAREN LBRACE stmt_list end_scopes RBRACE
    (71) create_function_scope -> .

    INT             reduce using rule 71 (create_function_scope -> .)
    FLOAT           reduce using rule 71 (create_function_scope -> .)
    STRING          reduce using rule 71 (create_function_scope -> .)
    BOOL            reduce using rule 71 (create_function_scope -> .)
    RPAREN          reduce using rule 71 (create_function_scope -> .)

    create_function_scope          shift and go to state 96

state 67

    (73) function_decl -> VOID ID LPAREN . create_function_scope param_list RPAREN LBRACE stmt_list end_scopes RBRACE
    (71) create_function_scope -> .

    INT             reduce using rule 71 (create_function_scope -> .)
    FLOAT           reduce using rule 71 (create_function_scope -> .)
    STRING          reduce using rule 71 (create_function_scope -> .)
    BOOL            reduce using rule 71 (create_function_scope -> .)
    RPAREN          reduce using rule 71 (create_function_scope -> .)

    create_function_scope          shift and go to state 97

state 68

    (83) array_decl -> type ID LBRACKET CTEI RBRACKET .

    SEMICOLON       reduce using rule 83 (array_decl -> type ID LBRACKET CTEI RBRACKET .)


state 69

    (7) main_function -> MAIN LPAREN RPAREN LBRACE start_main stmt_list RBRACE .

    $end            reduce using rule 7 (main_function -> MAIN LPAREN RPAREN LBRACE start_main stmt_list RBRACE .)


state 70

    (21) stmt_list -> stmt SEMICOLON . stmt_list
    (22) stmt_list -> stmt SEMICOLON .
    (21) stmt_list -> . stmt SEMICOLON stmt_list
    (22) stmt_list -> . stmt SEMICOLON
    (23) stmt -> . assign
    (24) stmt -> . print
    (25) stmt -> . conditional
    (26) stmt -> . loop
    (27) stmt -> . function_call
    (28) stmt -> . decl
    (29) stmt -> . built_in_function
    (30) stmt -> . return_stmt
    (40) assign -> . ID EQUALS expr
    (57) print -> . PRINT COLON expr
    (58) conditional -> . IF LPAREN comp_expr RPAREN LBRACE stmt_list RBRACE else_stmt
    (59) conditional -> . IF LPAREN comp_expr RPAREN LBRACE stmt_list RBRACE
    (70) loop -> . WHILE LPAREN comp_expr RPAREN LBRACE stmt_list RBRACE
    (76) function_call -> . ID LPAREN arg_list RPAREN
    (15) decl -> . type ID
    (16) decl -> . array_decl
    (31) built_in_function -> . TEACH_SUM LPAREN RPAREN
    (32) built_in_function -> . TEACH_SUBSTRACTION LPAREN RPAREN
    (33) built_in_function -> . TEACH_MULTIPLICATION LPAREN RPAREN
    (34) built_in_function -> . TEACH_DIVISION LPAREN RPAREN
    (35) built_in_function -> . TEACH_IF LPAREN RPAREN
    (36) built_in_function -> . TEACH_WHILE LPAREN RPAREN
    (37) built_in_function -> . TEACH_FUNCTION_DECLARATION LPAREN RPAREN
    (38) built_in_function -> . TEACH_FUNCTION_CALL LPAREN RPAREN
    (39) built_in_function -> . AYUDA LPAREN RPAREN
    (74) return_stmt -> . RETURN expr
    (75) return_stmt -> . empty
    (17) type -> . INT
    (18) type -> . FLOAT
    (19) type -> . STRING
    (20) type -> . BOOL
    (83) array_decl -> . type ID LBRACKET CTEI RBRACKET
    (84) empty -> .

    RBRACE          reduce using rule 22 (stmt_list -> stmt SEMICOLON .)
    ID              shift and go to state 51
    PRINT           shift and go to state 52
    IF              shift and go to state 53
    WHILE           shift and go to state 54
    TEACH_SUM       shift and go to state 55
    TEACH_SUBSTRACTION shift and go to state 56
    TEACH_MULTIPLICATION shift and go to state 57
    TEACH_DIVISION  shift and go to state 58
    TEACH_IF        shift and go to state 59
    TEACH_WHILE     shift and go to state 60
    TEACH_FUNCTION_DECLARATION shift and go to state 61
    TEACH_FUNCTION_CALL shift and go to state 62
    AYUDA           shift and go to state 63
    RETURN          shift and go to state 64
    INT             shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 21
    BOOL            shift and go to state 22
    SEMICOLON       reduce using rule 84 (empty -> .)

    stmt                           shift and go to state 42
    stmt_list                      shift and go to state 98
    assign                         shift and go to state 43
    print                          shift and go to state 44
    conditional                    shift and go to state 45
    loop                           shift and go to state 46
    function_call                  shift and go to state 47
    decl                           shift and go to state 48
    built_in_function              shift and go to state 49
    return_stmt                    shift and go to state 50
    type                           shift and go to state 17
    array_decl                     shift and go to state 18
    empty                          shift and go to state 65

state 71

    (40) assign -> ID EQUALS . expr
    (41) expr -> . expr PLUS term
    (42) expr -> . expr MINUS term
    (43) expr -> . expr comp_op term
    (44) expr -> . term
    (45) term -> . term MULTIPLY factor
    (46) term -> . term DIVIDE factor
    (47) term -> . factor
    (48) term -> . function_call
    (49) factor -> . LPAREN expr RPAREN
    (50) factor -> . CTEI
    (51) factor -> . FLOAT_NUMBER
    (52) factor -> . STRING_LITERAL
    (53) factor -> . TRUE
    (54) factor -> . FALSE
    (55) factor -> . ID
    (56) factor -> . function_call
    (76) function_call -> . ID LPAREN arg_list RPAREN

    LPAREN          shift and go to state 89
    CTEI            shift and go to state 90
    FLOAT_NUMBER    shift and go to state 91
    STRING_LITERAL  shift and go to state 92
    TRUE            shift and go to state 93
    FALSE           shift and go to state 94
    ID              shift and go to state 95

    expr                           shift and go to state 99
    term                           shift and go to state 86
    factor                         shift and go to state 87
    function_call                  shift and go to state 88

state 72

    (76) function_call -> ID LPAREN . arg_list RPAREN
    (77) arg_list -> . arg_list COMMA expr
    (78) arg_list -> . expr
    (41) expr -> . expr PLUS term
    (42) expr -> . expr MINUS term
    (43) expr -> . expr comp_op term
    (44) expr -> . term
    (45) term -> . term MULTIPLY factor
    (46) term -> . term DIVIDE factor
    (47) term -> . factor
    (48) term -> . function_call
    (49) factor -> . LPAREN expr RPAREN
    (50) factor -> . CTEI
    (51) factor -> . FLOAT_NUMBER
    (52) factor -> . STRING_LITERAL
    (53) factor -> . TRUE
    (54) factor -> . FALSE
    (55) factor -> . ID
    (56) factor -> . function_call
    (76) function_call -> . ID LPAREN arg_list RPAREN

    LPAREN          shift and go to state 89
    CTEI            shift and go to state 90
    FLOAT_NUMBER    shift and go to state 91
    STRING_LITERAL  shift and go to state 92
    TRUE            shift and go to state 93
    FALSE           shift and go to state 94
    ID              shift and go to state 95

    arg_list                       shift and go to state 100
    expr                           shift and go to state 101
    term                           shift and go to state 86
    factor                         shift and go to state 87
    function_call                  shift and go to state 88

state 73

    (57) print -> PRINT COLON . expr
    (41) expr -> . expr PLUS term
    (42) expr -> . expr MINUS term
    (43) expr -> . expr comp_op term
    (44) expr -> . term
    (45) term -> . term MULTIPLY factor
    (46) term -> . term DIVIDE factor
    (47) term -> . factor
    (48) term -> . function_call
    (49) factor -> . LPAREN expr RPAREN
    (50) factor -> . CTEI
    (51) factor -> . FLOAT_NUMBER
    (52) factor -> . STRING_LITERAL
    (53) factor -> . TRUE
    (54) factor -> . FALSE
    (55) factor -> . ID
    (56) factor -> . function_call
    (76) function_call -> . ID LPAREN arg_list RPAREN

    LPAREN          shift and go to state 89
    CTEI            shift and go to state 90
    FLOAT_NUMBER    shift and go to state 91
    STRING_LITERAL  shift and go to state 92
    TRUE            shift and go to state 93
    FALSE           shift and go to state 94
    ID              shift and go to state 95

    expr                           shift and go to state 102
    term                           shift and go to state 86
    factor                         shift and go to state 87
    function_call                  shift and go to state 88

state 74

    (58) conditional -> IF LPAREN . comp_expr RPAREN LBRACE stmt_list RBRACE else_stmt
    (59) conditional -> IF LPAREN . comp_expr RPAREN LBRACE stmt_list RBRACE
    (60) comp_expr -> . expr comp_op expr
    (41) expr -> . expr PLUS term
    (42) expr -> . expr MINUS term
    (43) expr -> . expr comp_op term
    (44) expr -> . term
    (45) term -> . term MULTIPLY factor
    (46) term -> . term DIVIDE factor
    (47) term -> . factor
    (48) term -> . function_call
    (49) factor -> . LPAREN expr RPAREN
    (50) factor -> . CTEI
    (51) factor -> . FLOAT_NUMBER
    (52) factor -> . STRING_LITERAL
    (53) factor -> . TRUE
    (54) factor -> . FALSE
    (55) factor -> . ID
    (56) factor -> . function_call
    (76) function_call -> . ID LPAREN arg_list RPAREN

    LPAREN          shift and go to state 89
    CTEI            shift and go to state 90
    FLOAT_NUMBER    shift and go to state 91
    STRING_LITERAL  shift and go to state 92
    TRUE            shift and go to state 93
    FALSE           shift and go to state 94
    ID              shift and go to state 95

    comp_expr                      shift and go to state 103
    expr                           shift and go to state 104
    term                           shift and go to state 86
    factor                         shift and go to state 87
    function_call                  shift and go to state 88

state 75

    (70) loop -> WHILE LPAREN . comp_expr RPAREN LBRACE stmt_list RBRACE
    (60) comp_expr -> . expr comp_op expr
    (41) expr -> . expr PLUS term
    (42) expr -> . expr MINUS term
    (43) expr -> . expr comp_op term
    (44) expr -> . term
    (45) term -> . term MULTIPLY factor
    (46) term -> . term DIVIDE factor
    (47) term -> . factor
    (48) term -> . function_call
    (49) factor -> . LPAREN expr RPAREN
    (50) factor -> . CTEI
    (51) factor -> . FLOAT_NUMBER
    (52) factor -> . STRING_LITERAL
    (53) factor -> . TRUE
    (54) factor -> . FALSE
    (55) factor -> . ID
    (56) factor -> . function_call
    (76) function_call -> . ID LPAREN arg_list RPAREN

    LPAREN          shift and go to state 89
    CTEI            shift and go to state 90
    FLOAT_NUMBER    shift and go to state 91
    STRING_LITERAL  shift and go to state 92
    TRUE            shift and go to state 93
    FALSE           shift and go to state 94
    ID              shift and go to state 95

    comp_expr                      shift and go to state 105
    expr                           shift and go to state 104
    term                           shift and go to state 86
    factor                         shift and go to state 87
    function_call                  shift and go to state 88

state 76

    (31) built_in_function -> TEACH_SUM LPAREN . RPAREN

    RPAREN          shift and go to state 106


state 77

    (32) built_in_function -> TEACH_SUBSTRACTION LPAREN . RPAREN

    RPAREN          shift and go to state 107


state 78

    (33) built_in_function -> TEACH_MULTIPLICATION LPAREN . RPAREN

    RPAREN          shift and go to state 108


state 79

    (34) built_in_function -> TEACH_DIVISION LPAREN . RPAREN

    RPAREN          shift and go to state 109


state 80

    (35) built_in_function -> TEACH_IF LPAREN . RPAREN

    RPAREN          shift and go to state 110


state 81

    (36) built_in_function -> TEACH_WHILE LPAREN . RPAREN

    RPAREN          shift and go to state 111


state 82

    (37) built_in_function -> TEACH_FUNCTION_DECLARATION LPAREN . RPAREN

    RPAREN          shift and go to state 112


state 83

    (38) built_in_function -> TEACH_FUNCTION_CALL LPAREN . RPAREN

    RPAREN          shift and go to state 113


state 84

    (39) built_in_function -> AYUDA LPAREN . RPAREN

    RPAREN          shift and go to state 114


state 85

    (74) return_stmt -> RETURN expr .
    (41) expr -> expr . PLUS term
    (42) expr -> expr . MINUS term
    (43) expr -> expr . comp_op term
    (61) comp_op -> . LESS_THAN
    (62) comp_op -> . GREATER_THAN
    (63) comp_op -> . LESS_EQUAL
    (64) comp_op -> . GREATER_EQUAL
    (65) comp_op -> . EQUAL_EQUAL
    (66) comp_op -> . NOT_EQUAL

    SEMICOLON       reduce using rule 74 (return_stmt -> RETURN expr .)
    PLUS            shift and go to state 115
    MINUS           shift and go to state 116
    LESS_THAN       shift and go to state 118
    GREATER_THAN    shift and go to state 119
    LESS_EQUAL      shift and go to state 120
    GREATER_EQUAL   shift and go to state 121
    EQUAL_EQUAL     shift and go to state 122
    NOT_EQUAL       shift and go to state 123

    comp_op                        shift and go to state 117

state 86

    (44) expr -> term .
    (45) term -> term . MULTIPLY factor
    (46) term -> term . DIVIDE factor

    PLUS            reduce using rule 44 (expr -> term .)
    MINUS           reduce using rule 44 (expr -> term .)
    LESS_THAN       reduce using rule 44 (expr -> term .)
    GREATER_THAN    reduce using rule 44 (expr -> term .)
    LESS_EQUAL      reduce using rule 44 (expr -> term .)
    GREATER_EQUAL   reduce using rule 44 (expr -> term .)
    EQUAL_EQUAL     reduce using rule 44 (expr -> term .)
    NOT_EQUAL       reduce using rule 44 (expr -> term .)
    SEMICOLON       reduce using rule 44 (expr -> term .)
    RPAREN          reduce using rule 44 (expr -> term .)
    COMMA           reduce using rule 44 (expr -> term .)
    MULTIPLY        shift and go to state 124
    DIVIDE          shift and go to state 125


state 87

    (47) term -> factor .

    MULTIPLY        reduce using rule 47 (term -> factor .)
    DIVIDE          reduce using rule 47 (term -> factor .)
    PLUS            reduce using rule 47 (term -> factor .)
    MINUS           reduce using rule 47 (term -> factor .)
    LESS_THAN       reduce using rule 47 (term -> factor .)
    GREATER_THAN    reduce using rule 47 (term -> factor .)
    LESS_EQUAL      reduce using rule 47 (term -> factor .)
    GREATER_EQUAL   reduce using rule 47 (term -> factor .)
    EQUAL_EQUAL     reduce using rule 47 (term -> factor .)
    NOT_EQUAL       reduce using rule 47 (term -> factor .)
    SEMICOLON       reduce using rule 47 (term -> factor .)
    RPAREN          reduce using rule 47 (term -> factor .)
    COMMA           reduce using rule 47 (term -> factor .)


state 88

    (48) term -> function_call .
    (56) factor -> function_call .

  ! reduce/reduce conflict for MULTIPLY resolved using rule 48 (term -> function_call .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 48 (term -> function_call .)
  ! reduce/reduce conflict for PLUS resolved using rule 48 (term -> function_call .)
  ! reduce/reduce conflict for MINUS resolved using rule 48 (term -> function_call .)
  ! reduce/reduce conflict for LESS_THAN resolved using rule 48 (term -> function_call .)
  ! reduce/reduce conflict for GREATER_THAN resolved using rule 48 (term -> function_call .)
  ! reduce/reduce conflict for LESS_EQUAL resolved using rule 48 (term -> function_call .)
  ! reduce/reduce conflict for GREATER_EQUAL resolved using rule 48 (term -> function_call .)
  ! reduce/reduce conflict for EQUAL_EQUAL resolved using rule 48 (term -> function_call .)
  ! reduce/reduce conflict for NOT_EQUAL resolved using rule 48 (term -> function_call .)
  ! reduce/reduce conflict for SEMICOLON resolved using rule 48 (term -> function_call .)
  ! reduce/reduce conflict for RPAREN resolved using rule 48 (term -> function_call .)
  ! reduce/reduce conflict for COMMA resolved using rule 48 (term -> function_call .)
    MULTIPLY        reduce using rule 48 (term -> function_call .)
    DIVIDE          reduce using rule 48 (term -> function_call .)
    PLUS            reduce using rule 48 (term -> function_call .)
    MINUS           reduce using rule 48 (term -> function_call .)
    LESS_THAN       reduce using rule 48 (term -> function_call .)
    GREATER_THAN    reduce using rule 48 (term -> function_call .)
    LESS_EQUAL      reduce using rule 48 (term -> function_call .)
    GREATER_EQUAL   reduce using rule 48 (term -> function_call .)
    EQUAL_EQUAL     reduce using rule 48 (term -> function_call .)
    NOT_EQUAL       reduce using rule 48 (term -> function_call .)
    SEMICOLON       reduce using rule 48 (term -> function_call .)
    RPAREN          reduce using rule 48 (term -> function_call .)
    COMMA           reduce using rule 48 (term -> function_call .)

  ! MULTIPLY        [ reduce using rule 56 (factor -> function_call .) ]
  ! DIVIDE          [ reduce using rule 56 (factor -> function_call .) ]
  ! PLUS            [ reduce using rule 56 (factor -> function_call .) ]
  ! MINUS           [ reduce using rule 56 (factor -> function_call .) ]
  ! LESS_THAN       [ reduce using rule 56 (factor -> function_call .) ]
  ! GREATER_THAN    [ reduce using rule 56 (factor -> function_call .) ]
  ! LESS_EQUAL      [ reduce using rule 56 (factor -> function_call .) ]
  ! GREATER_EQUAL   [ reduce using rule 56 (factor -> function_call .) ]
  ! EQUAL_EQUAL     [ reduce using rule 56 (factor -> function_call .) ]
  ! NOT_EQUAL       [ reduce using rule 56 (factor -> function_call .) ]
  ! SEMICOLON       [ reduce using rule 56 (factor -> function_call .) ]
  ! RPAREN          [ reduce using rule 56 (factor -> function_call .) ]
  ! COMMA           [ reduce using rule 56 (factor -> function_call .) ]


state 89

    (49) factor -> LPAREN . expr RPAREN
    (41) expr -> . expr PLUS term
    (42) expr -> . expr MINUS term
    (43) expr -> . expr comp_op term
    (44) expr -> . term
    (45) term -> . term MULTIPLY factor
    (46) term -> . term DIVIDE factor
    (47) term -> . factor
    (48) term -> . function_call
    (49) factor -> . LPAREN expr RPAREN
    (50) factor -> . CTEI
    (51) factor -> . FLOAT_NUMBER
    (52) factor -> . STRING_LITERAL
    (53) factor -> . TRUE
    (54) factor -> . FALSE
    (55) factor -> . ID
    (56) factor -> . function_call
    (76) function_call -> . ID LPAREN arg_list RPAREN

    LPAREN          shift and go to state 89
    CTEI            shift and go to state 90
    FLOAT_NUMBER    shift and go to state 91
    STRING_LITERAL  shift and go to state 92
    TRUE            shift and go to state 93
    FALSE           shift and go to state 94
    ID              shift and go to state 95

    expr                           shift and go to state 126
    term                           shift and go to state 86
    factor                         shift and go to state 87
    function_call                  shift and go to state 88

state 90

    (50) factor -> CTEI .

    MULTIPLY        reduce using rule 50 (factor -> CTEI .)
    DIVIDE          reduce using rule 50 (factor -> CTEI .)
    PLUS            reduce using rule 50 (factor -> CTEI .)
    MINUS           reduce using rule 50 (factor -> CTEI .)
    LESS_THAN       reduce using rule 50 (factor -> CTEI .)
    GREATER_THAN    reduce using rule 50 (factor -> CTEI .)
    LESS_EQUAL      reduce using rule 50 (factor -> CTEI .)
    GREATER_EQUAL   reduce using rule 50 (factor -> CTEI .)
    EQUAL_EQUAL     reduce using rule 50 (factor -> CTEI .)
    NOT_EQUAL       reduce using rule 50 (factor -> CTEI .)
    SEMICOLON       reduce using rule 50 (factor -> CTEI .)
    RPAREN          reduce using rule 50 (factor -> CTEI .)
    COMMA           reduce using rule 50 (factor -> CTEI .)


state 91

    (51) factor -> FLOAT_NUMBER .

    MULTIPLY        reduce using rule 51 (factor -> FLOAT_NUMBER .)
    DIVIDE          reduce using rule 51 (factor -> FLOAT_NUMBER .)
    PLUS            reduce using rule 51 (factor -> FLOAT_NUMBER .)
    MINUS           reduce using rule 51 (factor -> FLOAT_NUMBER .)
    LESS_THAN       reduce using rule 51 (factor -> FLOAT_NUMBER .)
    GREATER_THAN    reduce using rule 51 (factor -> FLOAT_NUMBER .)
    LESS_EQUAL      reduce using rule 51 (factor -> FLOAT_NUMBER .)
    GREATER_EQUAL   reduce using rule 51 (factor -> FLOAT_NUMBER .)
    EQUAL_EQUAL     reduce using rule 51 (factor -> FLOAT_NUMBER .)
    NOT_EQUAL       reduce using rule 51 (factor -> FLOAT_NUMBER .)
    SEMICOLON       reduce using rule 51 (factor -> FLOAT_NUMBER .)
    RPAREN          reduce using rule 51 (factor -> FLOAT_NUMBER .)
    COMMA           reduce using rule 51 (factor -> FLOAT_NUMBER .)


state 92

    (52) factor -> STRING_LITERAL .

    MULTIPLY        reduce using rule 52 (factor -> STRING_LITERAL .)
    DIVIDE          reduce using rule 52 (factor -> STRING_LITERAL .)
    PLUS            reduce using rule 52 (factor -> STRING_LITERAL .)
    MINUS           reduce using rule 52 (factor -> STRING_LITERAL .)
    LESS_THAN       reduce using rule 52 (factor -> STRING_LITERAL .)
    GREATER_THAN    reduce using rule 52 (factor -> STRING_LITERAL .)
    LESS_EQUAL      reduce using rule 52 (factor -> STRING_LITERAL .)
    GREATER_EQUAL   reduce using rule 52 (factor -> STRING_LITERAL .)
    EQUAL_EQUAL     reduce using rule 52 (factor -> STRING_LITERAL .)
    NOT_EQUAL       reduce using rule 52 (factor -> STRING_LITERAL .)
    SEMICOLON       reduce using rule 52 (factor -> STRING_LITERAL .)
    RPAREN          reduce using rule 52 (factor -> STRING_LITERAL .)
    COMMA           reduce using rule 52 (factor -> STRING_LITERAL .)


state 93

    (53) factor -> TRUE .

    MULTIPLY        reduce using rule 53 (factor -> TRUE .)
    DIVIDE          reduce using rule 53 (factor -> TRUE .)
    PLUS            reduce using rule 53 (factor -> TRUE .)
    MINUS           reduce using rule 53 (factor -> TRUE .)
    LESS_THAN       reduce using rule 53 (factor -> TRUE .)
    GREATER_THAN    reduce using rule 53 (factor -> TRUE .)
    LESS_EQUAL      reduce using rule 53 (factor -> TRUE .)
    GREATER_EQUAL   reduce using rule 53 (factor -> TRUE .)
    EQUAL_EQUAL     reduce using rule 53 (factor -> TRUE .)
    NOT_EQUAL       reduce using rule 53 (factor -> TRUE .)
    SEMICOLON       reduce using rule 53 (factor -> TRUE .)
    RPAREN          reduce using rule 53 (factor -> TRUE .)
    COMMA           reduce using rule 53 (factor -> TRUE .)


state 94

    (54) factor -> FALSE .

    MULTIPLY        reduce using rule 54 (factor -> FALSE .)
    DIVIDE          reduce using rule 54 (factor -> FALSE .)
    PLUS            reduce using rule 54 (factor -> FALSE .)
    MINUS           reduce using rule 54 (factor -> FALSE .)
    LESS_THAN       reduce using rule 54 (factor -> FALSE .)
    GREATER_THAN    reduce using rule 54 (factor -> FALSE .)
    LESS_EQUAL      reduce using rule 54 (factor -> FALSE .)
    GREATER_EQUAL   reduce using rule 54 (factor -> FALSE .)
    EQUAL_EQUAL     reduce using rule 54 (factor -> FALSE .)
    NOT_EQUAL       reduce using rule 54 (factor -> FALSE .)
    SEMICOLON       reduce using rule 54 (factor -> FALSE .)
    RPAREN          reduce using rule 54 (factor -> FALSE .)
    COMMA           reduce using rule 54 (factor -> FALSE .)


state 95

    (55) factor -> ID .
    (76) function_call -> ID . LPAREN arg_list RPAREN

    MULTIPLY        reduce using rule 55 (factor -> ID .)
    DIVIDE          reduce using rule 55 (factor -> ID .)
    PLUS            reduce using rule 55 (factor -> ID .)
    MINUS           reduce using rule 55 (factor -> ID .)
    LESS_THAN       reduce using rule 55 (factor -> ID .)
    GREATER_THAN    reduce using rule 55 (factor -> ID .)
    LESS_EQUAL      reduce using rule 55 (factor -> ID .)
    GREATER_EQUAL   reduce using rule 55 (factor -> ID .)
    EQUAL_EQUAL     reduce using rule 55 (factor -> ID .)
    NOT_EQUAL       reduce using rule 55 (factor -> ID .)
    SEMICOLON       reduce using rule 55 (factor -> ID .)
    RPAREN          reduce using rule 55 (factor -> ID .)
    COMMA           reduce using rule 55 (factor -> ID .)
    LPAREN          shift and go to state 72


state 96

    (72) function_decl -> type ID LPAREN create_function_scope . param_list RPAREN LBRACE stmt_list end_scopes RBRACE
    (79) param_list -> . param COMMA param_list
    (80) param_list -> . param
    (81) param_list -> . empty
    (82) param -> . type ID
    (84) empty -> .
    (17) type -> . INT
    (18) type -> . FLOAT
    (19) type -> . STRING
    (20) type -> . BOOL

    RPAREN          reduce using rule 84 (empty -> .)
    INT             shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 21
    BOOL            shift and go to state 22

    type                           shift and go to state 127
    param_list                     shift and go to state 128
    param                          shift and go to state 129
    empty                          shift and go to state 130

state 97

    (73) function_decl -> VOID ID LPAREN create_function_scope . param_list RPAREN LBRACE stmt_list end_scopes RBRACE
    (79) param_list -> . param COMMA param_list
    (80) param_list -> . param
    (81) param_list -> . empty
    (82) param -> . type ID
    (84) empty -> .
    (17) type -> . INT
    (18) type -> . FLOAT
    (19) type -> . STRING
    (20) type -> . BOOL

    RPAREN          reduce using rule 84 (empty -> .)
    INT             shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 21
    BOOL            shift and go to state 22

    param_list                     shift and go to state 131
    param                          shift and go to state 129
    empty                          shift and go to state 130
    type                           shift and go to state 127

state 98

    (21) stmt_list -> stmt SEMICOLON stmt_list .

    RBRACE          reduce using rule 21 (stmt_list -> stmt SEMICOLON stmt_list .)


state 99

    (40) assign -> ID EQUALS expr .
    (41) expr -> expr . PLUS term
    (42) expr -> expr . MINUS term
    (43) expr -> expr . comp_op term
    (61) comp_op -> . LESS_THAN
    (62) comp_op -> . GREATER_THAN
    (63) comp_op -> . LESS_EQUAL
    (64) comp_op -> . GREATER_EQUAL
    (65) comp_op -> . EQUAL_EQUAL
    (66) comp_op -> . NOT_EQUAL

    SEMICOLON       reduce using rule 40 (assign -> ID EQUALS expr .)
    PLUS            shift and go to state 115
    MINUS           shift and go to state 116
    LESS_THAN       shift and go to state 118
    GREATER_THAN    shift and go to state 119
    LESS_EQUAL      shift and go to state 120
    GREATER_EQUAL   shift and go to state 121
    EQUAL_EQUAL     shift and go to state 122
    NOT_EQUAL       shift and go to state 123

    comp_op                        shift and go to state 117

state 100

    (76) function_call -> ID LPAREN arg_list . RPAREN
    (77) arg_list -> arg_list . COMMA expr

    RPAREN          shift and go to state 132
    COMMA           shift and go to state 133


state 101

    (78) arg_list -> expr .
    (41) expr -> expr . PLUS term
    (42) expr -> expr . MINUS term
    (43) expr -> expr . comp_op term
    (61) comp_op -> . LESS_THAN
    (62) comp_op -> . GREATER_THAN
    (63) comp_op -> . LESS_EQUAL
    (64) comp_op -> . GREATER_EQUAL
    (65) comp_op -> . EQUAL_EQUAL
    (66) comp_op -> . NOT_EQUAL

    RPAREN          reduce using rule 78 (arg_list -> expr .)
    COMMA           reduce using rule 78 (arg_list -> expr .)
    PLUS            shift and go to state 115
    MINUS           shift and go to state 116
    LESS_THAN       shift and go to state 118
    GREATER_THAN    shift and go to state 119
    LESS_EQUAL      shift and go to state 120
    GREATER_EQUAL   shift and go to state 121
    EQUAL_EQUAL     shift and go to state 122
    NOT_EQUAL       shift and go to state 123

    comp_op                        shift and go to state 117

state 102

    (57) print -> PRINT COLON expr .
    (41) expr -> expr . PLUS term
    (42) expr -> expr . MINUS term
    (43) expr -> expr . comp_op term
    (61) comp_op -> . LESS_THAN
    (62) comp_op -> . GREATER_THAN
    (63) comp_op -> . LESS_EQUAL
    (64) comp_op -> . GREATER_EQUAL
    (65) comp_op -> . EQUAL_EQUAL
    (66) comp_op -> . NOT_EQUAL

    SEMICOLON       reduce using rule 57 (print -> PRINT COLON expr .)
    PLUS            shift and go to state 115
    MINUS           shift and go to state 116
    LESS_THAN       shift and go to state 118
    GREATER_THAN    shift and go to state 119
    LESS_EQUAL      shift and go to state 120
    GREATER_EQUAL   shift and go to state 121
    EQUAL_EQUAL     shift and go to state 122
    NOT_EQUAL       shift and go to state 123

    comp_op                        shift and go to state 117

state 103

    (58) conditional -> IF LPAREN comp_expr . RPAREN LBRACE stmt_list RBRACE else_stmt
    (59) conditional -> IF LPAREN comp_expr . RPAREN LBRACE stmt_list RBRACE

    RPAREN          shift and go to state 134


state 104

    (60) comp_expr -> expr . comp_op expr
    (41) expr -> expr . PLUS term
    (42) expr -> expr . MINUS term
    (43) expr -> expr . comp_op term
    (61) comp_op -> . LESS_THAN
    (62) comp_op -> . GREATER_THAN
    (63) comp_op -> . LESS_EQUAL
    (64) comp_op -> . GREATER_EQUAL
    (65) comp_op -> . EQUAL_EQUAL
    (66) comp_op -> . NOT_EQUAL

    PLUS            shift and go to state 115
    MINUS           shift and go to state 116
    LESS_THAN       shift and go to state 118
    GREATER_THAN    shift and go to state 119
    LESS_EQUAL      shift and go to state 120
    GREATER_EQUAL   shift and go to state 121
    EQUAL_EQUAL     shift and go to state 122
    NOT_EQUAL       shift and go to state 123

    comp_op                        shift and go to state 135

state 105

    (70) loop -> WHILE LPAREN comp_expr . RPAREN LBRACE stmt_list RBRACE

    RPAREN          shift and go to state 136


state 106

    (31) built_in_function -> TEACH_SUM LPAREN RPAREN .

    SEMICOLON       reduce using rule 31 (built_in_function -> TEACH_SUM LPAREN RPAREN .)


state 107

    (32) built_in_function -> TEACH_SUBSTRACTION LPAREN RPAREN .

    SEMICOLON       reduce using rule 32 (built_in_function -> TEACH_SUBSTRACTION LPAREN RPAREN .)


state 108

    (33) built_in_function -> TEACH_MULTIPLICATION LPAREN RPAREN .

    SEMICOLON       reduce using rule 33 (built_in_function -> TEACH_MULTIPLICATION LPAREN RPAREN .)


state 109

    (34) built_in_function -> TEACH_DIVISION LPAREN RPAREN .

    SEMICOLON       reduce using rule 34 (built_in_function -> TEACH_DIVISION LPAREN RPAREN .)


state 110

    (35) built_in_function -> TEACH_IF LPAREN RPAREN .

    SEMICOLON       reduce using rule 35 (built_in_function -> TEACH_IF LPAREN RPAREN .)


state 111

    (36) built_in_function -> TEACH_WHILE LPAREN RPAREN .

    SEMICOLON       reduce using rule 36 (built_in_function -> TEACH_WHILE LPAREN RPAREN .)


state 112

    (37) built_in_function -> TEACH_FUNCTION_DECLARATION LPAREN RPAREN .

    SEMICOLON       reduce using rule 37 (built_in_function -> TEACH_FUNCTION_DECLARATION LPAREN RPAREN .)


state 113

    (38) built_in_function -> TEACH_FUNCTION_CALL LPAREN RPAREN .

    SEMICOLON       reduce using rule 38 (built_in_function -> TEACH_FUNCTION_CALL LPAREN RPAREN .)


state 114

    (39) built_in_function -> AYUDA LPAREN RPAREN .

    SEMICOLON       reduce using rule 39 (built_in_function -> AYUDA LPAREN RPAREN .)


state 115

    (41) expr -> expr PLUS . term
    (45) term -> . term MULTIPLY factor
    (46) term -> . term DIVIDE factor
    (47) term -> . factor
    (48) term -> . function_call
    (49) factor -> . LPAREN expr RPAREN
    (50) factor -> . CTEI
    (51) factor -> . FLOAT_NUMBER
    (52) factor -> . STRING_LITERAL
    (53) factor -> . TRUE
    (54) factor -> . FALSE
    (55) factor -> . ID
    (56) factor -> . function_call
    (76) function_call -> . ID LPAREN arg_list RPAREN

    LPAREN          shift and go to state 89
    CTEI            shift and go to state 90
    FLOAT_NUMBER    shift and go to state 91
    STRING_LITERAL  shift and go to state 92
    TRUE            shift and go to state 93
    FALSE           shift and go to state 94
    ID              shift and go to state 95

    term                           shift and go to state 137
    factor                         shift and go to state 87
    function_call                  shift and go to state 88

state 116

    (42) expr -> expr MINUS . term
    (45) term -> . term MULTIPLY factor
    (46) term -> . term DIVIDE factor
    (47) term -> . factor
    (48) term -> . function_call
    (49) factor -> . LPAREN expr RPAREN
    (50) factor -> . CTEI
    (51) factor -> . FLOAT_NUMBER
    (52) factor -> . STRING_LITERAL
    (53) factor -> . TRUE
    (54) factor -> . FALSE
    (55) factor -> . ID
    (56) factor -> . function_call
    (76) function_call -> . ID LPAREN arg_list RPAREN

    LPAREN          shift and go to state 89
    CTEI            shift and go to state 90
    FLOAT_NUMBER    shift and go to state 91
    STRING_LITERAL  shift and go to state 92
    TRUE            shift and go to state 93
    FALSE           shift and go to state 94
    ID              shift and go to state 95

    term                           shift and go to state 138
    factor                         shift and go to state 87
    function_call                  shift and go to state 88

state 117

    (43) expr -> expr comp_op . term
    (45) term -> . term MULTIPLY factor
    (46) term -> . term DIVIDE factor
    (47) term -> . factor
    (48) term -> . function_call
    (49) factor -> . LPAREN expr RPAREN
    (50) factor -> . CTEI
    (51) factor -> . FLOAT_NUMBER
    (52) factor -> . STRING_LITERAL
    (53) factor -> . TRUE
    (54) factor -> . FALSE
    (55) factor -> . ID
    (56) factor -> . function_call
    (76) function_call -> . ID LPAREN arg_list RPAREN

    LPAREN          shift and go to state 89
    CTEI            shift and go to state 90
    FLOAT_NUMBER    shift and go to state 91
    STRING_LITERAL  shift and go to state 92
    TRUE            shift and go to state 93
    FALSE           shift and go to state 94
    ID              shift and go to state 95

    term                           shift and go to state 139
    factor                         shift and go to state 87
    function_call                  shift and go to state 88

state 118

    (61) comp_op -> LESS_THAN .

    LPAREN          reduce using rule 61 (comp_op -> LESS_THAN .)
    CTEI            reduce using rule 61 (comp_op -> LESS_THAN .)
    FLOAT_NUMBER    reduce using rule 61 (comp_op -> LESS_THAN .)
    STRING_LITERAL  reduce using rule 61 (comp_op -> LESS_THAN .)
    TRUE            reduce using rule 61 (comp_op -> LESS_THAN .)
    FALSE           reduce using rule 61 (comp_op -> LESS_THAN .)
    ID              reduce using rule 61 (comp_op -> LESS_THAN .)


state 119

    (62) comp_op -> GREATER_THAN .

    LPAREN          reduce using rule 62 (comp_op -> GREATER_THAN .)
    CTEI            reduce using rule 62 (comp_op -> GREATER_THAN .)
    FLOAT_NUMBER    reduce using rule 62 (comp_op -> GREATER_THAN .)
    STRING_LITERAL  reduce using rule 62 (comp_op -> GREATER_THAN .)
    TRUE            reduce using rule 62 (comp_op -> GREATER_THAN .)
    FALSE           reduce using rule 62 (comp_op -> GREATER_THAN .)
    ID              reduce using rule 62 (comp_op -> GREATER_THAN .)


state 120

    (63) comp_op -> LESS_EQUAL .

    LPAREN          reduce using rule 63 (comp_op -> LESS_EQUAL .)
    CTEI            reduce using rule 63 (comp_op -> LESS_EQUAL .)
    FLOAT_NUMBER    reduce using rule 63 (comp_op -> LESS_EQUAL .)
    STRING_LITERAL  reduce using rule 63 (comp_op -> LESS_EQUAL .)
    TRUE            reduce using rule 63 (comp_op -> LESS_EQUAL .)
    FALSE           reduce using rule 63 (comp_op -> LESS_EQUAL .)
    ID              reduce using rule 63 (comp_op -> LESS_EQUAL .)


state 121

    (64) comp_op -> GREATER_EQUAL .

    LPAREN          reduce using rule 64 (comp_op -> GREATER_EQUAL .)
    CTEI            reduce using rule 64 (comp_op -> GREATER_EQUAL .)
    FLOAT_NUMBER    reduce using rule 64 (comp_op -> GREATER_EQUAL .)
    STRING_LITERAL  reduce using rule 64 (comp_op -> GREATER_EQUAL .)
    TRUE            reduce using rule 64 (comp_op -> GREATER_EQUAL .)
    FALSE           reduce using rule 64 (comp_op -> GREATER_EQUAL .)
    ID              reduce using rule 64 (comp_op -> GREATER_EQUAL .)


state 122

    (65) comp_op -> EQUAL_EQUAL .

    LPAREN          reduce using rule 65 (comp_op -> EQUAL_EQUAL .)
    CTEI            reduce using rule 65 (comp_op -> EQUAL_EQUAL .)
    FLOAT_NUMBER    reduce using rule 65 (comp_op -> EQUAL_EQUAL .)
    STRING_LITERAL  reduce using rule 65 (comp_op -> EQUAL_EQUAL .)
    TRUE            reduce using rule 65 (comp_op -> EQUAL_EQUAL .)
    FALSE           reduce using rule 65 (comp_op -> EQUAL_EQUAL .)
    ID              reduce using rule 65 (comp_op -> EQUAL_EQUAL .)


state 123

    (66) comp_op -> NOT_EQUAL .

    LPAREN          reduce using rule 66 (comp_op -> NOT_EQUAL .)
    CTEI            reduce using rule 66 (comp_op -> NOT_EQUAL .)
    FLOAT_NUMBER    reduce using rule 66 (comp_op -> NOT_EQUAL .)
    STRING_LITERAL  reduce using rule 66 (comp_op -> NOT_EQUAL .)
    TRUE            reduce using rule 66 (comp_op -> NOT_EQUAL .)
    FALSE           reduce using rule 66 (comp_op -> NOT_EQUAL .)
    ID              reduce using rule 66 (comp_op -> NOT_EQUAL .)


state 124

    (45) term -> term MULTIPLY . factor
    (49) factor -> . LPAREN expr RPAREN
    (50) factor -> . CTEI
    (51) factor -> . FLOAT_NUMBER
    (52) factor -> . STRING_LITERAL
    (53) factor -> . TRUE
    (54) factor -> . FALSE
    (55) factor -> . ID
    (56) factor -> . function_call
    (76) function_call -> . ID LPAREN arg_list RPAREN

    LPAREN          shift and go to state 89
    CTEI            shift and go to state 90
    FLOAT_NUMBER    shift and go to state 91
    STRING_LITERAL  shift and go to state 92
    TRUE            shift and go to state 93
    FALSE           shift and go to state 94
    ID              shift and go to state 95

    factor                         shift and go to state 140
    function_call                  shift and go to state 141

state 125

    (46) term -> term DIVIDE . factor
    (49) factor -> . LPAREN expr RPAREN
    (50) factor -> . CTEI
    (51) factor -> . FLOAT_NUMBER
    (52) factor -> . STRING_LITERAL
    (53) factor -> . TRUE
    (54) factor -> . FALSE
    (55) factor -> . ID
    (56) factor -> . function_call
    (76) function_call -> . ID LPAREN arg_list RPAREN

    LPAREN          shift and go to state 89
    CTEI            shift and go to state 90
    FLOAT_NUMBER    shift and go to state 91
    STRING_LITERAL  shift and go to state 92
    TRUE            shift and go to state 93
    FALSE           shift and go to state 94
    ID              shift and go to state 95

    factor                         shift and go to state 142
    function_call                  shift and go to state 141

state 126

    (49) factor -> LPAREN expr . RPAREN
    (41) expr -> expr . PLUS term
    (42) expr -> expr . MINUS term
    (43) expr -> expr . comp_op term
    (61) comp_op -> . LESS_THAN
    (62) comp_op -> . GREATER_THAN
    (63) comp_op -> . LESS_EQUAL
    (64) comp_op -> . GREATER_EQUAL
    (65) comp_op -> . EQUAL_EQUAL
    (66) comp_op -> . NOT_EQUAL

    RPAREN          shift and go to state 143
    PLUS            shift and go to state 115
    MINUS           shift and go to state 116
    LESS_THAN       shift and go to state 118
    GREATER_THAN    shift and go to state 119
    LESS_EQUAL      shift and go to state 120
    GREATER_EQUAL   shift and go to state 121
    EQUAL_EQUAL     shift and go to state 122
    NOT_EQUAL       shift and go to state 123

    comp_op                        shift and go to state 117

state 127

    (82) param -> type . ID

    ID              shift and go to state 144


state 128

    (72) function_decl -> type ID LPAREN create_function_scope param_list . RPAREN LBRACE stmt_list end_scopes RBRACE

    RPAREN          shift and go to state 145


state 129

    (79) param_list -> param . COMMA param_list
    (80) param_list -> param .

    COMMA           shift and go to state 146
    RPAREN          reduce using rule 80 (param_list -> param .)


state 130

    (81) param_list -> empty .

    RPAREN          reduce using rule 81 (param_list -> empty .)


state 131

    (73) function_decl -> VOID ID LPAREN create_function_scope param_list . RPAREN LBRACE stmt_list end_scopes RBRACE

    RPAREN          shift and go to state 147


state 132

    (76) function_call -> ID LPAREN arg_list RPAREN .

    SEMICOLON       reduce using rule 76 (function_call -> ID LPAREN arg_list RPAREN .)
    MULTIPLY        reduce using rule 76 (function_call -> ID LPAREN arg_list RPAREN .)
    DIVIDE          reduce using rule 76 (function_call -> ID LPAREN arg_list RPAREN .)
    PLUS            reduce using rule 76 (function_call -> ID LPAREN arg_list RPAREN .)
    MINUS           reduce using rule 76 (function_call -> ID LPAREN arg_list RPAREN .)
    LESS_THAN       reduce using rule 76 (function_call -> ID LPAREN arg_list RPAREN .)
    GREATER_THAN    reduce using rule 76 (function_call -> ID LPAREN arg_list RPAREN .)
    LESS_EQUAL      reduce using rule 76 (function_call -> ID LPAREN arg_list RPAREN .)
    GREATER_EQUAL   reduce using rule 76 (function_call -> ID LPAREN arg_list RPAREN .)
    EQUAL_EQUAL     reduce using rule 76 (function_call -> ID LPAREN arg_list RPAREN .)
    NOT_EQUAL       reduce using rule 76 (function_call -> ID LPAREN arg_list RPAREN .)
    RPAREN          reduce using rule 76 (function_call -> ID LPAREN arg_list RPAREN .)
    COMMA           reduce using rule 76 (function_call -> ID LPAREN arg_list RPAREN .)


state 133

    (77) arg_list -> arg_list COMMA . expr
    (41) expr -> . expr PLUS term
    (42) expr -> . expr MINUS term
    (43) expr -> . expr comp_op term
    (44) expr -> . term
    (45) term -> . term MULTIPLY factor
    (46) term -> . term DIVIDE factor
    (47) term -> . factor
    (48) term -> . function_call
    (49) factor -> . LPAREN expr RPAREN
    (50) factor -> . CTEI
    (51) factor -> . FLOAT_NUMBER
    (52) factor -> . STRING_LITERAL
    (53) factor -> . TRUE
    (54) factor -> . FALSE
    (55) factor -> . ID
    (56) factor -> . function_call
    (76) function_call -> . ID LPAREN arg_list RPAREN

    LPAREN          shift and go to state 89
    CTEI            shift and go to state 90
    FLOAT_NUMBER    shift and go to state 91
    STRING_LITERAL  shift and go to state 92
    TRUE            shift and go to state 93
    FALSE           shift and go to state 94
    ID              shift and go to state 95

    expr                           shift and go to state 148
    term                           shift and go to state 86
    factor                         shift and go to state 87
    function_call                  shift and go to state 88

state 134

    (58) conditional -> IF LPAREN comp_expr RPAREN . LBRACE stmt_list RBRACE else_stmt
    (59) conditional -> IF LPAREN comp_expr RPAREN . LBRACE stmt_list RBRACE

    LBRACE          shift and go to state 149


state 135

    (60) comp_expr -> expr comp_op . expr
    (43) expr -> expr comp_op . term
    (41) expr -> . expr PLUS term
    (42) expr -> . expr MINUS term
    (43) expr -> . expr comp_op term
    (44) expr -> . term
    (45) term -> . term MULTIPLY factor
    (46) term -> . term DIVIDE factor
    (47) term -> . factor
    (48) term -> . function_call
    (49) factor -> . LPAREN expr RPAREN
    (50) factor -> . CTEI
    (51) factor -> . FLOAT_NUMBER
    (52) factor -> . STRING_LITERAL
    (53) factor -> . TRUE
    (54) factor -> . FALSE
    (55) factor -> . ID
    (56) factor -> . function_call
    (76) function_call -> . ID LPAREN arg_list RPAREN

    LPAREN          shift and go to state 89
    CTEI            shift and go to state 90
    FLOAT_NUMBER    shift and go to state 91
    STRING_LITERAL  shift and go to state 92
    TRUE            shift and go to state 93
    FALSE           shift and go to state 94
    ID              shift and go to state 95

    expr                           shift and go to state 150
    term                           shift and go to state 151
    factor                         shift and go to state 87
    function_call                  shift and go to state 88

state 136

    (70) loop -> WHILE LPAREN comp_expr RPAREN . LBRACE stmt_list RBRACE

    LBRACE          shift and go to state 152


state 137

    (41) expr -> expr PLUS term .
    (45) term -> term . MULTIPLY factor
    (46) term -> term . DIVIDE factor

    PLUS            reduce using rule 41 (expr -> expr PLUS term .)
    MINUS           reduce using rule 41 (expr -> expr PLUS term .)
    LESS_THAN       reduce using rule 41 (expr -> expr PLUS term .)
    GREATER_THAN    reduce using rule 41 (expr -> expr PLUS term .)
    LESS_EQUAL      reduce using rule 41 (expr -> expr PLUS term .)
    GREATER_EQUAL   reduce using rule 41 (expr -> expr PLUS term .)
    EQUAL_EQUAL     reduce using rule 41 (expr -> expr PLUS term .)
    NOT_EQUAL       reduce using rule 41 (expr -> expr PLUS term .)
    SEMICOLON       reduce using rule 41 (expr -> expr PLUS term .)
    RPAREN          reduce using rule 41 (expr -> expr PLUS term .)
    COMMA           reduce using rule 41 (expr -> expr PLUS term .)
    MULTIPLY        shift and go to state 124
    DIVIDE          shift and go to state 125


state 138

    (42) expr -> expr MINUS term .
    (45) term -> term . MULTIPLY factor
    (46) term -> term . DIVIDE factor

    PLUS            reduce using rule 42 (expr -> expr MINUS term .)
    MINUS           reduce using rule 42 (expr -> expr MINUS term .)
    LESS_THAN       reduce using rule 42 (expr -> expr MINUS term .)
    GREATER_THAN    reduce using rule 42 (expr -> expr MINUS term .)
    LESS_EQUAL      reduce using rule 42 (expr -> expr MINUS term .)
    GREATER_EQUAL   reduce using rule 42 (expr -> expr MINUS term .)
    EQUAL_EQUAL     reduce using rule 42 (expr -> expr MINUS term .)
    NOT_EQUAL       reduce using rule 42 (expr -> expr MINUS term .)
    SEMICOLON       reduce using rule 42 (expr -> expr MINUS term .)
    RPAREN          reduce using rule 42 (expr -> expr MINUS term .)
    COMMA           reduce using rule 42 (expr -> expr MINUS term .)
    MULTIPLY        shift and go to state 124
    DIVIDE          shift and go to state 125


state 139

    (43) expr -> expr comp_op term .
    (45) term -> term . MULTIPLY factor
    (46) term -> term . DIVIDE factor

    PLUS            reduce using rule 43 (expr -> expr comp_op term .)
    MINUS           reduce using rule 43 (expr -> expr comp_op term .)
    LESS_THAN       reduce using rule 43 (expr -> expr comp_op term .)
    GREATER_THAN    reduce using rule 43 (expr -> expr comp_op term .)
    LESS_EQUAL      reduce using rule 43 (expr -> expr comp_op term .)
    GREATER_EQUAL   reduce using rule 43 (expr -> expr comp_op term .)
    EQUAL_EQUAL     reduce using rule 43 (expr -> expr comp_op term .)
    NOT_EQUAL       reduce using rule 43 (expr -> expr comp_op term .)
    SEMICOLON       reduce using rule 43 (expr -> expr comp_op term .)
    RPAREN          reduce using rule 43 (expr -> expr comp_op term .)
    COMMA           reduce using rule 43 (expr -> expr comp_op term .)
    MULTIPLY        shift and go to state 124
    DIVIDE          shift and go to state 125


state 140

    (45) term -> term MULTIPLY factor .

    MULTIPLY        reduce using rule 45 (term -> term MULTIPLY factor .)
    DIVIDE          reduce using rule 45 (term -> term MULTIPLY factor .)
    PLUS            reduce using rule 45 (term -> term MULTIPLY factor .)
    MINUS           reduce using rule 45 (term -> term MULTIPLY factor .)
    LESS_THAN       reduce using rule 45 (term -> term MULTIPLY factor .)
    GREATER_THAN    reduce using rule 45 (term -> term MULTIPLY factor .)
    LESS_EQUAL      reduce using rule 45 (term -> term MULTIPLY factor .)
    GREATER_EQUAL   reduce using rule 45 (term -> term MULTIPLY factor .)
    EQUAL_EQUAL     reduce using rule 45 (term -> term MULTIPLY factor .)
    NOT_EQUAL       reduce using rule 45 (term -> term MULTIPLY factor .)
    SEMICOLON       reduce using rule 45 (term -> term MULTIPLY factor .)
    RPAREN          reduce using rule 45 (term -> term MULTIPLY factor .)
    COMMA           reduce using rule 45 (term -> term MULTIPLY factor .)


state 141

    (56) factor -> function_call .

    MULTIPLY        reduce using rule 56 (factor -> function_call .)
    DIVIDE          reduce using rule 56 (factor -> function_call .)
    PLUS            reduce using rule 56 (factor -> function_call .)
    MINUS           reduce using rule 56 (factor -> function_call .)
    LESS_THAN       reduce using rule 56 (factor -> function_call .)
    GREATER_THAN    reduce using rule 56 (factor -> function_call .)
    LESS_EQUAL      reduce using rule 56 (factor -> function_call .)
    GREATER_EQUAL   reduce using rule 56 (factor -> function_call .)
    EQUAL_EQUAL     reduce using rule 56 (factor -> function_call .)
    NOT_EQUAL       reduce using rule 56 (factor -> function_call .)
    SEMICOLON       reduce using rule 56 (factor -> function_call .)
    RPAREN          reduce using rule 56 (factor -> function_call .)
    COMMA           reduce using rule 56 (factor -> function_call .)


state 142

    (46) term -> term DIVIDE factor .

    MULTIPLY        reduce using rule 46 (term -> term DIVIDE factor .)
    DIVIDE          reduce using rule 46 (term -> term DIVIDE factor .)
    PLUS            reduce using rule 46 (term -> term DIVIDE factor .)
    MINUS           reduce using rule 46 (term -> term DIVIDE factor .)
    LESS_THAN       reduce using rule 46 (term -> term DIVIDE factor .)
    GREATER_THAN    reduce using rule 46 (term -> term DIVIDE factor .)
    LESS_EQUAL      reduce using rule 46 (term -> term DIVIDE factor .)
    GREATER_EQUAL   reduce using rule 46 (term -> term DIVIDE factor .)
    EQUAL_EQUAL     reduce using rule 46 (term -> term DIVIDE factor .)
    NOT_EQUAL       reduce using rule 46 (term -> term DIVIDE factor .)
    SEMICOLON       reduce using rule 46 (term -> term DIVIDE factor .)
    RPAREN          reduce using rule 46 (term -> term DIVIDE factor .)
    COMMA           reduce using rule 46 (term -> term DIVIDE factor .)


state 143

    (49) factor -> LPAREN expr RPAREN .

    MULTIPLY        reduce using rule 49 (factor -> LPAREN expr RPAREN .)
    DIVIDE          reduce using rule 49 (factor -> LPAREN expr RPAREN .)
    PLUS            reduce using rule 49 (factor -> LPAREN expr RPAREN .)
    MINUS           reduce using rule 49 (factor -> LPAREN expr RPAREN .)
    LESS_THAN       reduce using rule 49 (factor -> LPAREN expr RPAREN .)
    GREATER_THAN    reduce using rule 49 (factor -> LPAREN expr RPAREN .)
    LESS_EQUAL      reduce using rule 49 (factor -> LPAREN expr RPAREN .)
    GREATER_EQUAL   reduce using rule 49 (factor -> LPAREN expr RPAREN .)
    EQUAL_EQUAL     reduce using rule 49 (factor -> LPAREN expr RPAREN .)
    NOT_EQUAL       reduce using rule 49 (factor -> LPAREN expr RPAREN .)
    SEMICOLON       reduce using rule 49 (factor -> LPAREN expr RPAREN .)
    RPAREN          reduce using rule 49 (factor -> LPAREN expr RPAREN .)
    COMMA           reduce using rule 49 (factor -> LPAREN expr RPAREN .)


state 144

    (82) param -> type ID .

    COMMA           reduce using rule 82 (param -> type ID .)
    RPAREN          reduce using rule 82 (param -> type ID .)


state 145

    (72) function_decl -> type ID LPAREN create_function_scope param_list RPAREN . LBRACE stmt_list end_scopes RBRACE

    LBRACE          shift and go to state 153


state 146

    (79) param_list -> param COMMA . param_list
    (79) param_list -> . param COMMA param_list
    (80) param_list -> . param
    (81) param_list -> . empty
    (82) param -> . type ID
    (84) empty -> .
    (17) type -> . INT
    (18) type -> . FLOAT
    (19) type -> . STRING
    (20) type -> . BOOL

    RPAREN          reduce using rule 84 (empty -> .)
    INT             shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 21
    BOOL            shift and go to state 22

    param                          shift and go to state 129
    param_list                     shift and go to state 154
    empty                          shift and go to state 130
    type                           shift and go to state 127

state 147

    (73) function_decl -> VOID ID LPAREN create_function_scope param_list RPAREN . LBRACE stmt_list end_scopes RBRACE

    LBRACE          shift and go to state 155


state 148

    (77) arg_list -> arg_list COMMA expr .
    (41) expr -> expr . PLUS term
    (42) expr -> expr . MINUS term
    (43) expr -> expr . comp_op term
    (61) comp_op -> . LESS_THAN
    (62) comp_op -> . GREATER_THAN
    (63) comp_op -> . LESS_EQUAL
    (64) comp_op -> . GREATER_EQUAL
    (65) comp_op -> . EQUAL_EQUAL
    (66) comp_op -> . NOT_EQUAL

    RPAREN          reduce using rule 77 (arg_list -> arg_list COMMA expr .)
    COMMA           reduce using rule 77 (arg_list -> arg_list COMMA expr .)
    PLUS            shift and go to state 115
    MINUS           shift and go to state 116
    LESS_THAN       shift and go to state 118
    GREATER_THAN    shift and go to state 119
    LESS_EQUAL      shift and go to state 120
    GREATER_EQUAL   shift and go to state 121
    EQUAL_EQUAL     shift and go to state 122
    NOT_EQUAL       shift and go to state 123

    comp_op                        shift and go to state 117

state 149

    (58) conditional -> IF LPAREN comp_expr RPAREN LBRACE . stmt_list RBRACE else_stmt
    (59) conditional -> IF LPAREN comp_expr RPAREN LBRACE . stmt_list RBRACE
    (21) stmt_list -> . stmt SEMICOLON stmt_list
    (22) stmt_list -> . stmt SEMICOLON
    (23) stmt -> . assign
    (24) stmt -> . print
    (25) stmt -> . conditional
    (26) stmt -> . loop
    (27) stmt -> . function_call
    (28) stmt -> . decl
    (29) stmt -> . built_in_function
    (30) stmt -> . return_stmt
    (40) assign -> . ID EQUALS expr
    (57) print -> . PRINT COLON expr
    (58) conditional -> . IF LPAREN comp_expr RPAREN LBRACE stmt_list RBRACE else_stmt
    (59) conditional -> . IF LPAREN comp_expr RPAREN LBRACE stmt_list RBRACE
    (70) loop -> . WHILE LPAREN comp_expr RPAREN LBRACE stmt_list RBRACE
    (76) function_call -> . ID LPAREN arg_list RPAREN
    (15) decl -> . type ID
    (16) decl -> . array_decl
    (31) built_in_function -> . TEACH_SUM LPAREN RPAREN
    (32) built_in_function -> . TEACH_SUBSTRACTION LPAREN RPAREN
    (33) built_in_function -> . TEACH_MULTIPLICATION LPAREN RPAREN
    (34) built_in_function -> . TEACH_DIVISION LPAREN RPAREN
    (35) built_in_function -> . TEACH_IF LPAREN RPAREN
    (36) built_in_function -> . TEACH_WHILE LPAREN RPAREN
    (37) built_in_function -> . TEACH_FUNCTION_DECLARATION LPAREN RPAREN
    (38) built_in_function -> . TEACH_FUNCTION_CALL LPAREN RPAREN
    (39) built_in_function -> . AYUDA LPAREN RPAREN
    (74) return_stmt -> . RETURN expr
    (75) return_stmt -> . empty
    (17) type -> . INT
    (18) type -> . FLOAT
    (19) type -> . STRING
    (20) type -> . BOOL
    (83) array_decl -> . type ID LBRACKET CTEI RBRACKET
    (84) empty -> .

    ID              shift and go to state 51
    PRINT           shift and go to state 52
    IF              shift and go to state 53
    WHILE           shift and go to state 54
    TEACH_SUM       shift and go to state 55
    TEACH_SUBSTRACTION shift and go to state 56
    TEACH_MULTIPLICATION shift and go to state 57
    TEACH_DIVISION  shift and go to state 58
    TEACH_IF        shift and go to state 59
    TEACH_WHILE     shift and go to state 60
    TEACH_FUNCTION_DECLARATION shift and go to state 61
    TEACH_FUNCTION_CALL shift and go to state 62
    AYUDA           shift and go to state 63
    RETURN          shift and go to state 64
    INT             shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 21
    BOOL            shift and go to state 22
    SEMICOLON       reduce using rule 84 (empty -> .)

    stmt_list                      shift and go to state 156
    stmt                           shift and go to state 42
    assign                         shift and go to state 43
    print                          shift and go to state 44
    conditional                    shift and go to state 45
    loop                           shift and go to state 46
    function_call                  shift and go to state 47
    decl                           shift and go to state 48
    built_in_function              shift and go to state 49
    return_stmt                    shift and go to state 50
    type                           shift and go to state 17
    array_decl                     shift and go to state 18
    empty                          shift and go to state 65

state 150

    (60) comp_expr -> expr comp_op expr .
    (41) expr -> expr . PLUS term
    (42) expr -> expr . MINUS term
    (43) expr -> expr . comp_op term
    (61) comp_op -> . LESS_THAN
    (62) comp_op -> . GREATER_THAN
    (63) comp_op -> . LESS_EQUAL
    (64) comp_op -> . GREATER_EQUAL
    (65) comp_op -> . EQUAL_EQUAL
    (66) comp_op -> . NOT_EQUAL

    RPAREN          reduce using rule 60 (comp_expr -> expr comp_op expr .)
    PLUS            shift and go to state 115
    MINUS           shift and go to state 116
    LESS_THAN       shift and go to state 118
    GREATER_THAN    shift and go to state 119
    LESS_EQUAL      shift and go to state 120
    GREATER_EQUAL   shift and go to state 121
    EQUAL_EQUAL     shift and go to state 122
    NOT_EQUAL       shift and go to state 123

    comp_op                        shift and go to state 117

state 151

    (43) expr -> expr comp_op term .
    (44) expr -> term .
    (45) term -> term . MULTIPLY factor
    (46) term -> term . DIVIDE factor

  ! reduce/reduce conflict for PLUS resolved using rule 43 (expr -> expr comp_op term .)
  ! reduce/reduce conflict for MINUS resolved using rule 43 (expr -> expr comp_op term .)
  ! reduce/reduce conflict for LESS_THAN resolved using rule 43 (expr -> expr comp_op term .)
  ! reduce/reduce conflict for GREATER_THAN resolved using rule 43 (expr -> expr comp_op term .)
  ! reduce/reduce conflict for LESS_EQUAL resolved using rule 43 (expr -> expr comp_op term .)
  ! reduce/reduce conflict for GREATER_EQUAL resolved using rule 43 (expr -> expr comp_op term .)
  ! reduce/reduce conflict for EQUAL_EQUAL resolved using rule 43 (expr -> expr comp_op term .)
  ! reduce/reduce conflict for NOT_EQUAL resolved using rule 43 (expr -> expr comp_op term .)
    PLUS            reduce using rule 43 (expr -> expr comp_op term .)
    MINUS           reduce using rule 43 (expr -> expr comp_op term .)
    LESS_THAN       reduce using rule 43 (expr -> expr comp_op term .)
    GREATER_THAN    reduce using rule 43 (expr -> expr comp_op term .)
    LESS_EQUAL      reduce using rule 43 (expr -> expr comp_op term .)
    GREATER_EQUAL   reduce using rule 43 (expr -> expr comp_op term .)
    EQUAL_EQUAL     reduce using rule 43 (expr -> expr comp_op term .)
    NOT_EQUAL       reduce using rule 43 (expr -> expr comp_op term .)
    RPAREN          reduce using rule 44 (expr -> term .)
    MULTIPLY        shift and go to state 124
    DIVIDE          shift and go to state 125

  ! PLUS            [ reduce using rule 44 (expr -> term .) ]
  ! MINUS           [ reduce using rule 44 (expr -> term .) ]
  ! LESS_THAN       [ reduce using rule 44 (expr -> term .) ]
  ! GREATER_THAN    [ reduce using rule 44 (expr -> term .) ]
  ! LESS_EQUAL      [ reduce using rule 44 (expr -> term .) ]
  ! GREATER_EQUAL   [ reduce using rule 44 (expr -> term .) ]
  ! EQUAL_EQUAL     [ reduce using rule 44 (expr -> term .) ]
  ! NOT_EQUAL       [ reduce using rule 44 (expr -> term .) ]


state 152

    (70) loop -> WHILE LPAREN comp_expr RPAREN LBRACE . stmt_list RBRACE
    (21) stmt_list -> . stmt SEMICOLON stmt_list
    (22) stmt_list -> . stmt SEMICOLON
    (23) stmt -> . assign
    (24) stmt -> . print
    (25) stmt -> . conditional
    (26) stmt -> . loop
    (27) stmt -> . function_call
    (28) stmt -> . decl
    (29) stmt -> . built_in_function
    (30) stmt -> . return_stmt
    (40) assign -> . ID EQUALS expr
    (57) print -> . PRINT COLON expr
    (58) conditional -> . IF LPAREN comp_expr RPAREN LBRACE stmt_list RBRACE else_stmt
    (59) conditional -> . IF LPAREN comp_expr RPAREN LBRACE stmt_list RBRACE
    (70) loop -> . WHILE LPAREN comp_expr RPAREN LBRACE stmt_list RBRACE
    (76) function_call -> . ID LPAREN arg_list RPAREN
    (15) decl -> . type ID
    (16) decl -> . array_decl
    (31) built_in_function -> . TEACH_SUM LPAREN RPAREN
    (32) built_in_function -> . TEACH_SUBSTRACTION LPAREN RPAREN
    (33) built_in_function -> . TEACH_MULTIPLICATION LPAREN RPAREN
    (34) built_in_function -> . TEACH_DIVISION LPAREN RPAREN
    (35) built_in_function -> . TEACH_IF LPAREN RPAREN
    (36) built_in_function -> . TEACH_WHILE LPAREN RPAREN
    (37) built_in_function -> . TEACH_FUNCTION_DECLARATION LPAREN RPAREN
    (38) built_in_function -> . TEACH_FUNCTION_CALL LPAREN RPAREN
    (39) built_in_function -> . AYUDA LPAREN RPAREN
    (74) return_stmt -> . RETURN expr
    (75) return_stmt -> . empty
    (17) type -> . INT
    (18) type -> . FLOAT
    (19) type -> . STRING
    (20) type -> . BOOL
    (83) array_decl -> . type ID LBRACKET CTEI RBRACKET
    (84) empty -> .

    ID              shift and go to state 51
    PRINT           shift and go to state 52
    IF              shift and go to state 53
    WHILE           shift and go to state 54
    TEACH_SUM       shift and go to state 55
    TEACH_SUBSTRACTION shift and go to state 56
    TEACH_MULTIPLICATION shift and go to state 57
    TEACH_DIVISION  shift and go to state 58
    TEACH_IF        shift and go to state 59
    TEACH_WHILE     shift and go to state 60
    TEACH_FUNCTION_DECLARATION shift and go to state 61
    TEACH_FUNCTION_CALL shift and go to state 62
    AYUDA           shift and go to state 63
    RETURN          shift and go to state 64
    INT             shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 21
    BOOL            shift and go to state 22
    SEMICOLON       reduce using rule 84 (empty -> .)

    stmt_list                      shift and go to state 157
    stmt                           shift and go to state 42
    assign                         shift and go to state 43
    print                          shift and go to state 44
    conditional                    shift and go to state 45
    loop                           shift and go to state 46
    function_call                  shift and go to state 47
    decl                           shift and go to state 48
    built_in_function              shift and go to state 49
    return_stmt                    shift and go to state 50
    type                           shift and go to state 17
    array_decl                     shift and go to state 18
    empty                          shift and go to state 65

state 153

    (72) function_decl -> type ID LPAREN create_function_scope param_list RPAREN LBRACE . stmt_list end_scopes RBRACE
    (21) stmt_list -> . stmt SEMICOLON stmt_list
    (22) stmt_list -> . stmt SEMICOLON
    (23) stmt -> . assign
    (24) stmt -> . print
    (25) stmt -> . conditional
    (26) stmt -> . loop
    (27) stmt -> . function_call
    (28) stmt -> . decl
    (29) stmt -> . built_in_function
    (30) stmt -> . return_stmt
    (40) assign -> . ID EQUALS expr
    (57) print -> . PRINT COLON expr
    (58) conditional -> . IF LPAREN comp_expr RPAREN LBRACE stmt_list RBRACE else_stmt
    (59) conditional -> . IF LPAREN comp_expr RPAREN LBRACE stmt_list RBRACE
    (70) loop -> . WHILE LPAREN comp_expr RPAREN LBRACE stmt_list RBRACE
    (76) function_call -> . ID LPAREN arg_list RPAREN
    (15) decl -> . type ID
    (16) decl -> . array_decl
    (31) built_in_function -> . TEACH_SUM LPAREN RPAREN
    (32) built_in_function -> . TEACH_SUBSTRACTION LPAREN RPAREN
    (33) built_in_function -> . TEACH_MULTIPLICATION LPAREN RPAREN
    (34) built_in_function -> . TEACH_DIVISION LPAREN RPAREN
    (35) built_in_function -> . TEACH_IF LPAREN RPAREN
    (36) built_in_function -> . TEACH_WHILE LPAREN RPAREN
    (37) built_in_function -> . TEACH_FUNCTION_DECLARATION LPAREN RPAREN
    (38) built_in_function -> . TEACH_FUNCTION_CALL LPAREN RPAREN
    (39) built_in_function -> . AYUDA LPAREN RPAREN
    (74) return_stmt -> . RETURN expr
    (75) return_stmt -> . empty
    (17) type -> . INT
    (18) type -> . FLOAT
    (19) type -> . STRING
    (20) type -> . BOOL
    (83) array_decl -> . type ID LBRACKET CTEI RBRACKET
    (84) empty -> .

    ID              shift and go to state 51
    PRINT           shift and go to state 52
    IF              shift and go to state 53
    WHILE           shift and go to state 54
    TEACH_SUM       shift and go to state 55
    TEACH_SUBSTRACTION shift and go to state 56
    TEACH_MULTIPLICATION shift and go to state 57
    TEACH_DIVISION  shift and go to state 58
    TEACH_IF        shift and go to state 59
    TEACH_WHILE     shift and go to state 60
    TEACH_FUNCTION_DECLARATION shift and go to state 61
    TEACH_FUNCTION_CALL shift and go to state 62
    AYUDA           shift and go to state 63
    RETURN          shift and go to state 64
    INT             shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 21
    BOOL            shift and go to state 22
    SEMICOLON       reduce using rule 84 (empty -> .)

    type                           shift and go to state 17
    stmt_list                      shift and go to state 158
    stmt                           shift and go to state 42
    assign                         shift and go to state 43
    print                          shift and go to state 44
    conditional                    shift and go to state 45
    loop                           shift and go to state 46
    function_call                  shift and go to state 47
    decl                           shift and go to state 48
    built_in_function              shift and go to state 49
    return_stmt                    shift and go to state 50
    array_decl                     shift and go to state 18
    empty                          shift and go to state 65

state 154

    (79) param_list -> param COMMA param_list .

    RPAREN          reduce using rule 79 (param_list -> param COMMA param_list .)


state 155

    (73) function_decl -> VOID ID LPAREN create_function_scope param_list RPAREN LBRACE . stmt_list end_scopes RBRACE
    (21) stmt_list -> . stmt SEMICOLON stmt_list
    (22) stmt_list -> . stmt SEMICOLON
    (23) stmt -> . assign
    (24) stmt -> . print
    (25) stmt -> . conditional
    (26) stmt -> . loop
    (27) stmt -> . function_call
    (28) stmt -> . decl
    (29) stmt -> . built_in_function
    (30) stmt -> . return_stmt
    (40) assign -> . ID EQUALS expr
    (57) print -> . PRINT COLON expr
    (58) conditional -> . IF LPAREN comp_expr RPAREN LBRACE stmt_list RBRACE else_stmt
    (59) conditional -> . IF LPAREN comp_expr RPAREN LBRACE stmt_list RBRACE
    (70) loop -> . WHILE LPAREN comp_expr RPAREN LBRACE stmt_list RBRACE
    (76) function_call -> . ID LPAREN arg_list RPAREN
    (15) decl -> . type ID
    (16) decl -> . array_decl
    (31) built_in_function -> . TEACH_SUM LPAREN RPAREN
    (32) built_in_function -> . TEACH_SUBSTRACTION LPAREN RPAREN
    (33) built_in_function -> . TEACH_MULTIPLICATION LPAREN RPAREN
    (34) built_in_function -> . TEACH_DIVISION LPAREN RPAREN
    (35) built_in_function -> . TEACH_IF LPAREN RPAREN
    (36) built_in_function -> . TEACH_WHILE LPAREN RPAREN
    (37) built_in_function -> . TEACH_FUNCTION_DECLARATION LPAREN RPAREN
    (38) built_in_function -> . TEACH_FUNCTION_CALL LPAREN RPAREN
    (39) built_in_function -> . AYUDA LPAREN RPAREN
    (74) return_stmt -> . RETURN expr
    (75) return_stmt -> . empty
    (17) type -> . INT
    (18) type -> . FLOAT
    (19) type -> . STRING
    (20) type -> . BOOL
    (83) array_decl -> . type ID LBRACKET CTEI RBRACKET
    (84) empty -> .

    ID              shift and go to state 51
    PRINT           shift and go to state 52
    IF              shift and go to state 53
    WHILE           shift and go to state 54
    TEACH_SUM       shift and go to state 55
    TEACH_SUBSTRACTION shift and go to state 56
    TEACH_MULTIPLICATION shift and go to state 57
    TEACH_DIVISION  shift and go to state 58
    TEACH_IF        shift and go to state 59
    TEACH_WHILE     shift and go to state 60
    TEACH_FUNCTION_DECLARATION shift and go to state 61
    TEACH_FUNCTION_CALL shift and go to state 62
    AYUDA           shift and go to state 63
    RETURN          shift and go to state 64
    INT             shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 21
    BOOL            shift and go to state 22
    SEMICOLON       reduce using rule 84 (empty -> .)

    stmt_list                      shift and go to state 159
    stmt                           shift and go to state 42
    assign                         shift and go to state 43
    print                          shift and go to state 44
    conditional                    shift and go to state 45
    loop                           shift and go to state 46
    function_call                  shift and go to state 47
    decl                           shift and go to state 48
    built_in_function              shift and go to state 49
    return_stmt                    shift and go to state 50
    type                           shift and go to state 17
    array_decl                     shift and go to state 18
    empty                          shift and go to state 65

state 156

    (58) conditional -> IF LPAREN comp_expr RPAREN LBRACE stmt_list . RBRACE else_stmt
    (59) conditional -> IF LPAREN comp_expr RPAREN LBRACE stmt_list . RBRACE

    RBRACE          shift and go to state 160


state 157

    (70) loop -> WHILE LPAREN comp_expr RPAREN LBRACE stmt_list . RBRACE

    RBRACE          shift and go to state 161


state 158

    (72) function_decl -> type ID LPAREN create_function_scope param_list RPAREN LBRACE stmt_list . end_scopes RBRACE
    (11) end_scopes -> .

    RBRACE          reduce using rule 11 (end_scopes -> .)

    end_scopes                     shift and go to state 162

state 159

    (73) function_decl -> VOID ID LPAREN create_function_scope param_list RPAREN LBRACE stmt_list . end_scopes RBRACE
    (11) end_scopes -> .

    RBRACE          reduce using rule 11 (end_scopes -> .)

    end_scopes                     shift and go to state 163

state 160

    (58) conditional -> IF LPAREN comp_expr RPAREN LBRACE stmt_list RBRACE . else_stmt
    (59) conditional -> IF LPAREN comp_expr RPAREN LBRACE stmt_list RBRACE .
    (67) else_stmt -> . ELSE LBRACE else_part stmt_list RBRACE
    (68) else_stmt -> . empty
    (84) empty -> .

  ! reduce/reduce conflict for SEMICOLON resolved using rule 59 (conditional -> IF LPAREN comp_expr RPAREN LBRACE stmt_list RBRACE .)
    SEMICOLON       reduce using rule 59 (conditional -> IF LPAREN comp_expr RPAREN LBRACE stmt_list RBRACE .)
    ELSE            shift and go to state 165

  ! SEMICOLON       [ reduce using rule 84 (empty -> .) ]

    else_stmt                      shift and go to state 164
    empty                          shift and go to state 166

state 161

    (70) loop -> WHILE LPAREN comp_expr RPAREN LBRACE stmt_list RBRACE .

    SEMICOLON       reduce using rule 70 (loop -> WHILE LPAREN comp_expr RPAREN LBRACE stmt_list RBRACE .)


state 162

    (72) function_decl -> type ID LPAREN create_function_scope param_list RPAREN LBRACE stmt_list end_scopes . RBRACE

    RBRACE          shift and go to state 167


state 163

    (73) function_decl -> VOID ID LPAREN create_function_scope param_list RPAREN LBRACE stmt_list end_scopes . RBRACE

    RBRACE          shift and go to state 168


state 164

    (58) conditional -> IF LPAREN comp_expr RPAREN LBRACE stmt_list RBRACE else_stmt .

    SEMICOLON       reduce using rule 58 (conditional -> IF LPAREN comp_expr RPAREN LBRACE stmt_list RBRACE else_stmt .)


state 165

    (67) else_stmt -> ELSE . LBRACE else_part stmt_list RBRACE

    LBRACE          shift and go to state 169


state 166

    (68) else_stmt -> empty .

    SEMICOLON       reduce using rule 68 (else_stmt -> empty .)


state 167

    (72) function_decl -> type ID LPAREN create_function_scope param_list RPAREN LBRACE stmt_list end_scopes RBRACE .

    VOID            reduce using rule 72 (function_decl -> type ID LPAREN create_function_scope param_list RPAREN LBRACE stmt_list end_scopes RBRACE .)
    INT             reduce using rule 72 (function_decl -> type ID LPAREN create_function_scope param_list RPAREN LBRACE stmt_list end_scopes RBRACE .)
    FLOAT           reduce using rule 72 (function_decl -> type ID LPAREN create_function_scope param_list RPAREN LBRACE stmt_list end_scopes RBRACE .)
    STRING          reduce using rule 72 (function_decl -> type ID LPAREN create_function_scope param_list RPAREN LBRACE stmt_list end_scopes RBRACE .)
    BOOL            reduce using rule 72 (function_decl -> type ID LPAREN create_function_scope param_list RPAREN LBRACE stmt_list end_scopes RBRACE .)
    MAIN            reduce using rule 72 (function_decl -> type ID LPAREN create_function_scope param_list RPAREN LBRACE stmt_list end_scopes RBRACE .)


state 168

    (73) function_decl -> VOID ID LPAREN create_function_scope param_list RPAREN LBRACE stmt_list end_scopes RBRACE .

    VOID            reduce using rule 73 (function_decl -> VOID ID LPAREN create_function_scope param_list RPAREN LBRACE stmt_list end_scopes RBRACE .)
    INT             reduce using rule 73 (function_decl -> VOID ID LPAREN create_function_scope param_list RPAREN LBRACE stmt_list end_scopes RBRACE .)
    FLOAT           reduce using rule 73 (function_decl -> VOID ID LPAREN create_function_scope param_list RPAREN LBRACE stmt_list end_scopes RBRACE .)
    STRING          reduce using rule 73 (function_decl -> VOID ID LPAREN create_function_scope param_list RPAREN LBRACE stmt_list end_scopes RBRACE .)
    BOOL            reduce using rule 73 (function_decl -> VOID ID LPAREN create_function_scope param_list RPAREN LBRACE stmt_list end_scopes RBRACE .)
    MAIN            reduce using rule 73 (function_decl -> VOID ID LPAREN create_function_scope param_list RPAREN LBRACE stmt_list end_scopes RBRACE .)


state 169

    (67) else_stmt -> ELSE LBRACE . else_part stmt_list RBRACE
    (69) else_part -> .

    ID              reduce using rule 69 (else_part -> .)
    PRINT           reduce using rule 69 (else_part -> .)
    IF              reduce using rule 69 (else_part -> .)
    WHILE           reduce using rule 69 (else_part -> .)
    TEACH_SUM       reduce using rule 69 (else_part -> .)
    TEACH_SUBSTRACTION reduce using rule 69 (else_part -> .)
    TEACH_MULTIPLICATION reduce using rule 69 (else_part -> .)
    TEACH_DIVISION  reduce using rule 69 (else_part -> .)
    TEACH_IF        reduce using rule 69 (else_part -> .)
    TEACH_WHILE     reduce using rule 69 (else_part -> .)
    TEACH_FUNCTION_DECLARATION reduce using rule 69 (else_part -> .)
    TEACH_FUNCTION_CALL reduce using rule 69 (else_part -> .)
    AYUDA           reduce using rule 69 (else_part -> .)
    RETURN          reduce using rule 69 (else_part -> .)
    INT             reduce using rule 69 (else_part -> .)
    FLOAT           reduce using rule 69 (else_part -> .)
    STRING          reduce using rule 69 (else_part -> .)
    BOOL            reduce using rule 69 (else_part -> .)
    SEMICOLON       reduce using rule 69 (else_part -> .)

    else_part                      shift and go to state 170

state 170

    (67) else_stmt -> ELSE LBRACE else_part . stmt_list RBRACE
    (21) stmt_list -> . stmt SEMICOLON stmt_list
    (22) stmt_list -> . stmt SEMICOLON
    (23) stmt -> . assign
    (24) stmt -> . print
    (25) stmt -> . conditional
    (26) stmt -> . loop
    (27) stmt -> . function_call
    (28) stmt -> . decl
    (29) stmt -> . built_in_function
    (30) stmt -> . return_stmt
    (40) assign -> . ID EQUALS expr
    (57) print -> . PRINT COLON expr
    (58) conditional -> . IF LPAREN comp_expr RPAREN LBRACE stmt_list RBRACE else_stmt
    (59) conditional -> . IF LPAREN comp_expr RPAREN LBRACE stmt_list RBRACE
    (70) loop -> . WHILE LPAREN comp_expr RPAREN LBRACE stmt_list RBRACE
    (76) function_call -> . ID LPAREN arg_list RPAREN
    (15) decl -> . type ID
    (16) decl -> . array_decl
    (31) built_in_function -> . TEACH_SUM LPAREN RPAREN
    (32) built_in_function -> . TEACH_SUBSTRACTION LPAREN RPAREN
    (33) built_in_function -> . TEACH_MULTIPLICATION LPAREN RPAREN
    (34) built_in_function -> . TEACH_DIVISION LPAREN RPAREN
    (35) built_in_function -> . TEACH_IF LPAREN RPAREN
    (36) built_in_function -> . TEACH_WHILE LPAREN RPAREN
    (37) built_in_function -> . TEACH_FUNCTION_DECLARATION LPAREN RPAREN
    (38) built_in_function -> . TEACH_FUNCTION_CALL LPAREN RPAREN
    (39) built_in_function -> . AYUDA LPAREN RPAREN
    (74) return_stmt -> . RETURN expr
    (75) return_stmt -> . empty
    (17) type -> . INT
    (18) type -> . FLOAT
    (19) type -> . STRING
    (20) type -> . BOOL
    (83) array_decl -> . type ID LBRACKET CTEI RBRACKET
    (84) empty -> .

    ID              shift and go to state 51
    PRINT           shift and go to state 52
    IF              shift and go to state 53
    WHILE           shift and go to state 54
    TEACH_SUM       shift and go to state 55
    TEACH_SUBSTRACTION shift and go to state 56
    TEACH_MULTIPLICATION shift and go to state 57
    TEACH_DIVISION  shift and go to state 58
    TEACH_IF        shift and go to state 59
    TEACH_WHILE     shift and go to state 60
    TEACH_FUNCTION_DECLARATION shift and go to state 61
    TEACH_FUNCTION_CALL shift and go to state 62
    AYUDA           shift and go to state 63
    RETURN          shift and go to state 64
    INT             shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 21
    BOOL            shift and go to state 22
    SEMICOLON       reduce using rule 84 (empty -> .)

    stmt_list                      shift and go to state 171
    stmt                           shift and go to state 42
    assign                         shift and go to state 43
    print                          shift and go to state 44
    conditional                    shift and go to state 45
    loop                           shift and go to state 46
    function_call                  shift and go to state 47
    decl                           shift and go to state 48
    built_in_function              shift and go to state 49
    return_stmt                    shift and go to state 50
    type                           shift and go to state 17
    array_decl                     shift and go to state 18
    empty                          shift and go to state 65

state 171

    (67) else_stmt -> ELSE LBRACE else_part stmt_list . RBRACE

    RBRACE          shift and go to state 172


state 172

    (67) else_stmt -> ELSE LBRACE else_part stmt_list RBRACE .

    SEMICOLON       reduce using rule 67 (else_stmt -> ELSE LBRACE else_part stmt_list RBRACE .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: reduce/reduce conflict in state 25 resolved using rule (global_scope -> VARIABLES LBRACE decl_list RBRACE)
WARNING: rejected rule (empty -> <empty>) in state 25
WARNING: reduce/reduce conflict in state 26 resolved using rule (decl_list -> decl SEMICOLON)
WARNING: rejected rule (empty -> <empty>) in state 26
WARNING: reduce/reduce conflict in state 88 resolved using rule (term -> function_call)
WARNING: rejected rule (factor -> function_call) in state 88
WARNING: reduce/reduce conflict in state 151 resolved using rule (expr -> expr comp_op term)
WARNING: rejected rule (expr -> term) in state 151
WARNING: reduce/reduce conflict in state 160 resolved using rule (conditional -> IF LPAREN comp_expr RPAREN LBRACE stmt_list RBRACE)
WARNING: rejected rule (empty -> <empty>) in state 160
